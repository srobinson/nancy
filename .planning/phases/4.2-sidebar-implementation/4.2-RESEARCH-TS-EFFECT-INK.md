# Research: TS/Effect/Ink TUI Architecture

**Researched:** 2026-01-15
**Domain:** Rich TUI with CLI/Electron/Web portability
**Confidence:** HIGH (production libraries, documented patterns)

<research_summary>
## Summary

Researched the stack for building a rich TUI that can evolve to Electron and Web. The recommended architecture separates concerns into layers that can be rendered to different targets.

**Recommended Stack:**
- **Core Logic:** Effect-TS (typed effects, process management, streaming)
- **CLI UI:** Ink + @inkjs/ui (React for terminal, production ready)
- **Shared UI:** React components (portable to Electron/Web)
- **Process Management:** @effect/platform Command module

**Key Findings:**
1. Ink HAS mouse support (via escape sequences + useInput hook)
2. Effect has excellent process streaming with @effect/platform
3. Monorepo architecture enables code sharing across targets
4. OpenTUI exists but NOT production ready

**Primary Recommendation:** Start with Ink for CLI, structure code for future portability.
</research_summary>

<standard_stack>
## Standard Stack

### Core (Shared Across All Platforms)
| Library | Purpose | Why |
|---------|---------|-----|
| effect | Typed effects, error handling, concurrency | Best-in-class for TS side effects |
| @effect/platform | Process management, streaming | Command module for subprocess handling |
| @effect/schema | Runtime validation, codecs | Shared data validation |

### CLI Layer
| Library | Version | Purpose | Production Ready |
|---------|---------|---------|------------------|
| ink | 5.x | React renderer for terminal | YES |
| @inkjs/ui | latest | Select, Spinner, ProgressBar components | YES |
| react | 18.x | Component model | YES |

### Future Layers (Same React Components)
| Target | Renderer | Notes |
|--------|----------|-------|
| Electron | react-dom | Same components, electron-specific bindings |
| Web | react-dom | Same components, browser APIs |

### Alternatives Considered
| Library | Status | Why Not |
|---------|--------|---------|
| OpenTUI (sst/opentui) | NOT production ready | "Currently in development, not ready for production" |
| better-opentui | Experimental | Effect-TS reimplementation, too early |
| Blessed | Mature but dated | Not React-based, harder to share with web |
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Pattern: Layered Monorepo

```
packages/
├── core/                 # Effect-TS business logic (NO UI)
│   ├── src/
│   │   ├── agents/       # Agent process management
│   │   ├── orchestration/ # Orchestration logic
│   │   └── effects/      # Shared Effect definitions
│   └── package.json
│
├── ui-components/        # React components (portable)
│   ├── src/
│   │   ├── Sidebar.tsx
│   │   ├── AgentPane.tsx
│   │   └── Navigation.tsx
│   └── package.json
│
├── cli/                  # Ink application
│   ├── src/
│   │   ├── App.tsx       # Root Ink component
│   │   └── index.ts      # Entry point
│   └── package.json
│
├── electron/             # Future: Electron app
│   └── package.json
│
└── web/                  # Future: Web app
    └── package.json
```

### Pattern: Effect for Process Management

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect, Stream, String, pipe } from "effect"

// Spawn agent process with streaming output
const spawnAgent = (agentCommand: string) =>
  Effect.gen(function* () {
    const command = Command.make("claude", ["code", "--task", agentCommand])

    const process = yield* Command.start(command)

    // Stream stdout in real-time
    const stdoutStream = process.stdout.pipe(
      Stream.decodeText(),
      Stream.tap((line) => Effect.log(`Agent output: ${line}`))
    )

    return {
      process,
      stdout: stdoutStream,
      exitCode: process.exitCode
    }
  })
```

### Pattern: Ink with Mouse Support

```typescript
import React, { useState, useEffect } from 'react'
import { render, Box, Text, useInput, useStdout } from 'ink'

// Enable mouse tracking
function useMouse() {
  const { stdout } = useStdout()
  const [mouse, setMouse] = useState({ x: 0, y: 0, button: null })

  useEffect(() => {
    // Enable mouse tracking
    stdout.write('\x1b[?1003h') // All mouse events
    return () => stdout.write('\x1b[?1003l') // Disable on cleanup
  }, [stdout])

  useInput((input, key) => {
    // key.mouse contains { x, y, action, button } when mouse tracking enabled
    if (key.mouse) {
      setMouse(key.mouse)
    }
  })

  return mouse
}

// Clickable navigation item
function NavItem({ label, isActive, onClick }) {
  const mouse = useMouse()
  // Track if mouse is over this item and clicked
  // (requires tracking component position)

  return (
    <Box>
      <Text color={isActive ? 'cyan' : 'white'}>
        {isActive ? '▶ ' : '  '}{label}
      </Text>
    </Box>
  )
}
```

### Pattern: Sidebar Layout with Ink

```typescript
import { render, Box, Text } from 'ink'

function App() {
  const [activeAgent, setActiveAgent] = useState(1)

  return (
    <Box flexDirection="row" width="100%" height="100%">
      {/* Sidebar - 20% */}
      <Box
        width="20%"
        borderStyle="single"
        flexDirection="column"
        padding={1}
      >
        <Text bold>Navigation</Text>
        <NavItem label="Agent 1" isActive={activeAgent === 1} />
        <NavItem label="Agent 2" isActive={activeAgent === 2} />
        <NavItem label="Agent 3" isActive={activeAgent === 3} />
      </Box>

      {/* Main area - 80% */}
      <Box width="80%" borderStyle="single" padding={1}>
        <AgentOutput agentId={activeAgent} />
      </Box>
    </Box>
  )
}

render(<App />)
```

### Pattern: Effect + React Integration

```typescript
import { useMemo, useCallback, useState, useEffect } from 'react'
import { Effect, Stream, Fiber } from 'effect'

function useEffectStream<A>(stream: Stream.Stream<A>) {
  const [items, setItems] = useState<A[]>([])
  const [fiber, setFiber] = useState<Fiber.RuntimeFiber<void> | null>(null)

  useEffect(() => {
    const runnable = stream.pipe(
      Stream.tap((item) => Effect.sync(() => {
        setItems(prev => [...prev, item])
      })),
      Stream.runDrain
    )

    const f = Effect.runFork(runnable)
    setFiber(f)

    return () => {
      if (f) Effect.runPromise(Fiber.interrupt(f))
    }
  }, [stream])

  return items
}
```
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Terminal rendering | ANSI escape sequences | Ink | React model, maintained |
| Process streaming | Node child_process | @effect/platform Command | Typed, resource-safe |
| Select UI | Custom arrow key handling | @inkjs/ui Select | Battle-tested |
| State management | Custom | Effect Ref/SubscriptionRef | Concurrent-safe |
| Error handling | try/catch | Effect | Typed errors, composition |
| Flexbox terminal layout | Manual positioning | Ink Box | CSS-like flexbox |

**Key insight:** Ink + Effect gives you the best of both worlds - React's component model for UI and Effect's typed effects for business logic.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Mouse Support Complexity
**What goes wrong:** Expecting onClick handlers like browser React
**Why it happens:** Terminal mouse events work via escape sequences
**How to avoid:**
- Enable mouse tracking: `\x1b[?1003h`
- Parse events from useInput's key.mouse
- Track component positions manually for hit testing
**Alternative:** Use keyboard navigation primarily, mouse as enhancement

### Pitfall 2: Full-Screen Layout
**What goes wrong:** Ink components don't fill terminal by default
**Why it happens:** No viewport concept like browser
**How to avoid:**
- Use `useStdout` to get terminal dimensions
- Set explicit width/height on root Box
- Use `fullscreen` render option

### Pitfall 3: Process Output Buffering
**What goes wrong:** Agent output appears in chunks, not real-time
**Why it happens:** Node.js stream buffering
**How to avoid:**
- Use Effect Stream for proper backpressure
- Consider PTY for true terminal emulation
- Set `{ encoding: 'utf8' }` on streams

### Pitfall 4: Effect + React Lifecycle
**What goes wrong:** Effects don't cleanup on unmount
**Why it happens:** React lifecycle ≠ Effect lifecycle
**How to avoid:**
- Run Effects with Fiber, store fiber reference
- Interrupt fiber in useEffect cleanup
- Use Effect.acquireRelease for resources
</common_pitfalls>

<code_examples>
## Code Examples

### Basic Ink App with Layout
```typescript
// Source: Ink docs + verified patterns
import React from 'react'
import { render, Box, Text } from 'ink'

function App() {
  return (
    <Box flexDirection="column" width={80} height={24}>
      <Box borderStyle="round" borderColor="cyan" padding={1}>
        <Text bold>Header</Text>
      </Box>

      <Box flexGrow={1} flexDirection="row">
        <Box width="30%" borderStyle="single" padding={1}>
          <Text>Sidebar</Text>
        </Box>
        <Box flexGrow={1} borderStyle="single" padding={1}>
          <Text>Main Content</Text>
        </Box>
      </Box>
    </Box>
  )
}

render(<App />)
```

### Ink Select Component
```typescript
// Source: @inkjs/ui docs
import React, { useState } from 'react'
import { render, Box, Text } from 'ink'
import { Select } from '@inkjs/ui'

function AgentSelector() {
  const [agent, setAgent] = useState('agent1')

  return (
    <Box flexDirection="column" gap={1}>
      <Select
        options={[
          { label: 'Agent 1 - Worker', value: 'agent1' },
          { label: 'Agent 2 - Orchestrator', value: 'agent2' },
          { label: 'Agent 3 - Reviewer', value: 'agent3' },
        ]}
        onChange={setAgent}
      />
      <Text>Selected: {agent}</Text>
    </Box>
  )
}
```

### Effect Process Streaming
```typescript
// Source: @effect/platform docs
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect, Stream } from "effect"

const runAgent = Effect.gen(function* () {
  const command = Command.make("echo", ["Hello from agent"])

  const [exitCode, stdout] = yield* pipe(
    Command.start(command),
    Effect.flatMap((process) =>
      Effect.all([
        process.exitCode,
        process.stdout.pipe(
          Stream.decodeText(),
          Stream.runCollect
        )
      ], { concurrency: 2 })
    )
  )

  console.log({ exitCode, stdout: Array.from(stdout).join('') })
})

NodeRuntime.runMain(
  Effect.scoped(runAgent).pipe(Effect.provide(NodeContext.layer))
)
```
</code_examples>

<open_questions>
## Open Questions

1. **Mouse hit testing in Ink?**
   - Ink provides mouse x,y but not component bounds
   - May need custom hook to track component positions
   - Alternative: keyboard-first with optional mouse

2. **PTY for true terminal emulation?**
   - Agents output may need PTY for colors/cursor
   - node-pty or Effect equivalent?
   - Adds complexity but better fidelity

3. **Electron rendering strategy?**
   - xterm.js in Electron for terminal-like experience?
   - Or native React components for richer UI?
   - Decision affects how much code is shared
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [Ink GitHub](https://github.com/vadimdemedes/ink) - React for CLI, 27k stars
- [@inkjs/ui](https://github.com/vadimdemedes/ink-ui) - UI components
- [Effect docs](https://effect.website) - Effect-TS documentation
- [@effect/platform docs](https://effect.website/docs/platform/command) - Process management

### Secondary (MEDIUM confidence)
- [OpenTUI](https://github.com/sst/opentui) - Not production ready, but interesting
- [better-opentui](https://github.com/oetzilabs/better-opentui) - Effect-TS experiment
- [Mouse events in terminal](https://app.studyraid.com/en/read/11921/379938/mouse-events-in-terminal) - Mouse handling patterns
- [LogRocket Ink UI guide](https://blog.logrocket.com/using-ink-ui-react-build-interactive-custom-clis/) - 2024 tutorial

### Architecture References
- [react-native-universal-monorepo](https://github.com/mmazzarolo/react-native-universal-monorepo) - Multi-platform pattern
- [DevHub](https://github.com/devhubapp/devhub) - 6-platform app sharing code
</sources>

<next_steps>
## Recommended Next Steps

1. **Scaffold monorepo** with pnpm workspaces:
   - `packages/core` - Effect-TS logic
   - `packages/cli` - Ink application

2. **Prototype core features**:
   - Process spawning with @effect/platform
   - Streaming output to Ink component
   - Basic sidebar layout

3. **Validate mouse support**:
   - Test escape sequence approach
   - Decide keyboard-first vs mouse-first

4. **Define UI component contracts**:
   - Props interface for Sidebar, AgentPane, etc.
   - Keep React-only, no Ink-specific deps in shared components
</next_steps>

---

*Research completed: 2026-01-15*
*Ready for new codebase: YES*
