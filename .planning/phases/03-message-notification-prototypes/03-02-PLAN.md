<!-- b_path:: .planning/phases/03-message-notification-prototypes/03-02-PLAN.md -->
---
phase: 03-message-notification-prototypes
plan: 02
type: execute
domain: bash
---

<objective>
Create fswatch-based file watcher that monitors orchestrator inbox and triggers notifications.

Purpose: Implement the file watching mechanism that detects new worker messages and calls the notify module to alert the orchestrator.
Output: `src/notify/watcher.sh` with file watching functions, updated `cmd::_logs` to use message relay mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan in this phase:**
@.planning/phases/03-message-notification-prototypes/03-01-PLAN.md

**Research:**
@.planning/phases/03-message-notification-prototypes/03-RESEARCH.md

**Relevant source files:**
@src/notify/index.sh (created in 03-01)
@src/notify/tmux.sh (created in 03-01)
@src/cmd/internal.sh
@src/comms/comms.sh

**From RESEARCH.md - Standard stack:**
- fswatch 1.18.3 - File change monitor, uses native FSEvents on macOS

**From RESEARCH.md - Don't hand-roll:**
- File watching: Use fswatch, not polling loop with ls/stat

**From RESEARCH.md - Pitfalls to avoid:**
- Pitfall 2: fswatch not installed - check availability, provide clear error
- Pitfall 5: Race condition on message read - wait briefly after creation event
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create watcher.sh with fswatch-based inbox monitoring</name>
  <files>src/notify/watcher.sh</files>
  <action>
Create file watcher functions:

1. `notify::check_fswatch`
   - Check if fswatch is installed: `command -v fswatch &>/dev/null`
   - If missing, log error with install instructions: "fswatch required: brew install fswatch"
   - Return 1 if missing, 0 if available

2. `notify::watch_inbox <task>`
   - Watches orchestrator inbox: `$NANCY_TASK_DIR/$task/comms/orchestrator/inbox`
   - Uses fswatch with null-delimited output for safety: `fswatch -0 "$inbox_dir"`
   - For each new .md file:
     - Sleep 0.1s to ensure file is fully written (pitfall 5)
     - Call `notify::worker_message "$task" "$event"`
     - Echo event to stdout for logs pane display
   - Run in foreground (blocking loop)
   - Handle SIGINT/SIGTERM gracefully

3. `notify::watch_inbox_bg <task>`
   - Same as watch_inbox but backgrounds the fswatch process
   - Store PID in `$NANCY_TASK_DIR/$task/.watcher_pid`
   - Return immediately

4. `notify::stop_watcher <task>`
   - Read PID from `$NANCY_TASK_DIR/$task/.watcher_pid`
   - Kill the watcher process if running
   - Remove PID file

Include at top of file:
```bash
# Check fswatch availability on source
if ! command -v fswatch &>/dev/null; then
    log::warn "fswatch not installed - notification watching disabled"
    log::warn "Install with: brew install fswatch"
fi
```

This way the module loads but warns if fswatch missing.
  </action>
  <verify>
source src/notify/index.sh && type notify::check_fswatch && type notify::watch_inbox
  </verify>
  <done>watcher.sh sources without error, functions defined, fswatch check works</done>
</task>

<task type="auto">
  <name>Task 2: Update notify/index.sh to source watcher.sh</name>
  <files>src/notify/index.sh</files>
  <action>
Add watcher.sh to the notify module loader:

```bash
source "${BASH_SOURCE%/*}/watcher.sh"
```

Place after tmux.sh since watcher depends on notify::worker_message from tmux.sh.
  </action>
  <verify>source src/notify/index.sh && type notify::watch_inbox</verify>
  <done>watcher functions available after sourcing notify module</done>
</task>

<task type="auto">
  <name>Task 3: Create cmd::_logs_v2 with message relay mode</name>
  <files>src/cmd/internal.sh</files>
  <action>
Add new `cmd::_logs_v2` function that acts as message relay instead of session log viewer.

```bash
cmd::_logs_v2() {
    local task="$1"

    if [[ -z "$task" ]]; then
        log::error "Usage: nancy _logs_v2 <task>"
        return 1
    fi

    if ! task::exists "$task"; then
        log::error "Task '$task' not found"
        return 1
    fi

    ui::header "ðŸ“¬ Messages - $task"
    echo ""

    # Check fswatch availability
    if ! notify::check_fswatch; then
        ui::error "Cannot start message relay without fswatch"
        ui::muted "Install with: brew install fswatch"
        ui::muted ""
        ui::muted "Falling back to session log viewer..."
        cmd::_logs "$task"
        return
    fi

    config::load_task "$task"
    local inbox_dir="$NANCY_TASK_DIR/$task/comms/orchestrator/inbox"

    # Ensure inbox exists
    mkdir -p "$inbox_dir"

    ui::success "Watching for worker messages..."
    ui::muted "Inbox: $inbox_dir"
    echo "---"

    # Start watching (blocking)
    notify::watch_inbox "$task"
}
```

DO NOT modify existing cmd::_logs - it remains as fallback and for session viewing.
Add cmd::_logs_v2 as new function.
  </action>
  <verify>grep -q "cmd::_logs_v2" src/cmd/internal.sh</verify>
  <done>_logs_v2 function exists, falls back to _logs if fswatch missing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `source src/notify/index.sh` succeeds
- [ ] `notify::check_fswatch` returns correct status based on fswatch availability
- [ ] `notify::watch_inbox` function is defined
- [ ] `cmd::_logs_v2` exists in internal.sh
- [ ] `cmd::_logs_v2` gracefully falls back if fswatch missing
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- File watcher ready for testing
- Graceful degradation if fswatch not installed
</success_criteria>

<output>
After completion, create `.planning/phases/03-message-notification-prototypes/03-02-SUMMARY.md`
</output>
