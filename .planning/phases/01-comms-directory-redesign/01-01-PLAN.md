<!-- b_path:: .planning/phases/01-comms-directory-redesign/01-01-PLAN.md -->
---
phase: 01-comms-directory-redesign
plan: 01
type: execute
---

<objective>
Restructure comms directory for bidirectional message flow with inbox/outbox pattern.

Purpose: Enable workers to send messages to orchestrator (blockers, progress, review requests) - foundation for two-way communication.
Output: New comms module with inbox/outbox structure supporting both directions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STRUCTURE.md
@src/comms/comms.sh

**Existing comms structure:**
- `comms/directives/` - orchestrator → worker messages
- `comms/acks/` - worker acknowledgments to directives
- `comms/archive/` - processed directives

**Target structure (inbox/outbox pattern):**
- `comms/orchestrator/inbox/` - messages TO orchestrator (from worker)
- `comms/orchestrator/outbox/` - messages FROM orchestrator (directives, to worker)
- `comms/worker/inbox/` - messages TO worker (from orchestrator)
- `comms/worker/outbox/` - messages FROM worker (to orchestrator)
- `comms/archive/` - all processed messages

**Message types for worker → orchestrator:**
- `blocker` - Worker is blocked, needs help
- `progress` - Status update
- `review-request` - Worker wants review of completed work

**Constraint:** ZERO backward compatibility required (clean break).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create new comms module with inbox/outbox functions</name>
  <files>src/comms/comms.sh</files>
  <action>
Replace entire comms.sh with new implementation:

1. Define constants for directories:
   - COMMS_ORCHESTRATOR_INBOX, COMMS_ORCHESTRATOR_OUTBOX
   - COMMS_WORKER_INBOX, COMMS_WORKER_OUTBOX
   - COMMS_ARCHIVE

2. Create `comms::init <task>` - creates all comms directories for a task

3. Create `comms::send <task> <from> <to> <type> <message>`:
   - `from`: "orchestrator" or "worker"
   - `to`: "orchestrator" or "worker"
   - Writes to sender's outbox AND recipient's inbox (same file, two locations for clarity)
   - Actually just write to recipient's inbox (simpler - outbox not needed for MVP)
   - Format: timestamped markdown with type, priority, content
   - Returns filename

4. Create `comms::read_inbox <task> <role>`:
   - `role`: "orchestrator" or "worker"
   - Lists all pending messages in inbox
   - Returns list of filenames

5. Create `comms::archive <task> <role> <filename>`:
   - Moves message from inbox to archive
   - Preserves original filename with archive timestamp prefix

Keep function namespacing pattern: `comms::function_name`.
Use existing code style (see log.sh, task.sh for reference).
  </action>
  <verify>source src/comms/index.sh && type comms::send && type comms::read_inbox && type comms::archive</verify>
  <done>New comms functions defined: comms::init, comms::send, comms::read_inbox, comms::archive</done>
</task>

<task type="auto">
  <name>Task 2: Define message format and types</name>
  <files>src/comms/comms.sh</files>
  <action>
Add message format generation within comms::send:

Message file format (markdown):
```
# Message

**Type:** blocker|progress|review-request|directive|guidance
**From:** orchestrator|worker
**Priority:** urgent|normal|low
**Time:** ISO 8601 timestamp

## Content

{message content}
```

Define valid message types as array:
- COMMS_WORKER_TYPES=("blocker" "progress" "review-request")
- COMMS_ORCHESTRATOR_TYPES=("directive" "guidance" "stop")

Add validation in comms::send to check type is valid for sender role.
  </action>
  <verify>source src/comms/index.sh && comms::send "test-task" "worker" "orchestrator" "blocker" "test message" 2>&1 | head -5</verify>
  <done>Message format defined, type validation implemented, test message creates valid markdown file</done>
</task>

<task type="auto">
  <name>Task 3: Update comms index and add helper functions</name>
  <files>src/comms/index.sh, src/comms/comms.sh</files>
  <action>
1. Ensure src/comms/index.sh sources comms.sh correctly (should already work)

2. Add convenience functions to comms.sh:
   - `comms::worker_send <task> <type> <message>` - shorthand for worker sending to orchestrator
   - `comms::orchestrator_send <task> <type> <message>` - shorthand for orchestrator sending to worker
   - `comms::has_messages <task> <role>` - returns 0 if inbox has messages, 1 if empty

3. Add `comms::get_dir <task> <role> <box>` helper:
   - Returns full path to inbox/outbox directory
   - `role`: orchestrator|worker
   - `box`: inbox|outbox (outbox reserved for future use)
  </action>
  <verify>source src/comms/index.sh && comms::worker_send "test-task" "progress" "test" && comms::has_messages "test-task" "orchestrator" && echo "OK"</verify>
  <done>Index loads correctly, convenience functions work, has_messages returns correct status</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `source nancy && source src/comms/index.sh` loads without errors
- [ ] `comms::init "test"` creates directory structure
- [ ] `comms::worker_send "test" "blocker" "help"` creates message file
- [ ] `comms::read_inbox "test" "orchestrator"` lists the message
- [ ] `comms::archive "test" "orchestrator" <filename>` moves to archive
- [ ] Message file follows defined markdown format
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- New comms module supports bidirectional messaging
- Worker can send blocker/progress/review-request to orchestrator
- Orchestrator can send directive/guidance/stop to worker
- Clean inbox/outbox directory structure in place
</success_criteria>

<output>
After completion, create `.planning/phases/01-comms-directory-redesign/01-01-SUMMARY.md` following summary template.

Include:
- New directory structure created
- Functions implemented
- Message format specification
- Any deviations from plan
</output>
