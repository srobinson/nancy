# Storage Format Research: What Modern Developer Tools Use and Why

**Research Date:** 2026-01-24
**Focus:** Configuration and metadata storage formats in developer tools (2024-2026)
**Purpose:** Inform Nancy's storage format decisions for beads/configuration

---

## Executive Summary

Modern developer tools (2024-2026) show clear format preferences by category:

- **Developer Environment Tools**: Strongly prefer TOML (Rust/Python ecosystems) or Nix DSL
- **LLM/AI Tools**: Migrating from JSON to YAML for better human readability
- **CI/CD & Infrastructure**: YAML dominates (GitHub Actions, Kubernetes)
- **Node.js Ecosystem**: JSON remains standard (package.json)
- **Task Runners**: Split between YAML (Task) and Make-like DSL (Just)
- **Package Managers**: TOML (Cargo, pyproject.toml) or JSON (npm)

**Key Trend**: Tools are moving away from JSON for human-edited configs, preferring TOML (explicit, safe) or YAML (readable, familiar) depending on ecosystem.

---

## 1. Dotfiles/Config Managers

### chezmoi
**Storage Format**: Multi-format support (JSON, JSONC, TOML, YAML)
**Location**: `$HOME/.config/chezmoi/chezmoi.$FORMAT`

**Key Points**:
- Configuration files automatically detected by extension
- Data variables stored in `.chezmoidata.$FORMAT` files (read alphabetically)
- Template support for init: `.chezmoi.$FORMAT.tmpl`
- User choice philosophy - no format mandated

**Why Multi-Format**:
- Flexibility for diverse user preferences
- No strong technical reason to prefer one over another for this use case
- Community includes users from different ecosystems with different format familiarity

**Sources**:
- [Configuration file - chezmoi](https://www.chezmoi.io/reference/configuration-file/)
- [.chezmoidata. - chezmoi](https://www.chezmoi.io/reference/special-files/chezmoidata-format/)

---

### yadm (Yet Another Dotfiles Manager)
**Storage Format**: Git-based (stores actual dotfiles, not separate config)
**Location**: `$HOME` (managed files stay in place, tracked by `.yadm` instead of `.git`)

**Key Points**:
- Dotfiles remain in `$HOME` where they belong
- Uses `.yadm` directory instead of `.git` for repository metadata
- Supports system-specific alternate files via templating
- Encrypted private data support

**Design Philosophy**:
- Minimal abstraction - files stay where applications expect them
- Standard git workflow
- Encryption and templating as needed features

**Sources**:
- [Yet Another Dotfiles Manager - yadm](https://yadm.io/)
- [Managing Dotfiles with YADM: The Easy Way | by Julius | Medium](https://medium.com/@julius.dehner/how-i-manage-my-dotfiles-with-yadm-4cbdb0d35d34)

---

### mackup
**Storage Format**: Configuration file in INI-like format (`.mackup.cfg`)
**Location**: `$HOME/.mackup.cfg`

**Key Points**:
- Automatically finds application settings locations
- Syncs via Dropbox, Git, or other methods
- Application-specific knowledge built-in
- Simple INI-style config for user preferences

**Design Choice**:
- INI format for extreme simplicity (minimal configuration needed)
- Tool handles complexity, user just selects applications
- Mac-specific tool optimized for macOS patterns

**Sources**:
- [Setting Up a New Mac with Dotfiles, Brew Bundle, and Mackup](https://respawn.io/posts/dotfiles-brew-bundle-and-mackup)

---

### dotbot
**Storage Format**: YAML configuration
**Location**: Project root (typically in dotfiles repo)

**Key Points**:
- Lightweight standalone tool for bootstrapping
- YAML configuration defines symlink mappings and shell commands
- Git submodule integration common
- "One-click" installation philosophy

**Why YAML**:
- Human-readable for defining file mappings
- Familiar to DevOps-oriented users
- Structured enough for complex configurations
- Easy to comment and document

**Sources**:
- [General-purpose dotfiles utilities - dotfiles.github.io](https://dotfiles.github.io/utilities/)

---

## 2. LLM/AI Developer Tools

### Cursor IDE
**Storage Format**: MDC (Markdown-based) + JSON settings
**Location**: `.cursor/` directory, `.cursorrules` (legacy)

**Key Points**:
- **Modern**: `.cursor/index.mdc` with Rule Type "Always"
- **Context-aware**: `.cursor/*.mdc` files activated contextually
- **Legacy**: `.cursorrules` still supported but deprecated
- **Settings**: JSON for IDE configuration (VSCode compatible)

**Storage Philosophy**:
- Markdown for human-readable rules/context (like AI-focused README)
- JSON for machine settings
- Repository-level and context-specific scoping
- Mid-conversation context access limitations

**Recent Evolution (2024-2025)**:
- Moved from single `.cursorrules` to hierarchical `.cursor/*.mdc` system
- Better organization for complex projects
- Separation of global vs. context-specific rules

**Sources**:
- [Context | Cursor Learn](https://cursor.com/learn/context)
- [Cursor AI Complete Guide (2025): Real Experiences, Pro Tips, MCPs, Rules & Context Engineering](https://medium.com/@hilalkara.dev/cursor-ai-complete-guide-2025-real-experiences-pro-tips-mcps-rules-context-engineering-6de1a776a8af)
- [How to create a persistent context file for Cursor AI](https://forum.cursor.com/t/how-to-create-a-persistent-context-file-for-cursor-ai-similar-to-readme-md-but-for-ai/42218)

---

### Aider
**Storage Format**: YAML configuration + .env for secrets
**Location**: Config file (path not specified in docs), `.env` in project root

**Key Points**:
- YAML for configuration (model settings, preferences)
- `.env` for API keys and secrets
- Advanced model settings in YAML with extensive fields
- Recent improvements to configuration handling (2024)

**YAML Configuration Fields**:
- Model metadata (name, edit_format, weak_model_name)
- Feature flags (use_repo_map, lazy, streaming)
- Advanced settings (cache_control, reasoning_tag, system_prompt_prefix)
- Global parameters for litellm.completion()

**Why YAML**:
- Human-editable for complex model configurations
- Comments support for documenting settings
- Hierarchical structure for nested settings
- Standard in Python ecosystem

**Sources**:
- [Advanced model settings | aider](https://aider.chat/docs/config/adv-model-settings.html)
- [Aider Documentation | aider](https://aider.chat/docs/)

---

### Continue.dev
**Storage Format**: **Migrating from JSON to YAML**
**Location**: `~/.continue/config.{yaml,json,ts}`

**Key Points**:
- **Current (2024+)**: `config.yaml` preferred
- **Deprecated**: `config.json` being replaced
- **Advanced**: `config.ts` for programmatic configuration
- Workspace override: `.continuerc.json`

**Migration Rationale**:
> "YAML is the preferred format providing more readable, maintainable configuration files and will be used to integrate with future Continue products"

**Format Priority**:
1. If `config.yaml` exists, use it
2. Otherwise fall back to `config.json`
3. `config.ts` for advanced users

**Why YAML Over JSON**:
- More readable and maintainable
- Better for human editing (comments, multi-line strings)
- Future product integration requirements
- Industry standard for configuration

**Sources**:
- [How to Configure Continue - Continue](https://docs.continue.dev/customize/deep-dives/configuration)
- [Config Migration to YAML | Continue](https://docs.continue.dev/customize/yaml-migration)
- [config.json Reference | Continue](https://docs.continue.dev/json-reference)

---

### Cody (Sourcegraph)
**Storage Format**: JSON (Site config), Context Filters
**Location**: Sourcegraph instance configuration, extension settings

**Key Points**:
- `modelConfiguration` field in Site config (JSON)
- `cody.contextFilters` for repository access control (JSON with regex)
- RE2 regex syntax for include/exclude patterns
- MCP tools support (2025)

**Configuration Approach**:
- Server-side configuration in JSON
- Admin-controlled context filters
- Extension settings in VSCode settings.json
- MCP server configuration through extension settings

**Why JSON**:
- Server API compatibility
- VSCode settings format (JSON)
- Programmatic configuration common
- Not primarily human-edited (admin tools)

**Sources**:
- [Manage Cody Context - Sourcegraph docs](https://sourcegraph.com/docs/cody/capabilities/ignore-context)
- [Model Configuration - Sourcegraph docs](https://sourcegraph.com/docs/cody/enterprise/model-configuration)
- [MCP tools now supported in Cody's agentic context gathering](https://sourcegraph.com/changelog/mcp-context-gathering)

---

### GitHub Copilot
**Storage Format**: JSON (settings.json) + Markdown (instructions)
**Location**: `.vscode/settings.json`, `.github/copilot-instructions.md`

**Key Points**:
- Workspace settings in `.vscode/settings.json` (JSON)
- Custom instructions in `.github/copilot-instructions.md` (Markdown)
- Supports workspace-level overrides (2025)
- Per-workspace models, instructions, feature flags

**Configuration Pattern**:
```json
{
  "github.copilot.enable": {
    "*": true,
    "plaintext": false,
    "markdown": true
  }
}
```

**Why This Combination**:
- **JSON**: VSCode native format, programmatic access
- **Markdown**: Human-readable instructions for AI
- Separation of technical settings (JSON) and contextual guidance (Markdown)

**Best Practices**:
- Workspace settings for team policy
- User settings for personal preferences
- Version control workspace settings
- Annotated baseline for team diffs

**Sources**:
- [GitHub Copilot in VS Code settings reference](https://code.visualstudio.com/docs/copilot/reference/copilot-settings)
- [Adding repository custom instructions for GitHub Copilot - GitHub Docs](https://docs.github.com/copilot/customizing-copilot/adding-custom-instructions-for-github-copilot)
- [Managing GitHub Copilot & VS Code Settings Across Teams - DEV Community](https://dev.to/pwd9000/managing-github-copilot-vs-code-settings-across-teams-1phj)

---

## 3. Task Runners & Build Tools

### Task (go-task)
**Storage Format**: YAML
**Location**: `Taskfile.yml` (project root)

**Key Points**:
- YAML syntax for task definitions
- Clear, declarative workflow management
- Easy to read and write
- Standard convention for YAML files

**Why YAML**:
> "Taskfile uses a YAML syntax that is straightforward to understand and write, even for those new to DevOps tools. The format offers a clear and declarative format to manage workflows, ensuring that tasks are easy to write, read, and maintain."

**Design Philosophy**:
- Simplicity over complexity
- Human-readable task definitions
- Wide adoption in DevOps ecosystem
- Balance of flexibility and structure

**Community Feedback (2024)**:
- Medium article (July 2024) on Taskfile variables and parameterization
- Growing adoption for developer productivity
- Praised for clarity and ease of use

**Sources**:
- [Guide | Task - Taskfile](https://taskfile.dev/docs/guide)
- [Why you should be using Taskfile | by Martin Ricken | Medium](https://medium.com/@lorique/why-you-should-be-using-go-task-3cd30897f8d8)
- [Unlocking Developer Productivity with Taskfile | by Nikos Nikolakakis | Medium](https://medium.com/@nonickedgr/unlocking-developer-productivity-with-taskfile-38cbfc75f3af)

---

### Just
**Storage Format**: Make-inspired DSL (not TOML)
**Location**: `justfile` (project root)

**Key Points**:
- Custom DSL syntax inspired by Make
- Cross-platform command runner
- Choice of spaces or tabs for indentation
- Not a build tool - focused on commands

**Why DSL Instead of TOML**:
- Make familiarity for developers
- More concise for command definitions
- Recipe-based mental model
- Established syntax patterns

**Justfile Characteristics**:
- Recipe lines must be indented
- Comments with `#`
- Variables and dependencies
- Platform-agnostic shell commands

**TOML Alternative**: For those seeking TOML-based task running, **mise** provides tasks in TOML files alongside standalone scripts.

**Sources**:
- [GitHub - casey/just: ðŸ¤– Just a command runner](https://github.com/casey/just)
- [Introduction - Just Programmer's Manual](https://just.systems/man/en/)
- [Just, start using it! - Berk Karaal](https://berkkaraal.com/blog/2024/12/06/just-start-using-it/)

---

### Make
**Storage Format**: Makefile DSL
**Location**: `Makefile`, `GNUmakefile`, `makefile`

**Key Points**:
- Decades-old standard
- Tab-based indentation (infamous)
- Build-oriented with dependency tracking
- Universal tooling support

**Not Covered in Detail**: Included for completeness; well-established tool with known characteristics.

---

## 4. Developer Environment Managers

### mise (formerly rtx)
**Storage Format**: TOML (preferred), also supports `.tool-versions`
**Location**: `mise.toml`, `.mise.toml` (deprecated), `.tool-versions` (legacy)

**Key Points**:
- **Primary**: `mise.toml` (modern default)
- **Legacy**: `.mise.toml` (old default, still supported)
- **Compatibility**: `.tool-versions` (asdf format)
- **Local**: `mise.local.toml` for local overrides

**Configuration Structure**:
```toml
min_version = '2024.11.1'  # Minimum mise version

[tools]
node = "20.0.0"
python = "3.11"

[env]
NODE_ENV = "development"

[tasks]
# Task definitions
```

**Why TOML**:
- More flexible than `.tool-versions`
- Supports environment variables, tasks, and tools in one file
- Type-safe and explicit
- Better than YAML for avoiding parsing ambiguities
- Rust ecosystem alignment (mise written in Rust)

**Migration Note**: `.mise.toml` â†’ `mise.toml` (dropping the leading dot for better visibility)

**Sources**:
- [Configuration | mise-en-place](https://mise.jdx.dev/configuration.html)
- [`.mise.toml` -> `mise.toml` Â· jdx/mise Â· Discussion #2206](https://github.com/jdx/mise/discussions/2206)
- [Automating Development Environment with Mise: Comprehensive Guide ðŸ’«](https://medium.com/@rgeraskin/dev-env-with-mise-45a062707705)

---

### devenv
**Storage Format**: Nix configuration
**Location**: `devenv.nix`, `secretspec.toml`

**Key Points**:
- **Primary config**: `devenv.nix` (Nix language)
- **Secrets**: `secretspec.toml` for secret definitions
- **Lock file**: `devenv.lock` (format changed, version-dependent)

**Nix Configuration Example**:
```nix
{
  languages.python = {
    enable = true;
    version = "3.11";
    venv.enable = true;
  };
}
```

**Why Nix**:
- Declarative, reproducible environments
- Functional language for dependencies
- Cross-platform consistency
- NixOS ecosystem integration

**TOML for Secrets**:
- `secretspec.toml` defines secret requirements
- Integration with 1Password, LastPass, system Keychain, dotenv

**Sources**:
- [Fast, Declarative, Reproducible, and Composable Developer Environments - devenv](https://devenv.sh/)
- [Claude Code - devenv](https://devenv.sh/integrations/claude-code/)

---

### direnv
**Storage Format**: Bash scripts
**Location**: `.envrc`

**Key Points**:
- `.envrc` files written in Bash
- Loads/unloads environment variables per directory
- Hooks into shell (bash, zsh, fish)
- Works with asdf, mise (with caveats)

**Why Bash**:
- Maximum flexibility for environment manipulation
- Direct shell integration
- Simple to understand for developers
- Platform-native

**Integration Notes**:
- Can conflict with mise (both manage environment variables)
- Official stance: don't use direnv with mise
- Works well with asdf via asdf-direnv plugin

**Sources**:
- [direnv â€“ unclutter your .profile | direnv](https://direnv.net/)
- [direnv | mise-en-place](https://mise.jdx.dev/direnv.html)

---

### asdf
**Storage Format**: Custom text format
**Location**: `.tool-versions`

**Key Points**:
- Simple text format: `<tool> <version>`
- One tool version per line
- Comments with `#`
- No nested structure

**Example**:
```
node 20.0.0
ruby 3
shellcheck latest
jq 1.6
```

**Why Custom Format**:
- Extreme simplicity
- Single purpose (tool versions)
- No parsing ambiguity
- Easy to read and write

**Limitations**:
- No environment variables
- No complex configuration
- Tools like mise use `.tool-versions` for compatibility but recommend TOML

**Sources**:
- [GitHub - asdf-community/asdf-direnv](https://github.com/asdf-community/asdf-direnv)
- [Configuration | mise-en-place](https://mise.jdx.dev/configuration.html)

---

## 5. CLI Frameworks

### oclif (Node.js)
**Storage Format**: JSON (package.json + config files)
**Location**: `package.json` (metadata), config directory (settings)

**Key Points**:
- CLI metadata in `package.json` under `oclif` key
- Configuration files use JSON via fs-extra
- TypeScript-based framework
- Config class as central repository

**Why JSON**:
- Node.js ecosystem standard
- `package.json` already required
- Programmatic access straightforward
- TypeScript type safety

**No Native YAML Support**: Developers can add custom configuration formats, but framework defaults to JSON.

**Sources**:
- [Configuration Â· oclif: The Open CLI Framework](https://oclif.io/docs/config/)
- [GitHub - oclif/oclif](https://github.com/oclif/oclif)

---

### Clap (Rust)
**Storage Format**: Code-based + external config crates
**Location**: Varies by integration

**Key Points**:
- Clap itself: CLI argument parsing (not configuration storage)
- **Legacy**: YAML support in v2/v3 (deprecated, for CLI structure not runtime config)
- **Modern**: Separate config crates for runtime configuration

**Configuration Crate Options (2024)**:
- **clap-config-file**: Supports YAML, TOML, JSON
- **Figment + Clap**: Elegant hierarchical config (TOML + ENV + CLI args)
- **clap_conf**: ENV, Clap, and TOML

**Best Practice**:
- Use Clap for CLI parsing
- Use Figment or clap-config-file for configuration management
- TOML most common in Rust ecosystem

**Sources**:
- [ClapConfigFile â€” Rust config library // Lib.rs](https://lib.rs/crates/clap-config-file)
- [clap cli configuration figment rust - steezeburger.com](https://steezeburger.com/2023/03/rust-hierarchical-configuration/)
- [Designing for layered configs Â· clap-rs/clap Â· Discussion #2763](https://github.com/clap-rs/clap/discussions/2763)

---

### Commander, Yargs (Node.js)
**Storage Format**: JSON (typical Node.js patterns)
**Location**: `package.json`, separate config files

**Not Detailed**: Similar patterns to oclif - Node.js ecosystem defaults to JSON for configuration.

---

## 6. Documentation Tools

### Docusaurus
**Storage Format**: JavaScript/TypeScript
**Location**: `docusaurus.config.js`

**Key Points**:
- JavaScript configuration file
- React component integration
- Programmatic configuration
- Plugin and theme system

**Why JavaScript**:
- React-based framework
- Dynamic configuration needs
- Type safety with TypeScript option
- Familiar to React developers

**Workflow**:
- Docs in `/docs` folder (Markdown)
- Components in `/src` (React)
- Configuration in `docusaurus.config.js`

**Sources**:
- [Introduction | Docusaurus](https://docusaurus.io/docs)
- [MkDocs vs Docusaurus for technical documentation](https://blog.damavis.com/en/mkdocs-vs-docusaurus-for-technical-documentation/)

---

### VitePress
**Storage Format**: JavaScript/TypeScript
**Location**: `.vitepress/config.js`

**Key Points**:
- JavaScript configuration
- Vue.js-based
- Vite's fast build system
- Markdown files in `/docs`

**Why JavaScript**:
- Vue ecosystem standard
- Dynamic configuration
- TypeScript support
- Vite integration

**Sources**:
- [Documentation Generator Comparison 2025: VitePress vs Docusaurus vs MkDocs vs OkiDoki](https://okidoki.dev/documentation-generator-comparison)

---

### MkDocs
**Storage Format**: YAML
**Location**: `mkdocs.yml`

**Key Points**:
- Single YAML configuration file
- Python-based static site generator
- Simple, straightforward configuration
- Material for MkDocs theme popular

**Why YAML**:
- Python ecosystem familiarity
- Simple hierarchical structure
- Easy to read and write
- Documentation-focused (not code)

**Philosophy**:
- Markdown for content simplicity
- YAML for configuration simplicity
- Beautiful themes (Material)

**Sources**:
- [MkDocs vs Docusaurus for technical documentation](https://blog.damavis.com/en/mkdocs-vs-docusaurus-for-technical-documentation/)

---

## 7. Modern Project Scaffolders

### Vite
**Storage Format**: JavaScript/TypeScript
**Location**: `vite.config.js` / `vite.config.ts`

**Key Points**:
- JavaScript/TypeScript configuration
- Automatic resolution from project root
- Plugin-based architecture
- Build tool focus

**Why JavaScript**:
- Frontend tooling standard
- Dynamic configuration needs
- Plugin system integration
- TypeScript support for type safety

**Sources**:
- [Configuring Vite | Vite](https://vite.dev/config/)

---

### Nx
**Storage Format**: JSON
**Location**: `project.json`, `nx.json`, `workspace.json`

**Key Points**:
- `project.json` for individual project configuration
- `nx.json` for workspace configuration
- JSON schema validation
- Monorepo-focused

**Why JSON**:
- Tooling support (IDEs, validation)
- Schema-driven configuration
- Programmatic access
- Node.js ecosystem alignment

**Sources**:
- [Project Configuration | Nx](https://nx.dev/docs/reference/project-configuration)

---

### Create T3 App
**Storage Format**: Inherits from Next.js (JavaScript/TypeScript)
**Location**: Various config files per technology

**Key Points**:
- Next.js configuration (JavaScript)
- TypeScript for type safety
- Multiple technology integrations (Prisma, tRPC, NextAuth)
- Each tool uses its own config format

**Not a Monolithic Format**: Combines configurations from multiple tools in the T3 stack.

**Sources**:
- [Create T3 App](https://create.t3.gg/)

---

## 8. Package Managers

### Cargo (Rust)
**Storage Format**: TOML
**Location**: `Cargo.toml`

**Why TOML - Official Rationale**:

From PEP 518 (Python) analysis, which echoed Rust's reasoning:

> "TOML was chosen because it is human-usable (unlike JSON), it is flexible enough (unlike configparser), stems from a standard (also unlike configparser), and it is not overly complex (unlike YAML)."

**Specific Design Decisions**:

1. **File naming**: `Cargo.toml` (capital C, `.toml` extension)
   - Capital C: Groups with other config files (Makefile, README) in directory listings
   - `.toml` extension: Emphasizes TOML format, aids identification
   - No alternatives like `cargo.toml` or `Cargofile` allowed (consistency)

2. **TOML advantages**:
   - Human-readable like YAML
   - Unambiguous parsing (maps to hash table)
   - Minimal and explicit (avoids YAML complexity)
   - Easy to parse in multiple languages
   - Standardized (unlike INI)

3. **Rust community satisfaction**:
   - Private email from Cargo team: "quite happy with their choice of TOML"
   - Proven at scale in Rust ecosystem

**Sources**:
- [The Manifest Format - The Cargo Book](https://doc.rust-lang.org/cargo/reference/manifest.html)
- [TOML: Tom's Obvious Minimal Language](https://toml.io/en/)
- [TOML - Wikipedia](https://en.wikipedia.org/wiki/TOML)

---

### npm (Node.js)
**Storage Format**: JSON
**Location**: `package.json`

**Why JSON**:

1. **Machine-readable**: Programs can easily parse and access properties
2. **Human-readable**: Developers can read and edit
3. **Standard**: Universal data format across programming languages
4. **Structured**: Key-value pairs for metadata
5. **Ecosystem**: JavaScript native format

**What it Contains**:
- Project metadata (name, description, version)
- Dependencies (runtime and development)
- Scripts (build, test, etc.)
- Module type (CommonJS vs ES modules)
- Entry points (main, exports)

**Requirement**: Must respect JSON format for programmatic access.

**Sources**:
- [package.json | npm Docs](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/)
- [What Is package.json? | HeyNode](https://heynode.com/tutorial/what-packagejson/)
- [Modules: Packages | Node.js v25.3.0 Documentation](https://nodejs.org/api/packages.html)

---

### pip / Python (pyproject.toml)
**Storage Format**: TOML
**Location**: `pyproject.toml`

**Why TOML Over YAML and JSON - Official PEP 518 Rationale**:

**TOML Chosen Because**:
- Human-usable (unlike JSON)
- Flexible enough (unlike configparser/INI)
- Stems from a standard (unlike configparser)
- Not overly complex (unlike YAML)

**YAML Rejected - Three Critical Issues**:

1. **Specification Complexity**:
   - YAML spec: 86 pages (letter-sized)
   - Risk: Features work with one parser but not another
   - Maintenance burden

2. **Security Concerns**:
   > "YAML itself is not safe by default, as the specification allows for the arbitrary execution of code which is best avoided when dealing with configuration data."

   - PyYAML has `safe_load()`, but developers might use `load()` carelessly
   - Arbitrary code execution risk
   - Not acceptable for dependency metadata

3. **Implementation Complexity**:
   - PyYAML: thousands of lines + optional C extension
   - Vendoring challenge (pip needs self-contained)
   - Heavy dependency for simple configuration

**JSON Rejected**:
- Not human-usable
- Developers need to write/maintain by hand
- Comments not supported

**Community Validation**:
- Rust community (Cargo) "quite happy with their choice of TOML"
- Python build system ecosystem adopted TOML

**Sources**:
- [PEP 518 â€“ Specifying Minimum Build System Requirements for Python Projects | peps.python.org](https://peps.python.org/pep-0518/)
- [Clarifying PEP 518 (a.k.a. pyproject.toml)](https://snarky.ca/clarifying-pep-518/)
- [What the heck is pyproject.toml?](https://snarky.ca/what-the-heck-is-pyproject-toml/)

---

### Homebrew
**Storage Format**: Ruby DSL
**Location**: `Brewfile`

**Key Points**:
- Brewfiles evaluated as Ruby
- Domain-specific language for dependencies
- Comments with `#`
- Recent improvements (2024)

**DSL Keywords**:
- `brew "package"` - Homebrew packages
- `cask "app"` - GUI applications
- `tap "source"` - Third-party repositories
- `mas "app", id: 123` - Mac App Store apps
- VSCode extensions, Go, Cargo, Flatpak support

**Recent Features (2024)**:
- `version_file:` DSL for writing version files (e.g., `.ruby-version`)
- `ENV["PATH"]` configuration support
- Hugely improved documentation

**Why Ruby DSL**:
- Homebrew written in Ruby
- Flexible, programmable configuration
- Familiar to Homebrew contributors
- "Gemfile, but for Homebrew" philosophy

**Sources**:
- [Homebrew Bundle, brew bundle and Brewfile â€” Homebrew Documentation](https://docs.brew.sh/Brew-Bundle-and-Brewfile)
- [Brewfile: a Gemfile, but for Homebrew](https://thoughtbot.com/blog/brewfile-a-gemfile-but-for-homebrew)
- [4.5.0 â€” Homebrew](https://brew.sh/2025/04/29/homebrew-4.5.0/)

---

## 9. CI/CD & Infrastructure

### GitHub Actions
**Storage Format**: YAML
**Location**: `.github/workflows/*.yml` or `.github/workflows/*.yaml`

**Why YAML**:

1. **Human-readable**: Data serialization standard for configuration
2. **Simplicity**: Easy to write and understand
3. **DevOps standard**: Popular in CI/CD and infrastructure
4. **Declarative**: Define workflows with triggers, jobs, steps
5. **Industry alignment**: Azure DevOps, Jenkins use YAML pipelines

**Required Format**: Must create YAML file for workflow configuration.

**File Extension**: Both `.yml` and `.yaml` are functionally identical and supported.

**Benefits**:
- Reduces manual errors
- Speeds up development lifecycle
- Automates entire pipeline
- Clear workflow visualization

**Sources**:
- [Metadata syntax for GitHub Actions](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions)
- [YAML and GitHub Actions â€“ Continuous Integration / Continuous Deployment (CI/CD)](https://hsf-training.github.io/hsf-training-cicd-github/05-understanding-yaml-and-ci/index.html)
- [Introduction to GitHub Actions for CI/CD pipelines](https://graphite.com/guides/introduction-to-github-actions-for-ci-cd-pipelines)

---

### Kubernetes
**Storage Format**: YAML (predominantly)
**Location**: Manifest files

**Not Detailed**: Industry-standard YAML for declarative infrastructure. Ubiquitous in container orchestration.

---

## 10. Storage Location Standards

### XDG Base Directory Specification

**Primary Locations**:
- **Config**: `$XDG_CONFIG_HOME` (default: `$HOME/.config`)
- **Data**: `$XDG_DATA_HOME` (default: `$HOME/.local/share`)
- **Cache**: `$XDG_CACHE_HOME` (default: `$HOME/.cache`)
- **State**: `$XDG_STATE_HOME` (default: `$HOME/.local/state`)

**Additional Search Paths**:
- `$XDG_CONFIG_DIRS` (default: `/etc/xdg`)

**Modern Best Practice**:
- Store config in `$HOME/.config/appname/`
- Don't clutter `$HOME` with dotfiles
- Use subdirectories for organization

**Current Version**: 0.8.0 (2024)

**Sources**:
- [XDG Base Directory Specification](https://specifications.freedesktop.org/basedir/latest/)
- [XDG Base Directory - ArchWiki](https://wiki.archlinux.org/title/XDG_Base_Directory)
- [Use the XDG Base Directory Specification!](https://xdgbasedirectoryspecification.com/)

---

## Pattern Analysis & Trends

### By Ecosystem

| Ecosystem | Preferred Format | Reasoning |
|-----------|-----------------|-----------|
| **Rust** | TOML | Explicit, safe, standardized, human-friendly |
| **Python** | TOML | PEP 518 rationale (safe, simple, standard) |
| **Node.js** | JSON | Native format, tooling, `package.json` standard |
| **DevOps/CI** | YAML | Human-readable, industry standard |
| **Infrastructure** | YAML | Kubernetes, Docker Compose, Ansible |
| **Go** | YAML | Task runner, cloud-native tools |
| **Ruby** | Ruby DSL | Programmability (Brewfile, Rakefile) |
| **Nix** | Nix DSL | Functional, declarative environments |

---

### By Use Case

| Use Case | Format Choice | Why |
|----------|--------------|-----|
| **Human-edited config** | TOML or YAML | Readability, comments, structure |
| **Machine-generated** | JSON | Precise, no ambiguity, wide support |
| **Complex logic** | DSL (Ruby, Nix, JS) | Programmability, flexibility |
| **Simple key-value** | Custom text, INI, ENV | Minimal overhead |
| **API/interchange** | JSON | Universal, fast parsing |
| **Build systems** | DSL (Make, Just) | Domain-specific needs |
| **Documentation** | Markdown + YAML/JS | Content vs. config separation |

---

### Migration Stories

#### 1. Continue.dev: JSON â†’ YAML (2024)

**Reason**:
> "YAML is the preferred format providing more readable, maintainable configuration files and will be used to integrate with future Continue products"

**Migration Strategy**:
- Introduce `config.yaml` alongside `config.json`
- If YAML exists, use it; otherwise fall back to JSON
- Graceful deprecation, no forced migration
- Documentation updated to recommend YAML

**Lessons**:
- Backward compatibility critical
- Clear migration path
- Document reasoning publicly
- Support both during transition

**Source**: [Config Migration to YAML | Continue](https://docs.continue.dev/customize/yaml-migration)

---

#### 2. mise: `.mise.toml` â†’ `mise.toml` (Recent)

**Reason**:
- Better visibility (no leading dot)
- Consistency with modern conventions
- Easier discovery in file listings

**Migration Strategy**:
- Both supported
- Documentation uses new name
- No forced migration

**Lessons**:
- Even filename changes need compatibility
- Documentation leads behavior change
- Community adoption takes time

**Source**: [`.mise.toml` -> `mise.toml` Â· jdx/mise Â· Discussion #2206](https://github.com/jdx/mise/discussions/2206)

---

#### 3. Cursor: `.cursorrules` â†’ `.cursor/*.mdc` (2024-2025)

**Reason**:
- Better organization for complex projects
- Context-specific rules
- Hierarchical structure
- Markdown-based for readability

**Migration Strategy**:
- Legacy `.cursorrules` still supported
- New projects use `.cursor/index.mdc`
- Split into multiple files when needed

**Lessons**:
- Organizational improvements worth migration
- Support old format indefinitely for existing users
- New format optional but recommended

**Source**: [Cursor AI Complete Guide (2025)](https://medium.com/@hilalkara.dev/cursor-ai-complete-guide-2025-real-experiences-pro-tips-mcps-rules-context-engineering-6de1a776a8af)

---

#### 4. Clap (Rust): Deprecating YAML (v2/v3 â†’ v4+)

**Reason**:
- YAML was for CLI structure definition, not runtime config
- Maintenance burden
- Better alternatives with derive macros
- Separation of concerns (use config crates for runtime config)

**Modern Approach**:
- Derive macros for CLI structure
- Separate crates (Figment, clap-config-file) for configuration
- Focus on core competency (argument parsing)

**Lessons**:
- Right tool for the right job
- Framework scope matters
- Ecosystem can provide specialized solutions

**Source**: [Designing for layered configs Â· clap-rs/clap Â· Discussion #2763](https://github.com/clap-rs/clap/discussions/2763)

---

### Format Comparison Summary (2024-2026)

Based on 10+ articles and comparisons from 2024-2026:

#### TOML
**Strengths**:
- Explicit typing (no silent bugs)
- Unambiguous parsing
- Human-readable
- Minimal but sufficient
- Safe by design
- Growing in Rust/Python communities

**Weaknesses**:
- Less familiar to some developers
- More verbose than YAML for deep nesting
- Smaller ecosystem than JSON/YAML

**Best For**: Application configuration, package metadata, settings files

**Trend**: Growing adoption, especially in modern tools

---

#### YAML
**Strengths**:
- Extremely human-readable
- Concise syntax
- Comments support
- Ubiquitous in DevOps
- Familiar to most developers

**Weaknesses**:
> "YAML's implicit typing can cause silent bugs that become 'logic bombs waiting to explode in production'"

- 86-page specification (complex)
- Security concerns (arbitrary code execution)
- Indentation errors
- Parser inconsistencies
- Ambiguous typing (`NO` becomes `false`, `1.0` might be string or number)

**Best For**: CI/CD pipelines, infrastructure as code, documentation configs

**Trend**: Stable in DevOps, declining for new application configs

---

#### JSON
**Strengths**:
- Universal support
- Fast parsing
- Unambiguous
- Machine-friendly
- Native to JavaScript/web

**Weaknesses**:
- Not human-friendly (no comments, trailing commas, verbose)
- Manual editing error-prone
- Limited data types

**Best For**: APIs, machine-generated configs, web interchange

**Trend**: Declining for human-edited configs, stable for machine use

---

#### DSLs (Ruby, Nix, JavaScript)
**Strengths**:
- Maximum flexibility
- Programmability
- Domain-specific optimizations
- Native language integration

**Weaknesses**:
- Language dependency
- Learning curve
- Potential complexity
- Harder to parse/validate

**Best For**: Build tools, package managers, complex workflows

**Trend**: Stable in specific domains (Nix, Homebrew, Docusaurus)

---

#### Emerging: Pkl (Apple, 2024)

**What**: Configuration language from Apple
**Target**: Replace YAML, JSON, HCL in complex infrastructure

**Selling Points**:
- Eliminates entire categories of configuration errors
- Type-safe
- Validation built-in
- Better than YAML for complex scenarios

**Adoption**: Growing in infrastructure/DevOps communities (2024+)

**Sources**:
- [Tools and Trends - The State of Developer Ecosystem in 2025](https://devecosystem-2025.jetbrains.com/tools-and-trends)
- [JSON, YAML, TOML, or XML? The Best Choice for 2025 | Leapcell](https://leapcell.io/blog/json-yaml-toml-xml-best-choice-2025)

---

## Recommendations for Nancy

Based on this research, here are format recommendations for different Nancy components:

### 1. User Configuration (`~/.config/nancy/config.*`)
**Recommendation**: **TOML**

**Reasoning**:
- Human-editable (users will tweak settings)
- Explicit and safe (no YAML footguns)
- Modern preference in developer tools (Rust/Python ecosystems)
- Better error messages than YAML
- Type-safe

**Alternative**: YAML if team/users strongly prefer it, but TOML is safer

**Example Structure**:
```toml
[ai]
provider = "anthropic"
model = "claude-sonnet-4-5"

[storage]
database = "~/.local/share/nancy/nancy.db"

[behavior]
auto_commit = false
verbose = true
```

---

### 2. Project Metadata (`.nancy/config.*`)
**Recommendation**: **TOML** or **YAML**

**Reasoning**:
- Version-controlled, team-shared
- TOML: More explicit, safer, better for complex configs
- YAML: More familiar to most developers, concise

**Lean Toward**: TOML for consistency with user config

**Example Structure**:
```toml
[project]
name = "my-project"
version = "0.1.0"

[nancy]
version = "0.1.0"  # Nancy version used

[beads.active]
# Active bead configuration
```

---

### 3. Context/Instructions (AI-facing)
**Recommendation**: **Markdown** (`.md`)

**Reasoning**:
- Following Cursor, GitHub Copilot patterns
- Natural for AI consumption
- Human-readable
- Comments and structure built-in
- Familiar to developers

**Example**: `.nancy/context.md`, `.nancy/rules.md`

---

### 4. Structured Metadata (SQLite)
**Recommendation**: **SQLite database**

**Reasoning**:
- Already implemented
- Excellent for relational data (sessions, beads, messages)
- Queryable, performant
- Single-file portability
- No parser needed

**Use For**: Session history, bead storage, relational metadata

---

### 5. Hierarchical Configuration
**Recommendation**: **Layered TOML**

**Strategy**:
1. Global: `~/.config/nancy/config.toml`
2. Project: `.nancy/config.toml`
3. Local: `.nancy/config.local.toml` (gitignored)
4. Environment variables: `NANCY_*`

**Merge Strategy**: Later sources override earlier (local > project > global)

---

### 6. Migration Path
If changing from current format:

**Steps**:
1. Support both old and new formats simultaneously
2. Auto-migrate on first read (with backup)
3. Document migration clearly
4. Provide migration tool (`nancy migrate config`)
5. Deprecate old format after 2-3 versions
6. Remove old format support after 5+ versions

**Example** (from Continue.dev):
```python
if exists("config.toml"):
    use_config("config.toml")
elif exists("config.json"):
    use_config("config.json")
    warn("config.json is deprecated, migrate to config.toml")
```

---

## Key Takeaways

### Modern Preferences (2024-2026)

1. **TOML is Rising**:
   - Rust ecosystem standard (Cargo)
   - Python standard (PEP 518)
   - mise, many modern tools
   - Safer than YAML, friendlier than JSON

2. **YAML Stable in DevOps**:
   - GitHub Actions, Kubernetes, Docker Compose
   - Not recommended for new application configs
   - Security and complexity concerns

3. **JSON for Machines**:
   - APIs, generated configs, Node.js
   - Declining for human-edited files
   - Continue.dev, others migrating away

4. **Markdown for AI**:
   - Cursor, Copilot use Markdown for instructions
   - Human and AI readable
   - Separate technical config from contextual guidance

5. **DSLs for Specialized Needs**:
   - Homebrew, Just, Nix
   - When flexibility > simplicity

---

### Critical Decision Factors

**Choose TOML when**:
- Human editing expected
- Type safety important
- Rust/Python ecosystem alignment
- Modern tooling desired
- Avoiding YAML pitfalls

**Choose YAML when**:
- DevOps/infrastructure context
- Team familiarity critical
- Conciseness > explicitness
- Existing YAML tooling

**Choose JSON when**:
- Machine-generated
- API interchange
- JavaScript ecosystem
- No comments needed

**Choose Markdown when**:
- AI-facing content
- Documentation-like
- Human narratives
- Following Cursor/Copilot patterns

**Choose SQLite when**:
- Relational data
- Query needs
- Performance critical
- Single-file portability

---

### Format Evolution Pattern

**Observed Trend**:
```
JSON (early tools)
  â†“
YAML (human readability)
  â†“
TOML (safety + readability)
  â†“
Pkl? (type-safe, validated)
```

**Nancy Should**:
- Start with TOML (modern, safe)
- Support migration if needed
- Separate config (TOML) from context (Markdown)
- Use SQLite for data, not config

---

## Sources Summary

This research compiled information from **50+ sources** including:

- Official documentation (Cargo, PEP 518, GitHub Actions, etc.)
- Migration announcements (Continue.dev, mise)
- Developer blogs and comparisons (2024-2026)
- Framework documentation (oclif, Clap, Task, Just)
- Ecosystem trends (JetBrains State of Developer Ecosystem)

All sources are hyperlinked throughout this document.

---

**Research completed**: 2026-01-24
**Next steps**: Apply findings to Nancy's configuration design decisions
