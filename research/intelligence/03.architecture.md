# Nancy Prompt Factory - Architecture Design

**Date**: 2026-01-24
**Status**: Design Phase

---

## Design Principles

1. **Composable** - Fragments combine like Lego blocks
2. **Discoverable** - Clear what exists and how to use it
3. **Extensible** - Add new domains/fragments without touching core
4. **Obvious** - Mental model is immediately clear
5. **Boring** - Use proven patterns, save innovation for features

---

## Directory Structure

```
nancy/
├── templates/                         # Shipped with Nancy (version controlled)
│   ├── fragments/                    # Flat directory - all fragments here
│   │   ├── core.principles.md       # Core Nancy principles
│   │   ├── core.tone.md            # Communication style
│   │   ├── user.identity.md        # User context injection
│   │   ├── user.preferences.md     # Work style preferences
│   │   ├── eng.project.summary.md  # Project context
│   │   ├── eng.project.constraints.md  # Project rules
│   │   ├── eng.lang.typescript.md
│   │   ├── eng.lang.go.md
│   │   ├── eng.lang.python.md
│   │   ├── eng.lang.rust.md
│   │   ├── eng.framework.react.md
│   │   ├── eng.framework.nextjs.md
│   │   ├── eng.framework.svelte.md
│   │   ├── eng.framework.vue.md
│   │   ├── eng.workflow.linear.md   # Linear integration
│   │   ├── eng.workflow.git-worktree.md  # Git worktree patterns
│   │   ├── eng.workflow.subagents.md     # Subagent delegation
│   │   ├── eng.task.feature.md      # New feature guidance
│   │   ├── eng.task.bugfix.md       # Bug fix workflow
│   │   ├── eng.task.research.md     # Research/exploration
│   │   ├── marketing.campaign.brief.md   # Campaign planning
│   │   ├── marketing.content.voice.md    # Brand voice guidelines
│   │   ├── legal.contract.review.md      # Contract review checklist
│   │   ├── legal.compliance.gdpr.md      # GDPR compliance
│   │   ├── creative.design.principles.md # Design system
│   │   ├── creative.brand.guidelines.md  # Brand guidelines
│   │   ├── research.methodology.md       # Research approach
│   │   ├── ops.incident.response.md      # Incident handling
│   │   ├── finance.budget.review.md      # Budget review
│   │   └── hr.onboarding.md             # Employee onboarding
│   │
│   ├── assemblers/                   # Assembly rules (YAML)
│   │   ├── onboarding.yaml          # First-time user
│   │   ├── task-init.yaml           # Starting new task
│   │   └── quick-fix.yaml           # Fast iteration
│   │
│   └── schemas/                      # JSON Schema definitions
│       ├── bead.schema.json         # Bead validation
│       ├── fragment.schema.json     # Fragment frontmatter
│       └── assembler.schema.json

└── ~/.nancy/                         # User data (NOT version controlled)
    ├── config.yaml                   # User preferences
    ├── beads/                        # Flat directory - all beads here
    │   ├── user.yaml                # User identity/profile
    │   ├── project.nancy.yaml       # Nancy project bead
    │   ├── project.bubble-gum.yaml  # Bubble-gum project bead
    │   ├── style.typescript.yaml    # User's TS preferences
    │   ├── style.typescript-poc.yaml
    │   ├── style.go.yaml
    │   ├── marketing.campaigns.yaml # Marketing campaign data
    │   └── finance.budgets.yaml     # Budget tracking data
    │
    ├── cache/
    │   ├── bubble-gum.db            # SQLite cache (per project)
    │   └── assembled/               # Cached assembled prompts
    │       └── {hash}.md
    │
    └── logs/
        └── nancy.log
```

**Naming Convention**: `{domain}.{category}.{name}.md`

**Domains**: core, user, eng, marketing, legal, creative, research, ops, finance, hr

---

## Mental Model: "What Goes Where?"

### The Form UI Test

**"Could a non-developer edit this in a form?"**

- **YES** → Bead (YAML data in `~/.nancy/beads/`)
- **NO** → Fragment (Markdown in `templates/fragments/`)

### Examples

| Content | Goes In | Why |
|---------|---------|-----|
| User's name, role, preferences | `beads/user.yaml` | Facts about the user |
| "You are working with {{user.name}}" | `fragments/user.identity.md` | Template using the data |
| Project tech stack | `beads/project.foo.yaml` | Project metadata |
| TypeScript coding guidelines | `fragments/eng.lang.typescript.md` | Instructions |
| User's preferred TS style (strict vs loose) | `beads/style.typescript.yaml` | User preference data |
| Linear workflow instructions | `fragments/eng.workflow.linear.md` | How to use Linear |
| Marketing campaign data | `beads/marketing.campaigns.yaml` | Campaign facts |
| Brand voice guidelines | `fragments/marketing.content.voice.md` | How to write content |
| Contract review checklist | `fragments/legal.contract.review.md` | Legal review steps |
| Budget tracking data | `beads/finance.budgets.yaml` | Financial data |
| Assembly rules | `assemblers/task-init.yaml` | Which fragments to include when |

---

## File Format Breakdown

### Beads (YAML) - "The What"

**Purpose**: Structured data that varies per user/project

**Characteristics**:
- Facts, metrics, status, relationships
- Schema-validated
- Composable (base + user + project)
- Queryable

**Example**: `~/.nancy/beads/user.yaml`

```yaml
nancy_version: "1.0"
identity:
  name: Stuart
  role: Senior Developer
  experience_level: senior
  focus:
    - TypeScript
    - Go
    - Distributed Systems
  communication_style: direct, technical

preferences:
  code_review: thorough
  testing: comprehensive
  documentation: minimal

summary: |
    35 year old senior developer focused on TypeScript and
    distributed systems. Prefers direct technical communication.
```

### Fragments (Markdown) - "The How"

**Purpose**: Reusable prompt instructions that get composed

**Characteristics**:
- Instructions for LLM behavior
- YAML frontmatter for metadata
- Variable interpolation
- Conditional inclusion logic
- Flat directory with dot notation naming

**Example**: `templates/fragments/user.identity.md`

```markdown
---
id: user.identity
requires:
  - beads: user.identity
dependencies: []
priority: 10
---

You are working with {{user.identity.name}}, a {{user.identity.role}}.

{{user.identity.summary}}

Communication style: {{user.identity.communication_style}}
```

**Example**: `templates/fragments/eng.lang.typescript.md`

```markdown
---
id: eng.lang.typescript
requires:
  - beads: style.typescript
conditions:
  - detected.language == "typescript"
priority: 50
---

## TypeScript Guidelines

{{#if beads.style.typescript.mode == "production"}}
- Use strict mode with explicit types
- Comprehensive error handling
- No `any` types without justification
{{else if beads.style.typescript.mode == "poc"}}
- Speed over perfection
- `any` is acceptable for rapid iteration
- Focus on proving the concept
{{/if}}

{{#if beads.style.typescript.preferences}}
Additional preferences:
{{beads.style.typescript.preferences}}
{{/if}}

Follow existing patterns in the codebase.
```

**Example**: `templates/fragments/marketing.content.voice.md`

```markdown
---
id: marketing.content.voice
requires:
  - beads: marketing.brand
conditions:
  - task.domain == "marketing"
priority: 40
---

## Brand Voice Guidelines

Tone: {{marketing.brand.tone}}

Key Messages:
{{#each marketing.brand.key_messages}}
- {{this}}
{{/each}}

Avoid:
{{#each marketing.brand.avoid}}
- {{this}}
{{/each}}
```

**Example**: `templates/fragments/legal.contract.review.md`

```markdown
---
id: legal.contract.review
conditions:
  - task.type == "contract_review"
priority: 60
---

## Contract Review Checklist

1. **Parties**: Verify all parties are correctly identified
2. **Terms**: Review payment terms, deliverables, timelines
3. **Liability**: Check limitation of liability clauses
4. **IP Rights**: Verify intellectual property ownership
5. **Termination**: Review termination conditions
6. **Jurisdiction**: Confirm governing law and venue

Flag any unusual or concerning clauses for legal team review.
```

### Assemblers (YAML) - "The Rules"

**Purpose**: Define which fragments to include and how to compose them

**Example**: `templates/assemblers/task-init.yaml`

```yaml
name: Task Initialization
description: Assemble context for starting a new task
trigger: nancy init <project>

# Detection logic
detect:
  project:
    from: git_root
  language:
    from: [package.json, go.mod, Cargo.toml, pyproject.toml]
  framework:
    from: [package.json.dependencies]

# Fragment selection (using dot notation)
fragments:
  always:
    - core.principles
    - eng.workflow.linear
    - eng.workflow.subagents

  conditional:
    - if: beads.user exists
      include: user.identity

    - if: beads.project.{project} exists
      include: eng.project.summary

    - if: detected.language == "typescript"
      include: eng.lang.typescript

    - if: detected.framework contains "react"
      include: eng.framework.react

    - if: detected.framework contains "next"
      include: eng.framework.nextjs

    - if: git.worktrees detected
      include: eng.workflow.git-worktree

    - if: beads.style.{language} exists
      include: eng.style.{language}

    - if: task.domain == "marketing"
      include:
        - marketing.content.voice
        - marketing.campaign.brief

    - if: task.domain == "legal"
      include: legal.contract.review

# Variable interpolation sources
interpolation:
  user: beads.user
  project: beads.project.{project}
  detected: detected.*
  git: git.*
  marketing: beads.marketing.*
  finance: beads.finance.*

# Assembly order (priority ascending)
order:
  - core.* (priority: 0-9)
  - user.* (priority: 10-19)
  - eng.project.* (priority: 20-29)
  - eng.lang.* (priority: 50-59)
  - eng.framework.* (priority: 60-69)
  - eng.workflow.* (priority: 70-79)
  - eng.task.* (priority: 80-89)
  - marketing.* (priority: 40-49)
  - legal.* (priority: 60-69)
  - creative.* (priority: 40-49)

# Output
output:
  format: markdown
  sections:
    - "# Role & Context"
    - "# Project Summary"
    - "# Coding Guidelines"
    - "# Workflow"
    - "# Principles"

  cache: true
  cache_key: hash(beads + fragments + detected)
```

---

## Composition Logic

### 1. Detection Phase

```typescript
// Pseudo-code
const context = {
  user: loadBead('~/.nancy/beads/user.yaml'),
  project: loadBead(`~/.nancy/beads/project.${projectName}.yaml`),
  detected: {
    language: detectLanguage(), // from package.json, go.mod, etc.
    framework: detectFramework(),
  },
  git: {
    worktrees: hasWorktrees(),
    branch: getCurrentBranch(),
  }
}
```

### 2. Fragment Selection

```typescript
// Load assembler
const assembler = loadAssembler('task-init.yaml')

// Select fragments based on rules (using dot notation)
const selectedFragments = []

// Always includes
selectedFragments.push(...assembler.fragments.always)

// Conditional includes
for (const rule of assembler.fragments.conditional) {
  if (evaluateCondition(rule.if, context)) {
    selectedFragments.push(rule.include)
  }
}
```

### 3. Fragment Loading

```typescript
// Load each fragment with frontmatter parsing
// Files are in flat directory, named with dots
const fragments = selectedFragments.map(fragmentId => {
  const filename = `${fragmentId}.md` // e.g., "eng.lang.typescript.md"
  const content = readFile(`templates/fragments/${filename}`)
  const { frontmatter, body } = parseFrontmatter(content)
  return { ...frontmatter, body, path: filename }
})
```

### 4. Priority Sorting

```typescript
// Sort by priority (ascending)
fragments.sort((a, b) => a.priority - b.priority)
```

### 5. Variable Interpolation

```typescript
// Interpolate variables in each fragment
const interpolated = fragments.map(fragment => {
  let content = fragment.body

  // Simple interpolation: {{user.identity.name}}
  content = interpolateSimple(content, context)

  // Conditional blocks: {{#if beads.style.typescript.mode == "poc"}}
  content = interpolateConditionals(content, context)

  return content
})
```

### 6. Assembly

```typescript
// Combine into final prompt
const sections = assembler.output.sections
const prompt = []

for (const section of sections) {
  prompt.push(section) // Section header

  // Add fragments that belong to this section
  const sectionFragments = interpolated.filter(f =>
    belongsToSection(f, section)
  )

  prompt.push(...sectionFragments)
}

const finalPrompt = prompt.join('\n\n')
```

### 7. Caching

```typescript
// Cache assembled prompt
if (assembler.output.cache) {
  const key = hash({ beads: context, fragments: selectedFragments })
  saveToCache(key, finalPrompt)
}
```

---

## Provenance Metadata

Every assembled prompt includes rich metadata tracking its composition and sources. This makes prompts transparent, debuggable, and reproducible.

### Structure

Assembled prompts use a **hybrid approach**:
- **YAML frontmatter**: Rich metadata about fragments, beads, and context
- **Inline markers**: HTML comments showing fragment boundaries

```markdown
---
provenance:
  assembler:
    name: task-init
    version: 1.0
    file: templates/assemblers/task-init.yaml

  context:
    user: Stuart
    project: nancy-bubble-gum
    detected:
      language: typescript
      framework: react

  fragments:
    - id: core.principles
      file: templates/fragments/core.principles.md
      version: 1.0.0
      priority: 0
      hash: a4f3b2c1d5e6f7a8
      size_bytes: 1024

    - id: eng.lang.typescript
      file: templates/fragments/eng.lang.typescript.md
      version: 1.0.0
      priority: 50
      hash: b9c0d1e2f3a4b5c6
      size_bytes: 2048

  beads:
    - file: beads/user.yaml
      hash: f3a4b5c6d7e8f9a0
    - file: beads/project.nancy-bubble-gum.yaml
      hash: a8b9c0d1e2f3a4b5

  assembled_at: 2026-01-24T15:30:00Z
  cache_key: hash(assembler + context + fragments + beads)
---

<!-- BEGIN: core.principles | priority: 0 | templates/fragments/core.principles.md -->
# Core Principles
...
<!-- END: core.principles -->

<!-- BEGIN: eng.lang.typescript | priority: 50 | templates/fragments/eng.lang.typescript.md -->
# TypeScript Guidelines
...
<!-- END: eng.lang.typescript -->
```

### Benefits

1. **Traceability** - Know exactly which fragments were used and where they came from
2. **Debuggability** - Jump from prompt section to source file when something needs fixing
3. **Version Control** - Track which version of each fragment was used
4. **Reproducibility** - Recreate exact prompts given the same inputs
5. **Change Detection** - Hash changes indicate when fragments have been modified
6. **Easy Modification** - See fragment source path, edit it, reassemble

### Use Cases

**Debugging**: "TypeScript guidelines too strict" → Check provenance → See `eng.lang.typescript` → Edit source or related bead → Reassemble

**Understanding Changes**: Compare cache keys and fragment hashes to see what changed and why

**Impact Analysis**: Find all prompts using a specific fragment before making changes

**For complete details**, see `research/intelligence/04.provenance.md`

---

## Extensibility Pattern

### Adding a New Language (Zero-Config)

**1. Create fragment**: `templates/fragments/eng.lang.rust.md`

```markdown
---
id: eng.lang.rust
requires:
  - beads: style.rust (optional)
conditions:
  - detected.language == "rust"
priority: 50
---

## Rust Guidelines

- Follow Clippy recommendations
- Use `cargo fmt` for formatting
- Prefer `Result<T, E>` over panicking
- ...
```

**2. Done.** The assembler auto-discovers it via:
- Filename convention: `eng.lang.*.md`
- Condition: `detected.language == "rust"`
- No code changes needed

### Adding a Framework

**1. Create fragment**: `templates/fragments/eng.framework.svelte.md`

```markdown
---
id: eng.framework.svelte
conditions:
  - detected.framework contains "svelte"
priority: 60
---

## Svelte Guidelines

- Use Svelte 5 runes (`$state`, `$derived`, `$effect`)
- ...
```

**2. Done.** Auto-discovered via framework detection.

### Adding a New Domain

**1. Create fragments**: e.g., `templates/fragments/hr.onboarding.md`

```markdown
---
id: hr.onboarding
conditions:
  - task.domain == "hr"
  - task.type == "onboarding"
priority: 40
---

## Employee Onboarding Checklist

1. **Pre-arrival**: Setup workspace, accounts, equipment
2. **Day 1**: Welcome session, team introductions
3. **Week 1**: Training schedule, orientation materials
4. **Month 1**: Check-in meetings, feedback collection

Reference the employee's start date: {{hr.employee.start_date}}
```

**2. Create bead**: `~/.nancy/beads/hr.employees.yaml`

```yaml
nancy_version: "1.0"
employees:
  - name: "Jane Doe"
    role: "Product Manager"
    start_date: "2026-02-01"
    department: "Product"
```

**3. Update assembler** (if needed) to include HR fragments when `task.domain == "hr"`

**4. Done.** The system is domain-agnostic and extensible.

---

## Discoverability

### CLI Commands

```bash
# List available fragments (flat directory)
$ nancy fragments list
core.principles
core.tone
user.identity
eng.lang.typescript
eng.lang.go
eng.framework.react
marketing.content.voice
legal.contract.review
...

# Describe a fragment
$ nancy fragments describe eng.lang.typescript
ID: eng.lang.typescript
Requires: style.typescript (optional)
Conditions: detected.language == "typescript"
Priority: 50
Description: TypeScript coding guidelines

# List beads
$ nancy beads list
user.yaml
project.nancy.yaml
project.bubble-gum.yaml
style.typescript.yaml
marketing.campaigns.yaml
finance.budgets.yaml

# Show bead schema
$ nancy beads schema
(prints JSON Schema for beads)

# Show what would be assembled
$ nancy assemble --dry-run
Assembler: task-init
Detected:
  - Language: typescript
  - Framework: react
  - Git worktrees: yes

Selected fragments:
  1. core.principles (priority: 0)
  2. user.identity (priority: 10)
  3. eng.project.summary (priority: 20)
  4. eng.lang.typescript (priority: 50)
  5. eng.framework.react (priority: 60)
  6. eng.workflow.git-worktree (priority: 75)
  7. eng.workflow.linear (priority: 70)

Output: 2,847 tokens (cached: no)
```

### IDE Integration

```json
// .vscode/settings.json
{
  "yaml.schemas": {
    "nancy/schemas/bead.schema.json": "~/.nancy/beads/**/*.yaml",
    "nancy/schemas/assembler.schema.json": "nancy/templates/assemblers/*.yaml"
  }
}
```

Auto-completion in VS Code when editing beads or assemblers.

---

## Next Steps

1. Implement bead schema (JSON Schema)
2. Implement fragment loader (frontmatter parsing)
3. Implement assembler (composition engine)
4. Create initial fragment library (core, user, eng domains)
5. Build CLI commands (fragments, beads, assemble)
6. Add validation (schema checking)
7. Test with real examples across multiple domains

---

## Open Questions

1. **Bead composition**: How do we merge user + project + team beads?
   - Proposal: Deep merge with explicit precedence (team < project < user)

2. **Fragment overrides**: Can users override shipped fragments?
   - Proposal: `~/.nancy/fragments/` takes precedence over `templates/fragments/`

3. **Validation strictness**: Hard fail or soft warnings on schema violations?
   - Proposal: Warnings during development, errors in CI

4. **Versioning**: How do we handle schema evolution?
   - Proposal: `nancy_version: "1.0"` in beads, migration scripts

5. **Multi-language projects**: How to handle polyglot codebases?
   - Proposal: Support arrays in `detected.language`, include all matching fragments

6. **Cross-domain tasks**: How to handle tasks that span multiple domains (e.g., product launch = eng + marketing + legal)?
   - Proposal: Support multiple domain tags in task metadata, include fragments from all relevant domains
