# Beads Evaluation - Comprehensive Research Report

**Research Date:** January 24, 2026
**Repository:** https://github.com/steveyegge/beads
**Author:** Steve Yegge
**License:** MIT
**Primary Language:** Go (94.5%)

---

## Executive Summary

Beads is a distributed, git-backed graph issue tracker designed specifically for AI coding agents. Created by Steve Yegge and released in mid-October 2025, it has experienced rapid adoption with 12,468 GitHub stars and tens of thousands of users in just over three months. The project addresses the fundamental "context window problem" in AI-driven development by providing persistent, structured memory through a dual-persistence model combining SQLite for performance and JSONL for git-friendliness.

**Current State:** Actively maintained with daily commits, version 0.49.0 released January 22, 2026. The project is in a "hypergrowth" phase with 180 contributors and 568 merged PRs, but faces scaling challenges and edge case issues.

**Key Innovation:** Replaces messy markdown plans with a dependency-aware graph database, allowing AI agents to query only the information needed for immediate tasks rather than loading entire project specs into their context window.

---

## 1. What is Beads?

### Original Purpose and Design Goals

Beads was created to solve the **context window problem** in AI-assisted development. When AI coding agents start fresh sessions, they lose all understanding of previous work, project goals, and architecture. Traditional approaches like markdown task files or chat history are inefficient and don't scale to large, long-horizon projects.

**Core Design Philosophy:**
- Treat the project plan as a queryable database, not a document
- Make dependencies first-class objects, not prose descriptions
- Enable agents to make small, targeted queries instead of loading entire specs
- Leverage git as the persistence layer for agent memory
- Prevent merge conflicts through hash-based IDs in multi-agent workflows

### Current State

**Development Activity (as of January 24, 2026):**
- Created: October 12, 2025
- Last Update: January 24, 2026
- Version: 0.49.0 (January 22, 2026)
- Commit Frequency: 12+ commits per 3-day period
- Active Contributors: 180 total, with steveyegge as primary maintainer

**Maturity Assessment:**
- **Phase:** Hypergrowth with stability challenges
- **Production Readiness:** Early adopters using in daily workflows, but numerous edge cases remain
- **Breaking Changes:** Frequent (26 breaking changes across recent versions)
- **Bug Density:** High - maintainer reports "half a dozen critical bugs per day for 3 solid weeks"

**Community Metrics:**
- Stars: 12,468
- Forks: 746
- Open Issues: 135
- Pull Requests: 26 open, 568 closed
- Watchers: 65 subscribers

### Core Features and Capabilities

**1. Hierarchical Task Organization**
- Epics, tasks, and subtasks through dotted notation (`bd-a3f8.1.1`)
- Hash-based IDs (`bd-a1b2`) prevent merge collisions
- Parent-child relationships for work breakdown

**2. Dependency Tracking**
- First-class dependency objects with types: blocks, parent-child, related, discovered-from
- Automatic detection of ready tasks (those without blockers)
- Visual dependency graphs

**3. Agent Optimization**
- JSON output for programmatic consumption
- CLI designed for non-interactive execution
- Query-based workflows (avoid loading entire database)

**4. Multi-Agent Coordination**
- Git-based synchronization across branches and machines
- Pull-first 3-way merge to prevent data loss
- Conflict-free concurrent writes through hash-based IDs

**5. Memory Management**
- Semantic summarization of old closed tasks (30+ days)
- Compaction commands to reduce database size
- "Memory decay" similar to human memory consolidation

**6. Work Modes**
- Standard: Full git integration with syncing
- Stealth: Local-only for personal use on shared projects
- Contributor: Open-source workflow support
- Sandbox: Disabled daemon for restricted environments

**7. Advanced Features**
- Molecular Chemistry: Template-based workflows (proto templates, persistent mols, ephemeral wisps)
- Federation: Multi-repo synchronization (v0.49.0)
- Custom type system for domain-specific workflows
- Plugin architecture for tracker integrations

### Technical Implementation

**Architecture - Three-Layer Data Model:**

```
┌─────────────────────────────────┐
│   SQLite Database Layer         │ <- Fast local queries, indexes, joins
│   (.beads/beads.db, gitignored) │
└─────────────────────────────────┘
           ↕ (sync)
┌─────────────────────────────────┐
│   JSONL File Layer              │ <- Git-tracked source of truth
│   (issues.jsonl)                │    Human-readable diffs
└─────────────────────────────────┘
           ↕ (git push/pull)
┌─────────────────────────────────┐
│   Remote Repository Layer       │ <- Distributed collaboration
│   (origin/main)                 │
└─────────────────────────────────┘
```

**Write Path:**
1. Command hits SQLite immediately
2. Dirty flag set, 5-second debounce applied
3. Export changed entities to JSONL (incremental)
4. Git hooks optionally auto-commit

**Read Path:**
1. `git pull` fetches new JSONL
2. Next bd command detects newer content
3. Auto-import via content-hash comparison
4. Merge strategies: same hash → skip, different hash → update, no match → create

**Daemon Architecture:**
- One daemon per workspace (follows LSP pattern)
- RPC server via Unix domain socket (`.beads/bd.sock`)
- Batches operations, holds open DB connections
- Background sync coordination
- Event-driven mode: <500ms latency, 60% less CPU than polling

**Technology Stack (from go.mod):**
- Go 1.24.0
- CLI: Cobra v1.10.2
- Config: Viper v1.21.0, YAML v3.0.1
- Database: SQLite3 (go-sqlite3 v0.30.4), DoltHub v0.2.0
- AI: Anthropic SDK for Go v1.19.0
- Terminal UI: Charmbracelet ecosystem (Glamour, Huh, Lipgloss, Bubbletea)
- WASM Runtime: Wazero v1.11.0
- File locking: gofrs/flock v0.13.0
- Date parsing: when v1.1.0

**Data Model:**

Core entity types:
- **Issues:** Work items with status (open → in_progress → closed), priority (0-4), type (epic, task, bug, etc.)
- **Dependencies:** Relationships with types (blocks, parent-child, related, discovered-from)
- **Labels:** Dimensional tags (`patrol:active`, `mode:degraded`)
- **Comments:** Discussion threads
- **Events:** Complete audit trail

**Directory Structure:**
```
.beads/
├── beads.db          # SQLite database (gitignored)
├── issues.jsonl      # Git-tracked source of truth
├── bd.sock           # Daemon socket (gitignored)
├── config.yaml       # Project configuration (optional)
└── .sync.lock        # Sync exclusion lock
```

---

## 2. How Does It Work?

### File Format and Structure

**JSONL Format:**
- One JSON object per line (newline-delimited JSON)
- Each line represents a complete issue entity
- Human-readable for git diffs
- Automatic merge-friendly (line-based)

**Example Issue Structure:**
```jsonl
{"id":"bd-a3f8","title":"Implement authentication","status":"open","priority":1,"type":"task","created_at":"2026-01-15T10:00:00Z","updated_at":"2026-01-15T10:00:00Z","description":"Add JWT-based auth","labels":["backend","security"],"dependencies":[{"type":"blocks","target":"bd-b2c4"}]}
```

### Storage Model

**Dual Persistence:**
1. **SQLite Primary:** All reads/writes hit local database first
2. **JSONL Secondary:** Export layer for git versioning
3. **Sync Coordination:** Daemon manages bidirectional consistency

**Hash-Based ID System:**
- IDs generated from random UUIDs → short hashes
- Start at 4 characters, grow to 5-6 as needed
- Collision prevention in concurrent multi-agent workflows
- No sequential numbering = no merge conflicts

**Progressive Scaling:**
```
Small project: bd-a3f8
Medium project: bd-a3f8e
Large project: bd-a3f8e9
```

### Query/Retrieval Mechanisms

**CLI Query Patterns:**

```bash
# Find all unblocked work
bd ready --json

# Filter by status
bd list --status open --json

# Filter by assignee
bd list --assignee me --json

# Filter by labels
bd list --label backend --label security --json

# Filter by priority
bd list --priority 0 --json

# Date range queries
bd list --created-after -P7D --json  # Last 7 days

# Text search
bd list --query "authentication" --json

# Dependency queries (optimized with cache)
bd show bd-a3f8 --json  # Includes dependency graph
```

**Performance:**
- Microbenchmark: 1000 issues in ~950ms
- SQLite: Sub-millisecond local queries
- Blocked issues cache: 25x improvement for dependency queries
- Event-driven daemon: <500ms latency
- Memory: 30-35MB (SQLite + WASM runtime)

### Composition/Merging Capabilities

**Three-Way Merge Process:**

1. **Load States:**
   - Local state (current SQLite)
   - Base state (last successful sync snapshot)
   - Remote state (pulled from git)

2. **Merge Strategies (Per-Field):**
   - **Scalars (title, description, status, priority):** Last-Write-Wins with clock skew detection
   - **Collections (labels, dependencies):** Union merge (combine all unique values)
   - **Conflicts:** Deterministic resolution via `bd resolve-conflicts`

3. **Conflict Scenarios:**
   - **Concurrent edits:** LWW based on timestamps
   - **Delete vs. Modify:** Modification wins (prevents silent data loss)
   - **Zombie resurrection:** Deleted issue reappears if locally modified
   - **Clock skew:** 24-hour warning threshold

**Sync Workflow:**

```bash
# Manual sync
bd sync

# Automatic sync (via daemon)
# Configured in config.yaml:
daemon:
  auto-sync: true
sync:
  mode: normal  # or sync-branch, external
```

**Sync Lock Mechanism:**
- Exclusive file lock: `.beads/.sync.lock`
- Immediate failure if concurrent sync detected
- Prevents race conditions

### Schema Validation

**Type System:**
- Built-in types: epic, task, bug, feature, improvement, test, doc
- Custom types via configuration (v0.45.0+)
- Status validation: open, in_progress, closed (with reopen capability)
- Priority validation: 0-4 (0=no priority, 1=urgent, 2=high, 3=normal, 4=low)

**Validation Rules:**
- Required fields: id, title, status, created_at, updated_at
- Optional fields: description, priority, type, assignee, labels, dependencies
- Dependency type validation: blocks, parent-child, related, discovered-from
- Hierarchical ID validation (parent must exist for child IDs)

**Import Validation:**
- Orphan handling modes: skip, adopt, fail
- Parent-first import ordering for hierarchical issues
- Content hash deduplication

---

## 3. Adoption and Ecosystem

### Production Use Cases

**Reported Usage:**
- "Tens of thousands" of users (as of November 2025)
- Daily workflows for early adopters
- Complex multi-week projects completing that previously stalled
- Significant reduction in forgotten work, disabled tests, incomplete implementations

**Use Case Patterns:**
1. **Solo Developer + AI:** Personal TODO with agent memory
2. **Team Coordination:** Multi-agent workflows with git sync
3. **Open Source Contribution:** Contributor mode for external projects
4. **Large Project Management:** Multi-repo federation (v0.49.0)

**Success Stories:**
- Users report "love it so much they use it for personal TODO lists"
- "Complex projects that stalled at partial completion now progress methodically"
- "Rate of forgotten work drops significantly when AI has reliable external memory"

### Community Size and Activity

**GitHub Activity:**
- 135 open issues (January 2026)
- Active discussion in issues and PRs
- Community PRs: race condition fixes, Windows support, ARM builds, merge drivers
- Response pattern: Fast iteration but high bug density

**Community Engagement:**
- GitHub Discussions #276: Community tools showcase
- Active contribution to ecosystem tools
- Pull request acceptance rate: 568 merged / (568+26 open) = 95.6%

**Growth Trajectory:**
- Released: Mid-October 2025
- Stars: 12.5k in 3 months (~4k/month)
- Contributors: 180 in 3 months
- Described as "going viral" by creator

### Library Support

**Official Implementations:**
- **Go:** Primary implementation (github.com/steveyegge/beads)
- **TypeScript/Node:** npm package `@beads/bd`
- **Python:** `beads-mcp` on PyPI (v0.49.0)

**Community Ports:**
- **Rust:** beads_rust by Dicklesworthstone - "fast Rust port for stable, minimal tracker"
- Described as: "use br for stability, use beads for advanced features"

**Installation Methods:**
```bash
# npm
npm install -g @beads/bd

# Homebrew
brew install steveyegge/beads/bd

# Go
go install github.com/steveyegge/beads/cmd/bd@latest

# Direct shell script
curl -sSL https://beads.sh | bash
```

**Platform Support:**
- Linux (AMD64, ARM64)
- macOS (Intel, Apple Silicon)
- Windows (AMD64, ARM64)
- FreeBSD
- Android/Termux (ARM64)
- WSL2 (with known issues)

### Tooling and Ecosystem

**Terminal UIs:**
- **beads_viewer** (Go) - Tree navigation, vim-style commands
- **bdui** (Node.js) - Interactive terminal interface
- **bsv** (Rust) - Rust-based viewer

**Web UIs:**
- **beads-ui** - Live updates, kanban board
- **beads-dashboard** - Metrics (lead time, throughput analysis)

**Editor Extensions:**
- **VS Code:** vscode-beads, ANAL Beads, Beads-Kanban
- **Neovim:** Neovim plugins
- **Emacs:** Emacs tools

**Native Applications:**
- **Beadster** (macOS) - Native Mac application
- **Parade** (Electron) - Cross-platform desktop app

**Integration Middleware:**
- **jira-beads-sync** - Bidirectional Jira synchronization
- **beads-orchestration** - Multi-agent orchestration for Claude Code
- **GitLab backend** - Bidirectional GitLab issue sync

**AI Agent Integrations:**
- Claude (primary design target)
- Aider (documented integration: AIDER_INTEGRATION.md)
- Generic MCP server support

**Development Tools:**
- Merge drivers for git
- Shell completion scripts
- Git hooks for auto-sync
- DeepWiki integration for documentation

---

## 4. Strengths and Weaknesses

### What It Does Exceptionally Well

**1. Solves the Context Window Problem**
- Query-based access vs. loading entire specs
- Agents retrieve only needed information for immediate tasks
- Semantic compaction preserves essential context while reducing size

**2. Dependency Management**
- First-class dependency objects (not prose)
- Automatic ready-task detection (`bd ready`)
- Explicit blocking relationships prevent out-of-order execution

**3. Multi-Agent Coordination**
- Hash-based IDs eliminate sequential number collisions
- Git-based distribution (no special sync server needed)
- Conflict-free concurrent issue creation

**4. Git Integration**
- JSONL format provides readable diffs
- Automatic merge-friendly (line-based changes)
- Issues travel with code, offline work "just works"
- Standard git workflows (push/pull/branch)

**5. Performance**
- SQLite local cache for fast queries
- Blocked issues cache: 25x dependency query improvement
- Event-driven daemon: <500ms latency
- Incremental export for large codebases

**6. Developer Experience**
- Rich CLI with shell completions
- JSON output for programmatic consumption
- Extensive documentation (49 files in /docs)
- Active community building ecosystem tools

### Known Limitations and Problems

**1. Stability and Bugs**
- **Critical Assessment:** "Very buggy" per creator
- **Bug Density:** "Half a dozen critical bugs per day for 3 solid weeks"
- **Edge Cases:** "Crummy architecture that requires AI to work around edge cases"
- **Data Loss Risks:** Child issues not exporting (#1278), sync reverting files (#1258)

**2. Complexity and Learning Curve**
- **Multi-Database Issues:** "Agents behaving unpredictably with multiple databases"
- **Sync Confusion:** "Worktrees falling out of sync"
- **Documentation:** Users report "AI-generated docs make it impossible to understand" (#376)
- **Recovery:** "Documentation doesn't explain how to recover from broken states"

**3. Configuration Problems**
- Settings ignored: `sync.mode` from config.yaml (#1277)
- Auto-sync not read from config (#1235)
- Daemon behavior inconsistent with configuration

**4. Platform-Specific Issues**
- **Windows:** Postinstall fails with file lock errors (#1252)
- **WSL2:** Stack overflow with SQLite WAL locking (#1224)
- **Git Worktrees:** Daemon incompatibility (requires `BEADS_NO_DAEMON=1`)

**5. Invasiveness Concerns**
- **Auto-Push Behavior:** "Wants to git push anytime issue changes, conflicts with deployment workflows"
- **Override Failures:** "Behavior persists despite attempts to override"
- **.beads Directory:** Requires committing to project repository

**6. Scalability Limitations**
- **Performance Degradation:** "Keep active database under ~500 tasks" for good performance
- **Large Projects:** JSONL files grow large (10k+ issues slow export/import)
- **Workaround Required:** Regular `bd cleanup` to archive completed work

**7. Multi-Process Concurrency**
- **SQLite Locking:** "Database is locked" with multiple processes
- **Workaround:** Use `--no-db` in-memory mode, but loses persistence benefits

**8. Merge Conflicts**
- **JSONL Conflicts:** "Often happen during merges"
- **Manual Resolution:** "Users need to ask agents to clean up messes"
- **Broken Rebases:** Common occurrence requiring intervention

**9. Sync Challenges**
- **Race Conditions:** "Export-after-commit race condition" (#1208)
- **Uncommitted Changes:** Sync fails with dirty state
- **Clock Skew:** Machine clock differences cause LWW to select wrong version
- **Zombie Issues:** Deleted issues resurrect if locally modified

**10. Migration Friction**
- **No Auto-Import:** "No automated migration tools from GitHub/Jira/Linear"
- **Custom Scripts Required:** Users must write own import logic
- **Cross-Project Refs:** "Unsupported by design"

### Performance Characteristics

**Benchmarks (Documented):**
- 1000 issues: ~950ms (no hardware/concurrency details)
- SQLite queries: Sub-millisecond
- Blocked issues cache: 25x improvement
- Daemon latency: <500ms (event-driven)
- Memory: 30-35MB

**Real-World Performance:**
- Small projects (<500 issues): Excellent
- Medium projects (500-5k issues): Good, requires periodic cleanup
- Large projects (10k+ issues): Degraded, filtering required

**Bottlenecks:**
- JSONL export/import on large databases
- N+1 query issues (fixed in recent versions)
- Dependency graph traversal without cache

### Edge Cases and Gotchas

**1. Hierarchical Issue Parents Missing**
- Import fails if parent not imported first
- Orphan handling modes: skip, adopt, fail

**2. Concurrent Deletion and Modification**
- Modification always wins (prevents silent data loss)
- Deleted issues can "resurrect"

**3. Sandbox Environment Detection**
- Auto-detection sometimes fails
- Manual override: `bd --sandbox`

**4. Database Staleness**
- After `git pull`, must run any bd command to trigger auto-import
- Install git hooks for immediate sync

**5. Multi-Agent Last-Write-Wins**
- "Last agent to export/commit wins"
- Requires manual coordination (status claims, assignee filtering, git diffs)

**6. Daemon State Confusion**
- Stale daemon prevents sync
- "Database out of sync" errors persist
- Kill and restart required

**7. Git Hooks Permission Issues**
- Auto-sync fails silently if hooks not executable
- Manual installation: `bd hooks install`

**8. WAL Mode Conflicts**
- SQLite WAL checkpointing issues on network filesystems
- WSL2 specific locking problems

**9. Breaking Changes**
- Frequent breaking changes across versions
- Manual migration after upgrades: `bd migrate`

**10. ID Collision Math Edge Cases**
- Hash collisions theoretically possible but rare
- Progressive ID length scaling required for very large projects

---

## 5. Evolution and Maintenance

### Active Maintenance Status

**Current Status:** **Highly Active**

**Commit Activity:**
- Daily commits (as of January 24, 2026)
- Average: 12+ commits per 3-day period
- Recent burst: 22 commits on January 22 (v0.49.0 release)
- Consistent multi-day stretches of 5-8 commits

**Maintainer Engagement:**
- Primary: steveyegge (with Claude AI co-authoring)
- 10 hours/day responding to bug reports (per creator)
- Community contributors: aleiby, maphew, peterkc, irbull

**Release Cadence:**
- Version 0.40.0: December 28, 2025
- Version 0.49.0: January 22, 2026
- ~9 versions in 25 days = ~2.8 days/release
- Rapid iteration indicates active development but also instability

### Breaking Changes History

**Major Breaking Changes (v0.40.0 - v0.49.0):**

1. **Hash-Based IDs** (v0.20.0)
   - Replaced sequential numbering
   - Migration: All existing IDs regenerated

2. **Configuration Format** (v0.43.0)
   - JSON → YAML migration
   - Manual config file updates required

3. **Daemon Architecture** (v0.41.0)
   - Global socket → per-project daemons
   - Daemon restart required after upgrade

4. **Sync Branch Behavior** (v0.47.0)
   - Pull-first 3-way merge introduced
   - Changed sync semantics

5. **Status Field Semantics** (v0.46.0)
   - "deleted" → "tombstone" in JSONL
   - Data format migration

6. **Gas Town Type Extraction** (v0.44.0)
   - Built-in convoy/phase types → custom types
   - Config migration for users of these types

7. **Multi-Prefix Routing** (v0.45.0)
   - `allowed_prefixes` config added
   - Changes default routing behavior

8. **Per-Field Merge Strategies** (v0.49.0)
   - New conflict resolution semantics
   - Potential merge behavior changes

**Breaking Change Frequency:** ~0.9 breaking changes per version (26 across ~29 versions)

### Backward Compatibility Approach

**Migration Strategy:**
- `bd migrate` command after upgrades
- Automatic schema migrations
- JSONL format migrations applied to git history

**Compatibility Guarantees:**
- **None explicitly stated** - project in rapid development
- Config files: Breaking changes with manual update guides
- Database schema: Automatic migrations
- CLI flags: Deprecated flags maintained temporarily with warnings

**Versioning Approach:**
- Currently pre-1.0 (0.x.x versions)
- No semantic versioning guarantees
- Frequent minor version bumps with breaking changes

**Upgrade Path:**
1. Pull latest JSONL from git
2. Upgrade bd binary
3. Run `bd migrate`
4. Test in sandbox mode before committing
5. Export to verify JSONL consistency

### Roadmap and Future Plans

**Recent Focus Areas (v0.47.0 - v0.49.0):**

1. **Federation & Multi-Repo** (v0.49.0)
   - Peer-to-peer sync across repositories
   - SQLite-to-Dolt migration for multi-client access
   - Dolt server mode for collaborative workflows

2. **Sync Robustness** (v0.47.0 - v0.48.0)
   - Pull-first 3-way merge
   - Automatic conflict resolution
   - Timestamp preservation improvements

3. **Plugin Architecture** (v0.46.0 - v0.48.0)
   - Versioned storage interface
   - Pluggable backends support
   - External tracker integrations (Jira, GitLab)

4. **Developer Experience** (v0.47.0)
   - Dynamic shell completions for issue IDs
   - Tree display for hierarchical issues
   - Dry-run previews for commands

5. **Performance** (v0.45.0 - v0.49.0)
   - Incremental export for large codebases
   - Blocked issues cache optimization
   - N+1 query elimination

**Community-Requested Features (from open issues):**

1. **Enhanced Filtering** (#1295)
   - External reference lookup
   - Advanced query DSL

2. **Batch Operations** (#1253)
   - Multi-field edit commands
   - Bulk status updates

3. **Data Integrity** (#1278, #1208)
   - Child issue export reliability
   - Race condition elimination

4. **Platform Support**
   - Windows/WSL2 stability (#1252, #1224)
   - Network filesystem compatibility

**Probable Future Direction:**

Based on creator statements and recent commits:

1. **Stabilization Phase**
   - Bug density reduction (currently primary focus)
   - Edge case hardening
   - Documentation improvements

2. **Multi-User Workflows**
   - Dolt backend for true multi-writer support
   - Real-time collaboration features
   - Conflict resolution UX improvements

3. **Enterprise Features**
   - Jira/Linear bidirectional sync maturity
   - Access control and permissions
   - Audit trail enhancements

4. **Performance Optimization**
   - Large project scaling (10k+ issues)
   - Query optimization for complex graphs
   - Export/import speed improvements

**Long-Term Vision:**

Based on creator's Medium articles:
- Become the standard memory system for AI agents
- Replace traditional markdown planning in AI workflows
- Enable truly long-horizon AI-assisted projects
- Complement (not replace) tools like Jira/GitHub Issues

**Uncertainty Factors:**
- High bug density may require extended stabilization
- Breaking changes frequency may deter adoption
- Competition from simpler alternatives (markdown, Linear, etc.)
- Dependency on AI agent ecosystem growth

---

## 6. Critical Assessment for Our Use Case

### Strengths Relevant to Nancy

**1. AI Agent Memory**
- Solves persistent context problem across sessions
- Query-based access aligns with token efficiency goals
- Dependency tracking for complex workflows

**2. Git Integration**
- JSONL format fits version control best practices
- Distributed collaboration model
- Code and tasks travel together

**3. Programmability**
- JSON output for agent consumption
- CLI designed for non-interactive use
- Extensive API through command flags

**4. Active Development**
- Rapid feature additions
- Responsive to community feedback
- Growing ecosystem

### Weaknesses for Nancy

**1. Stability Concerns**
- **Critical:** "Very buggy" with data loss risks
- High bug density indicates immaturity
- Frequent breaking changes disrupt workflows

**2. Complexity Overhead**
- Steep learning curve for developers and agents
- Multi-database confusion in practice
- Recovery from broken states poorly documented

**3. Invasive Integration**
- Requires `.beads/` directory in project
- Auto-push behavior conflicts with deployment workflows
- Git hooks can interfere with existing workflows

**4. Scalability Issues**
- Performance degradation above 500 active tasks
- JSONL file growth becomes problematic
- Requires active maintenance (cleanup, compaction)

**5. Edge Case Brittleness**
- Creator admits "crummy architecture requiring AI workarounds"
- Merge conflicts common
- Sync race conditions persist

### Alternative Approaches

**1. Lightweight SQLite + Git (DIY)**
- Implement minimal issue tracker ourselves
- JSONL export for git versioning
- Avoid beads complexity and bugs

**2. Markdown + Vector Search**
- Traditional spec files with embedding search
- Simpler, more stable
- Lower cognitive overhead

**3. External Tracker Integration**
- Use Linear/GitHub Issues directly via API
- Established tools, better stability
- Loss of git-native benefits

**4. Hybrid: Beads-Inspired Custom Solution**
- Adopt dual-persistence concept
- Simpler implementation (fewer features)
- Tailored to Nancy's specific needs

### Recommendation

**For Nancy's Current Phase: NOT RECOMMENDED**

**Reasons:**

1. **Stability Risk:** Data loss bugs and frequent breaking changes incompatible with production use
2. **Complexity:** Learning curve and operational overhead outweigh benefits for current scale
3. **Invasiveness:** Auto-push and git hook behaviors conflict with controlled workflows
4. **Maintenance Burden:** Regular cleanup/compaction required; high bug density demands constant attention

**Alternative Recommendation:**

Implement a **beads-inspired lightweight solution**:
- SQLite for local storage
- JSONL export for git versioning
- Simple dependency tracking
- Query-based agent access
- Avoid daemon complexity, auto-sync, multi-repo features

**Reevaluation Triggers:**

Consider beads again when:
1. Project reaches v1.0.0 with stability commitment
2. Bug density drops significantly (measured by issues/week)
3. Breaking changes cease (semantic versioning adopted)
4. Nancy scales to 500+ concurrent tasks requiring advanced features

**Immediate Action:**

1. Monitor beads development for stabilization
2. Prototype minimal SQLite+JSONL solution
3. Study beads architecture for design insights
4. Avoid production dependency until maturity proven

---

## 7. References and Resources

### Official Resources

**Repository and Code:**
- Main Repository: https://github.com/steveyegge/beads
- Go Package: https://pkg.go.dev/github.com/steveyegge/beads
- npm Package: https://www.npmjs.com/package/@beads/bd
- PyPI Package: https://pypi.org/project/beads-mcp/

**Documentation:**
- Quickstart: https://github.com/steveyegge/beads/blob/main/docs/QUICKSTART.md
- Architecture: https://github.com/steveyegge/beads/blob/main/docs/ARCHITECTURE.md
- CLI Reference: https://github.com/steveyegge/beads/blob/main/docs/CLI_REFERENCE.md
- Agent Instructions: https://github.com/steveyegge/beads/blob/main/AGENT_INSTRUCTIONS.md
- FAQ: https://github.com/steveyegge/beads/blob/main/docs/FAQ.md
- Troubleshooting: https://github.com/steveyegge/beads/blob/main/docs/TROUBLESHOOTING.md

**Creator's Articles:**
- Introducing Beads: https://steve-yegge.medium.com/introducing-beads-a-coding-agent-memory-system-637d7d92514a
- Best Practices: https://steve-yegge.medium.com/beads-best-practices-2db636b9760c
- The Beads Revolution: https://steve-yegge.medium.com/the-beads-revolution-how-i-built-the-todo-system-that-ai-agents-actually-want-to-use-228a5f9be2a9
- Beads Blows Up: https://steve-yegge.medium.com/beads-blows-up-a0a61bb889b4

### Community Resources

**Guides and Reviews:**
- Better Stack Guide: https://betterstack.com/community/guides/ai/beads-issue-tracker-ai-agents/
- YUV.AI Blog: https://yuv.ai/blog/beads
- Edgar Tools Analysis: https://www.edgartools.io/beads-and-the-future-of-programming/
- Debugg.AI Architecture: https://debugg.ai/resources/beads-memory-ai-coding-agents-automated-pm-developer-workflows
- Paddo Dev Blog: https://paddo.dev/blog/beads-memory-for-coding-agents/
- Logique Deep Dive: https://www.logique.co.id/blog/en/2026/01/15/beads-ai-memory-2/

**Community Tools:**
- beads_viewer (Go): https://github.com/Dicklesworthstone/beads_viewer
- beads_rust (Rust port): https://github.com/Dicklesworthstone/beads_rust
- Community Tools Discussion: https://github.com/steveyegge/beads/discussions/276

**Issues and Discussions:**
- Open Issues: https://github.com/steveyegge/beads/issues
- Pull Requests: https://github.com/steveyegge/beads/pulls
- Releases: https://github.com/steveyegge/beads/releases

### Key Statistics Summary

| Metric | Value |
|--------|-------|
| Created | October 12, 2025 |
| Current Version | 0.49.0 (Jan 22, 2026) |
| GitHub Stars | 12,468 |
| Forks | 746 |
| Contributors | 180 |
| Open Issues | 135 |
| Merged PRs | 568 |
| Primary Language | Go (94.5%) |
| License | MIT |
| Estimated Users | Tens of thousands |
| Release Frequency | ~2.8 days/release |
| Commit Frequency | 12+ commits/3 days |

---

## Appendix: Code Examples

### Basic Workflow

```bash
# Initialize beads in project
bd init

# Create epic
bd create "Build API" -t epic -p 1 --description="REST API for user management"

# Create dependent tasks
bd create "Design schema" -p 0 --parent bd-a3f8
bd create "Implement endpoints" -p 1 --parent bd-a3f8
bd create "Write tests" -p 2 --parent bd-a3f8

# Add blocking dependency
bd dep add bd-b2c4 bd-a3f9  # bd-b2c4 blocks bd-a3f9

# Find ready work
bd ready --json

# Claim work
bd update bd-a3f9 --status in_progress --assignee me

# Complete work
bd close bd-a3f9 --reason "Schema designed and reviewed"

# Sync to git
bd sync
```

### Agent Query Pattern

```bash
# Query unblocked tasks (JSON for parsing)
bd ready --json | jq '.[] | {id, title, priority}'

# Get specific issue details
bd show bd-a3f8 --json | jq '{title, status, dependencies}'

# Filter by label
bd list --label backend --status open --json

# Update multiple fields
bd update bd-a3f8 \
  --status in_progress \
  --priority 0 \
  --description "Updated requirements" \
  --json
```

### Configuration Example

```yaml
# .beads/config.yaml
daemon:
  auto-sync: true

sync:
  mode: normal  # or sync-branch, external

allowed_prefixes:
  - bd

custom_types:
  - name: research
    description: Research tasks
  - name: deployment
    description: Deployment activities
```

---

**Document Version:** 1.0
**Last Updated:** January 24, 2026
**Research Conducted By:** Claude (Sonnet 4.5)
**Review Status:** Complete
