# Alternative Structured Storage Formats for Developer Tool Configuration

**Research Date**: January 24, 2026
**Focus**: Configuration and context storage for Nancy bubble gum intelligence system
**Scope**: Modern developer tools (2024-2026), LLM/AI tool preferences, composability patterns

---

## Executive Summary

This research evaluates 10 alternative structured storage formats for developer tool configuration and context storage. Key findings:

1. **YAML** remains dominant in DevOps/infrastructure but has significant complexity issues
2. **TOML** is gaining strong momentum in modern ecosystems (Rust, Python)
3. **JSON5/HJSON** provide excellent human-friendly JSON alternatives
4. **SQLite** offers unique advantages for structured, queryable configuration
5. **LLMs show measurable preferences** for YAML > JSON > Markdown for accuracy

---

## Format Comparison Table

| Format | Human Readable | Comments | Type System | Schema Support | Composability | Ecosystem Maturity | LLM Friendly |
|--------|---------------|----------|-------------|----------------|---------------|-------------------|--------------|
| **YAML** | ⭐⭐⭐⭐ | ✅ | Implicit (dangerous) | JSON Schema | Include/Merge | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **TOML** | ⭐⭐⭐⭐⭐ | ✅ | Explicit | Limited | Partial | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **JSON5** | ⭐⭐⭐⭐ | ✅ | None | JSON Schema | Manual | ⭐⭐⭐ | ⭐⭐⭐ |
| **HCL** | ⭐⭐⭐⭐ | ✅ | Strong | Native | Modules | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **SQLite** | ⭐⭐ | ✅ (SQL) | Strong | Native | Foreign Keys | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| **RON** | ⭐⭐⭐⭐ | ✅ | Serde-based | Rust types | Limited | ⭐⭐⭐ | ⭐⭐ |
| **HOCON** | ⭐⭐⭐⭐ | ✅ | JSON-based | Limited | Merge/Substitution | ⭐⭐⭐ | ⭐⭐⭐ |
| **HJSON** | ⭐⭐⭐⭐⭐ | ✅ | None | JSON Schema | Manual | ⭐⭐⭐ | ⭐⭐⭐ |
| **StrictYAML** | ⭐⭐⭐⭐ | ✅ | Strong (schema) | Native | Include | ⭐⭐ | ⭐⭐⭐⭐ |
| **EDN** | ⭐⭐⭐ | ✅ | Rich | Tagged literals | Manual | ⭐⭐ | ⭐⭐ |

---

## 1. YAML (YAML Ain't Markup Language)

### Primary Use Cases
- **DevOps & Infrastructure**: Kubernetes, Ansible, Docker Compose
- **CI/CD Pipelines**: GitHub Actions, GitLab CI, CircleCI
- **ML/AI Tools**: MLflow, Kubeflow model configurations
- **Cloud Services**: AWS, Azure, Google Cloud configurations

### Features
- ✅ Comments (hash-style: `#`)
- ✅ Hierarchical structure
- ✅ Anchors and aliases for reuse
- ✅ Multi-document support
- ✅ Include directives (implementation-dependent)
- ⚠️ Implicit typing (dangerous)
- ⚠️ Indentation-sensitive (error-prone)

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

Appears simple at first glance but has significant hidden complexity. Strict indentation rules cause frequent errors that often result in valid YAML that represents invalid configuration.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐⭐⭐ (5/5)

**Parsers**:
- **JavaScript**: `js-yaml` (widely used, Node.js + browser)
- **Python**: `PyYAML`, `ruamel.yaml`
- **Rust**: `serde_yaml`, `yaml-rust`

**Schema Support**: JSON Schema (via deserialization)

**Validation**: Can be validated using JSON Schema after deserializing to native objects

### Composability
**Multiple Files**: Include directives vary by implementation
**Merge Patterns**: Anchors, aliases, and merge keys (`<<`)
**Override Patterns**: Docker Compose-style (base + override files)

### Pros
✅ Universal adoption in DevOps ecosystem
✅ Excellent for complex, nested configurations
✅ Cross-platform and language-agnostic
✅ Strong LLM performance (highest accuracy in tests)
✅ Human-readable with proper formatting
✅ Comments critical for maintainability

### Cons
❌ Specification is 23,449 words (vs TOML 3,339, JSON 1,969)
❌ Indentation errors create valid but incorrect config
❌ Implicit typing causes unexpected behavior
❌ IDE support limited for error detection
❌ "Norway problem" and other gotchas
❌ Cryptic error messages
❌ Version fragmentation (1.1 vs 1.2)

### Code Example
```yaml
# Application configuration
app:
  name: nancy-bubble-gum
  version: 1.0.0

  database:
    type: sqlite
    path: ./data/nancy.db

  features:
    - intelligence
    - context-tracking
    - llm-integration

  # Anchor for reuse
  defaults: &defaults
    timeout: 30
    retry: 3

  services:
    api:
      <<: *defaults
      port: 8080

    worker:
      <<: *defaults
      concurrency: 4
```

### Real-World Adoption
- **Kubernetes**: Industry standard for container orchestration
- **GitHub Actions**: Workflow configuration
- **Ansible**: Infrastructure automation
- **Prometheus**: Monitoring configuration
- **Docker Compose**: Multi-container applications

### References
- [YAML Tutorial - Spacelift](https://spacelift.io/blog/yaml)
- [YAML: probably not so great after all](https://www.arp242.net/yaml-config.html)
- [JSON vs YAML vs TOML: 2026 Comparison](https://dev.to/jsontoall_tools/json-vs-yaml-vs-toml-which-configuration-format-should-you-use-in-2026-1hlb)
- [Why YAML is bad and what to do about it](https://kula.blog/posts/yaml/)

---

## 2. TOML (Tom's Obvious, Minimal Language)

### Primary Use Cases
- **Rust Ecosystem**: Cargo package manager (`Cargo.toml`)
- **Python Packaging**: Poetry, PDM (`pyproject.toml`)
- **Cloud-Native**: Buildpacks configuration
- **Static Site Generators**: Hugo
- **Configuration Files**: Application settings where clarity matters

### Features
- ✅ Comments (hash-style: `#`)
- ✅ Explicit typing (no implicit conversion)
- ✅ Tables and nested tables
- ✅ Arrays and inline tables
- ✅ Date/time types
- ✅ Multi-line strings
- ⚠️ Limited deep nesting (uses dotted keys)

### Human Readability
**Rating**: ⭐⭐⭐⭐⭐ (5/5)

Exceptionally clear and obvious. No indentation sensitivity. Easy to understand at a glance.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐⭐ (4/5) - Growing rapidly

**Parsers**:
- **Rust**: `toml-rs` (native, serde integration)
- **Python**: `tomli` (built into Python 3.11+)
- **JavaScript**: `@iarna/toml`, `smol-toml`

**Schema Support**: Limited native support; JSON Schema after conversion

**Validation**: Primarily relies on application-level validation

### Composability
**Multiple Files**: Limited native support; typically handled at application level
**Merge Patterns**: Not built-in; requires custom implementation
**Override Patterns**: Environment-based overrides common

### Pros
✅ Simple, minimal specification (3,339 words)
✅ Explicit typing prevents surprises
✅ Clear error messages
✅ Growing adoption in modern ecosystems
✅ No indentation issues
✅ Excellent for flat/moderate hierarchies
✅ Poetry 2.0 (Jan 2025) standardizes Python ecosystem

### Cons
❌ Verbose for deeply nested structures
❌ Limited composability/include mechanisms
❌ Smaller ecosystem than YAML
❌ No built-in merge/override patterns
❌ Not ideal for very complex configurations

### Code Example
```toml
# Nancy Bubble Gum Configuration
[app]
name = "nancy-bubble-gum"
version = "1.0.0"

[app.database]
type = "sqlite"
path = "./data/nancy.db"

# Features array
features = ["intelligence", "context-tracking", "llm-integration"]

[app.defaults]
timeout = 30
retry = 3

[app.services.api]
port = 8080
timeout = 30
retry = 3

[app.services.worker]
concurrency = 4
timeout = 30
retry = 3

# Date/time support
[metadata]
created = 2026-01-24T10:30:00Z
```

### Real-World Adoption
- **Rust Cargo**: Universal adoption in Rust ecosystem
- **Python Poetry**: Modern Python dependency management (2.0 released Jan 2025)
- **Hugo**: Popular static site generator
- **Buildpacks**: Cloud-native build configuration
- **PDM**: Python package manager

### References
- [Why Buildpacks Use TOML - Heroku](https://www.heroku.com/blog/why-buildpacks-use-toml/)
- [Writing pyproject.toml - Python Packaging](https://packaging.python.org/en/latest/guides/writing-pyproject-toml/)
- [JSON vs TOML - IO Tools](https://iotools.cloud/journal/json-vs-toml-which-config-format-reigns/)

---

## 3. JSON5 (JSON for Humans)

### Primary Use Cases
- **Configuration Files**: VS Code settings, TypeScript configs
- **Developer Tools**: Modern build tools, linters
- **Application Config**: Where JSON is needed but comments are valuable
- **Hand-Written Data**: Configuration that needs to be human-editable

### Features
- ✅ Comments (single-line `//` and multi-line `/* */`)
- ✅ Trailing commas in arrays and objects
- ✅ Unquoted object keys (if valid identifiers)
- ✅ Single-quoted strings
- ✅ Multi-line strings
- ✅ Hexadecimal numbers
- ✅ Leading/trailing decimal points

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

Very readable, essentially "JSON with the annoying parts fixed". Familiar to JavaScript developers.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐ (3/5) - Stable but niche

**Parsers**:
- **JavaScript**: `json5` (official implementation)
- **Python**: `json5` (Cython-based)
- **Rust**: `json5` (serde-compatible)

**Schema Support**: JSON Schema (compatible)

**Validation**: Full JSON Schema support

### Composability
**Multiple Files**: No built-in support; manual composition required
**Merge Patterns**: Application-level logic needed
**Override Patterns**: Custom implementation

### Pros
✅ Backward compatible with JSON
✅ Comments make configuration self-documenting
✅ Trailing commas prevent common errors
✅ More forgiving syntax than JSON
✅ JavaScript ecosystem familiarity
✅ 1.0.0 spec stable since 2018, still relevant in 2025

### Cons
❌ Not as widely adopted as YAML/TOML
❌ No built-in composability features
❌ Less tooling than mainstream formats
❌ Not standardized (not an official JSON version)

### Code Example
```json5
// Nancy Bubble Gum Configuration
{
  app: {
    name: "nancy-bubble-gum",
    version: "1.0.0",

    database: {
      type: "sqlite",
      path: "./data/nancy.db",
    },

    // Feature flags
    features: [
      "intelligence",
      "context-tracking",
      "llm-integration", // trailing comma OK
    ],

    defaults: {
      timeout: 30,
      retry: 3,
    },

    services: {
      api: {
        port: 8080,
        timeout: 30,
        retry: 3,
      },

      worker: {
        concurrency: 4,
        timeout: 30,
        retry: 3,
      },
    },
  },

  /* Multi-line comment
     for detailed notes */
  metadata: {
    created: "2026-01-24T10:30:00Z",
  },
}
```

### Real-World Adoption
- **VS Code**: Settings and configuration files
- **TypeScript**: `tsconfig.json` supports JSON5-style comments
- **Babel**: `.babelrc` configuration
- **ESLint**: Configuration files

### References
- [JSON5 Official Site](https://json5.org/)
- [Understanding JSON and JSON5](https://json-5.com/json-vs-json5)
- [The JSON5 Data Interchange Format Spec](https://spec.json5.org/)
- [Evolving Landscape of Data Formats 2025](https://dev.to/dataformathub/the-evolving-landscape-of-data-formats-json-yaml-and-the-rise-of-specialized-standards-in-2025-3mp8)

---

## 4. HCL (HashiCorp Configuration Language)

### Primary Use Cases
- **Infrastructure as Code**: Terraform, OpenTofu
- **HashiCorp Tools**: Consul, Vault, Nomad, Boundary
- **Declarative Infrastructure**: Defining desired state
- **Cloud Provisioning**: Multi-cloud infrastructure

### Features
- ✅ Comments (hash `#` and C-style `//`, `/* */`)
- ✅ Blocks and nested blocks
- ✅ Interpolation and expressions
- ✅ Functions and built-ins
- ✅ Conditionals and loops
- ✅ Module composition
- ✅ Strong typing

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

Clear block structure, designed for human reading first. Declarative style is intuitive.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐⭐ (4/5)

**Parsers**:
- **Go**: `hcl` (official HashiCorp library)
- **JavaScript**: `hcl2-parser`
- **Python**: `python-hcl2`

**Schema Support**: Native HCL schema validation

**Validation**: `terraform fmt` for formatting, `terraform validate` for validation

### Composability
**Multiple Files**: Module system for composition
**Merge Patterns**: Variable overrides, module inputs/outputs
**Override Patterns**: Environment variables, variable files

### Pros
✅ Purpose-built for infrastructure configuration
✅ Strong typing and validation
✅ Excellent module system
✅ Interpolation and expressions
✅ Proven at scale (Terraform ecosystem)
✅ Clear error messages
✅ Formatting tools (`terraform fmt`)

### Cons
❌ Domain-specific (infrastructure-focused)
❌ Smaller ecosystem outside HashiCorp tools
❌ Learning curve for non-Terraform users
❌ Overkill for simple configurations

### Code Example
```hcl
# Nancy Bubble Gum Configuration

app "nancy-bubble-gum" {
  version = "1.0.0"

  database {
    type = "sqlite"
    path = "./data/nancy.db"
  }

  features = [
    "intelligence",
    "context-tracking",
    "llm-integration"
  ]

  defaults {
    timeout = 30
    retry   = 3
  }

  service "api" {
    port    = 8080
    timeout = var.defaults.timeout
    retry   = var.defaults.retry
  }

  service "worker" {
    concurrency = 4
    timeout     = var.defaults.timeout
    retry       = var.defaults.retry
  }
}

# Variable interpolation
variable "environment" {
  default = "development"
}

output "config_path" {
  value = "${path.module}/configs/${var.environment}"
}
```

### Real-World Adoption
- **Terraform**: Industry-standard IaC tool
- **OpenTofu**: Open-source Terraform alternative
- **Consul**: Service mesh and configuration
- **Vault**: Secrets management
- **Nomad**: Container orchestration

### References
- [HCL Syntax - Terraform](https://developer.hashicorp.com/terraform/language/syntax/configuration)
- [HCL Overview - HashiCorp](https://developer.hashicorp.com/terraform/language)
- [HCL Tutorial - Spacelift](https://spacelift.io/blog/hcl-hashicorp-configuration-language)
- [HCL GitHub Repository](https://github.com/hashicorp/hcl)

---

## 5. SQLite (Embedded SQL Database)

### Primary Use Cases
- **Structured Configuration**: Queryable, relational config data
- **Application State**: Persistent application state storage
- **Cache Storage**: Configuration caching with TTL
- **Version History**: Config versioning and auditing
- **Mobile/IoT**: Embedded device configuration
- **Browser Storage**: Durable Objects (Cloudflare)

### Features
- ✅ SQL queries for complex retrieval
- ✅ ACID transactions
- ✅ Schema enforcement
- ✅ Triggers and constraints
- ✅ Indexes for performance
- ✅ JSONB support (added 2024)
- ✅ Full-text search
- ✅ Zero configuration
- ✅ Single-file database

### Human Readability
**Rating**: ⭐⭐ (2/5)

Binary format, not directly human-readable. Requires tools (DB Browser, sqlite3 CLI) for inspection.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐⭐⭐ (5/5)

**Tools**:
- **CLI**: `sqlite3` (built-in)
- **GUI**: DB Browser for SQLite, DBeaver, Beekeeper Studio
- **Replication**: LiteFS, rqlite
- **Cloud**: Turso (distributed SQLite), SQLite.ai

**Schema Support**: Native SQL schema with DDL

**Validation**: CHECK constraints, triggers, foreign keys

### Composability
**Multiple Files**: ATTACH DATABASE for multi-file queries
**Merge Patterns**: JOIN operations, UNION queries
**Override Patterns**: UPDATE statements, triggers

### Pros
✅ Zero configuration, embedded
✅ ACID compliance
✅ Powerful query capabilities
✅ Schema enforcement
✅ Excellent for structured data
✅ Version control friendly (with tools)
✅ Footprint under 1MB
✅ JSONB support (2024)
✅ Mature, stable, trusted
✅ Cross-platform

### Cons
❌ Not human-readable (binary)
❌ Requires tooling for editing
❌ Learning curve (SQL knowledge)
❌ Overkill for simple configs
❌ Not ideal for hand-editing
❌ Merge conflicts harder to resolve

### Code Example
```sql
-- Schema definition
CREATE TABLE app_config (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    type TEXT NOT NULL CHECK(type IN ('string', 'number', 'boolean', 'json')),
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE features (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    enabled BOOLEAN DEFAULT 1
);

CREATE TABLE services (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    port INTEGER,
    timeout INTEGER,
    retry INTEGER,
    config TEXT -- JSONB column
);

-- Trigger for timestamp updates
CREATE TRIGGER update_timestamp
AFTER UPDATE ON app_config
BEGIN
    UPDATE app_config SET updated_at = CURRENT_TIMESTAMP WHERE key = NEW.key;
END;

-- Insert configuration
INSERT INTO app_config (key, value, type) VALUES
    ('app.name', 'nancy-bubble-gum', 'string'),
    ('app.version', '1.0.0', 'string'),
    ('database.type', 'sqlite', 'string'),
    ('database.path', './data/nancy.db', 'string'),
    ('defaults.timeout', '30', 'number'),
    ('defaults.retry', '3', 'number');

INSERT INTO features (name, enabled) VALUES
    ('intelligence', 1),
    ('context-tracking', 1),
    ('llm-integration', 1);

INSERT INTO services (name, port, timeout, retry, config) VALUES
    ('api', 8080, 30, 3, '{"host": "0.0.0.0"}'),
    ('worker', NULL, 30, 3, '{"concurrency": 4}');

-- Query examples
SELECT * FROM app_config WHERE key LIKE 'database.%';

SELECT s.name, s.port, json_extract(s.config, '$.concurrency') as concurrency
FROM services s
WHERE s.name = 'worker';
```

### Real-World Adoption
- **Mobile Apps**: iOS, Android application state
- **Browsers**: Web SQL (deprecated), modern alternatives
- **Cloudflare**: Durable Objects with SQLite storage
- **Turso**: Distributed edge database
- **DuckDB**: Analytics extension of SQLite concepts

### References
- [Top 8 Embedded SQL Databases 2025 - Explo](https://www.explo.co/blog/embedded-sql-databases)
- [SQLite Wikipedia](https://en.wikipedia.org/wiki/SQLite)
- [Embedded Databases 2025 Trends - Kestra](https://kestra.io/blogs/embedded-databases)
- [Cloudflare SQLite in Durable Objects](https://blog.cloudflare.com/sqlite-in-durable-objects/)

---

## 6. RON (Rusty Object Notation)

### Primary Use Cases
- **Rust Configuration**: Game engines (Bevy, Amethyst)
- **Rust Data Files**: Asset configuration
- **Game Development**: Scene files, entity definitions
- **Rust-Native Projects**: Where Serde integration is key

### Features
- ✅ Comments (C-style `//` and `/* */`)
- ✅ Rust-like syntax
- ✅ Serde data model support
- ✅ Structs, enums, tuples, arrays
- ✅ Named and unnamed fields
- ✅ Generic maps
- ✅ Extensions and custom types

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

Very readable for Rust developers. Looks like actual Rust code, which is both familiar and intuitive.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐ (3/5) - Rust-specific

**Parsers**:
- **Rust**: `ron` (49.3M+ downloads, 8.6M recent)

**Schema Support**: Rust type system via Serde

**Validation**: Compile-time type checking via Rust

### Composability
**Multiple Files**: Limited built-in support; requires custom loading
**Merge Patterns**: Application-level logic
**Override Patterns**: Rust-based merging strategies

### Pros
✅ Perfect for Rust ecosystem
✅ Type-safe via Serde
✅ Familiar to Rust developers
✅ Strong adoption in Rust games
✅ Supports complex Rust types
✅ Clear, readable syntax
✅ Dual-licensed (Apache-2.0/MIT)

### Cons
❌ Rust-specific (limited cross-language)
❌ Smaller ecosystem outside Rust
❌ No built-in composability
❌ Not widely known outside Rust community

### Code Example
```ron
// Nancy Bubble Gum Configuration
(
    app: (
        name: "nancy-bubble-gum",
        version: "1.0.0",

        database: (
            type: "sqlite",
            path: "./data/nancy.db",
        ),

        features: [
            "intelligence",
            "context-tracking",
            "llm-integration",
        ],

        defaults: (
            timeout: 30,
            retry: 3,
        ),

        services: {
            "api": Service(
                port: Some(8080),
                timeout: 30,
                retry: 3,
                config: {},
            ),
            "worker": Service(
                port: None,
                timeout: 30,
                retry: 3,
                config: {
                    "concurrency": 4,
                },
            ),
        },
    ),

    /* Multi-line comment
       for detailed configuration notes */
    metadata: (
        created: "2026-01-24T10:30:00Z",
    ),
)
```

### Real-World Adoption
- **Bevy**: Popular Rust game engine
- **Amethyst**: Game engine (accepted RON as config format)
- **Rust Projects**: Growing usage in Rust ecosystem

### References
- [RON GitHub Repository](https://github.com/ron-rs/ron)
- [RON Crates.io](https://crates.io/crates/ron)
- [RON Documentation](https://docs.rs/ron)
- [RON Rust Crate Guide](https://generalistprogrammer.com/tutorials/ron-rust-crate-guide)

---

## 7. HOCON (Human-Optimized Config Object Notation)

### Primary Use Cases
- **JVM Applications**: Akka, Play Framework
- **.NET Applications**: Akka.NET
- **Sponge Plugins**: Minecraft server configuration
- **StreamBase**: Configuration files
- **Conveyor**: Package configuration

### Features
- ✅ Comments (hash `#` and C-style `//`, `/* */`)
- ✅ JSON superset (all JSON is valid HOCON)
- ✅ Variable substitution (`${path.to.value}`)
- ✅ Include files
- ✅ Configuration merging
- ✅ Optional commas, quotes
- ✅ Unquoted strings
- ✅ Concatenation

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

Very readable, less verbose than JSON. Substitutions can be complex but powerful.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐ (3/5) - JVM/.NET focused

**Parsers**:
- **Java/Scala**: Typesafe Config (Lightbend)
- **C#**: HOCON (Akka.NET)
- **JavaScript**: Limited support

**Schema Support**: Limited; relies on application validation

**Validation**: Application-level validation typical

### Composability
**Multiple Files**: Include directive built-in
**Merge Patterns**: Automatic merging, last-wins semantics
**Override Patterns**: Environment-based overrides, substitution

### Pros
✅ Powerful substitution and includes
✅ Configuration merging built-in
✅ Less verbose than JSON
✅ JSON-compatible
✅ Great for complex JVM apps
✅ Well-documented

### Cons
❌ Primarily JVM/.NET ecosystem
❌ Limited cross-language support
❌ Substitution complexity can be confusing
❌ Smaller community than YAML/JSON

### Code Example
```hocon
# Nancy Bubble Gum Configuration

app {
  name = nancy-bubble-gum
  version = 1.0.0

  database {
    type = sqlite
    path = "./data/nancy.db"
  }

  features = [
    intelligence,
    context-tracking,
    llm-integration
  ]

  # Defaults that can be referenced
  defaults {
    timeout = 30
    retry = 3
  }

  services {
    api {
      port = 8080
      # Variable substitution
      timeout = ${app.defaults.timeout}
      retry = ${app.defaults.retry}
    }

    worker {
      concurrency = 4
      timeout = ${app.defaults.timeout}
      retry = ${app.defaults.retry}
    }
  }
}

# Include other config files
include "environments/development.conf"

# Environment variable substitution
database.path = ${?DATABASE_PATH}

metadata {
  created = 2026-01-24T10:30:00Z
}
```

### Real-World Adoption
- **Akka**: Actor framework (Java/Scala)
- **Play Framework**: Web framework
- **Sponge**: Minecraft server platform
- **Akka.NET**: .NET actor framework
- **Conveyor**: Application packaging

### References
- [HOCON Overview - Akka.NET](https://getakka.net/articles/configuration/hocon.html)
- [HOCON Introduction - Sponge](https://docs.spongepowered.org/stable/en/server/getting-started/configuration/hocon.html)
- [HOCON Specification - Lightbend](https://github.com/lightbend/config/blob/main/HOCON.md)
- [HOCON Secret Behind .conf Files](https://dev.to/sriramsridhar/hocon-secret-behind-conf-files-3051)

---

## 8. HJSON (Human JSON)

### Primary Use Cases
- **Configuration Files**: Where JSON is required but needs human-friendliness
- **Settings Files**: Application and user preferences
- **Data Exchange**: When JSON is standard but readability matters
- **Documentation**: Self-documenting configuration files

### Features
- ✅ Comments (hash `#`, C-style `//`, block `/* */`)
- ✅ Optional commas
- ✅ Optional quotes for keys and strings
- ✅ Multiline strings
- ✅ Trailing commas allowed
- ✅ JSON superset (all JSON is valid HJSON)

### Human Readability
**Rating**: ⭐⭐⭐⭐⭐ (5/5)

Extremely readable. Eliminates JSON's most annoying features while maintaining compatibility.

### Tooling & Ecosystem
**Maturity**: ⭐⭐⭐ (3/5)

**Parsers**:
- **JavaScript**: `hjson` (npm package)
- **Python**: `hjson-py`
- **Java**: `hjson-java`
- **PHP**: Available on Packagist

**Schema Support**: JSON Schema compatible

**Validation**: JSON Schema after parsing

### Composability
**Multiple Files**: No built-in support; manual composition
**Merge Patterns**: Application-level
**Override Patterns**: Custom implementation

### Pros
✅ Extremely human-friendly
✅ JSON-compatible
✅ Comments encouraged
✅ No comma errors
✅ Multi-language support
✅ CLI tools available
✅ Easy migration from JSON

### Cons
❌ Smaller ecosystem than JSON5
❌ No built-in composability
❌ Less common than alternatives
❌ Not an official standard

### Code Example
```hjson
{
  # Nancy Bubble Gum Configuration

  app: {
    name: nancy-bubble-gum
    version: 1.0.0

    database: {
      type: sqlite
      path: ./data/nancy.db
    }

    // Feature flags
    features: [
      intelligence
      context-tracking
      llm-integration
    ]

    defaults: {
      timeout: 30
      retry: 3
    }

    services: {
      api: {
        port: 8080
        timeout: 30
        retry: 3
      }

      worker: {
        concurrency: 4
        timeout: 30
        retry: 3
      }
    }
  }

  /* Multi-line comment
     for detailed configuration notes */
  metadata: {
    created: 2026-01-24T10:30:00Z
  }
}
```

### Real-World Adoption
- Growing usage in projects seeking human-friendly JSON
- Recognized as one of the JSON supersets with useful features
- Used in various web development projects

### References
- [HJSON Official Site](https://hjson.github.io)
- [HJSON GitHub JavaScript](https://github.com/hjson/hjson-js)
- [HJSON RFC](https://hjson.github.io/rfc.html)
- [JSON vs Human JSON - Medium](https://medium.com/@dwinTech/json-vs-human-json-which-format-fits-your-needs-9761180bb5f9)

---

## 9. StrictYAML (Type-Safe YAML Subset)

### Primary Use Cases
- **Type-Safe Configuration**: Where YAML readability is needed with type safety
- **Validated Data**: Configuration requiring strict schema validation
- **Python Projects**: Especially where security matters
- **Testing**: Integration tests with type-safe YAML

### Features
- ✅ Comments (hash-style `#`)
- ✅ Type safety via schemas
- ✅ Clear error messages with line numbers
- ✅ Schema validation (Map, Str, Int, Seq, Decimal)
- ✅ Comment preservation on round-trip
- ✅ No duplicate keys
- ✅ Strict indentation enforcement
- ❌ Removes dangerous YAML features

### Human Readability
**Rating**: ⭐⭐⭐⭐ (4/5)

As readable as YAML but safer. Enforces consistency that aids readability.

### Tooling & Ecosystem
**Maturity**: ⭐⭐ (2/5) - Python-specific

**Parsers**:
- **Python**: `strictyaml` (PyPI)

**Schema Support**: Native schema system (Map, Str, Int, Seq, etc.)

**Validation**: Built-in schema validation with detailed errors

### Composability
**Multiple Files**: Include support possible
**Merge Patterns**: Application-level
**Override Patterns**: Schema-validated merging

### Pros
✅ Type-safe YAML parsing
✅ Security-focused (removes dangerous features)
✅ Excellent error messages
✅ Schema-driven validation
✅ Comment preservation
✅ Prevents common YAML issues
✅ No duplicate keys allowed

### Cons
❌ Python-only
❌ Small ecosystem
❌ Removes some YAML features
❌ Less flexible than full YAML

### Code Example
```yaml
# Nancy Bubble Gum Configuration

app:
  name: nancy-bubble-gum
  version: 1.0.0

  database:
    type: sqlite
    path: ./data/nancy.db

  features:
    - intelligence
    - context-tracking
    - llm-integration

  defaults:
    timeout: 30
    retry: 3

  services:
    api:
      port: 8080
      timeout: 30
      retry: 3

    worker:
      concurrency: 4
      timeout: 30
      retry: 3

metadata:
  created: 2026-01-24T10:30:00Z
```

**Schema Definition (Python)**:
```python
from strictyaml import Map, Str, Int, Seq, Optional

schema = Map({
    "app": Map({
        "name": Str(),
        "version": Str(),
        "database": Map({
            "type": Str(),
            "path": Str(),
        }),
        "features": Seq(Str()),
        "defaults": Map({
            "timeout": Int(),
            "retry": Int(),
        }),
        "services": Map({
            "api": Map({
                "port": Int(),
                "timeout": Int(),
                "retry": Int(),
            }),
            "worker": Map({
                "concurrency": Int(),
                "timeout": Int(),
                "retry": Int(),
            }),
        }),
    }),
    "metadata": Map({
        "created": Str(),
    }),
})
```

### Real-World Adoption
- **HitchStory**: Type-safe YAML integration tests
- Python projects requiring secure YAML parsing
- Available on conda-forge for scientific computing

### References
- [StrictYAML GitHub](https://github.com/crdoconnor/strictyaml)
- [StrictYAML Documentation](https://hitchdev.com/strictyaml/)
- [StrictYAML PyPI](https://pypi.org/project/strictyaml/0.2/)

---

## 10. EDN (Extensible Data Notation)

### Primary Use Cases
- **Clojure Applications**: Native data format
- **Full-Stack Clojure**: ClojureScript + Clojure communication
- **Datomic**: Database data transfer
- **Configuration Files**: Clojure-based systems
- **Data Serialization**: Rich data structures

### Features
- ✅ Comments (semicolon `;`)
- ✅ Rich built-in types (sets, keywords, symbols)
- ✅ Extensibility via tagged literals
- ✅ JSON-like foundation (maps, vectors, strings)
- ✅ Characters, lists, booleans, nil
- ✅ Dates and UUIDs
- ⚠️ Code restrictions (data only, no executable code)

### Human Readability
**Rating**: ⭐⭐⭐ (3/5)

Readable for Clojure developers. Keywords and symbols may be unfamiliar to others.

### Tooling & Ecosystem
**Maturity**: ⭐⭐ (2/5) - Clojure-specific

**Parsers**:
- **Clojure/ClojureScript**: Built-in `clojure.edn`
- **C**: `edn.c` (SIMD acceleration)
- **Limited cross-language support**

**Schema Support**: Tagged literals for extensions

**Validation**: Application-level validation

### Composability
**Multiple Files**: Manual composition required
**Merge Patterns**: Application-level merging
**Override Patterns**: Custom implementation

### Pros
✅ Rich type system
✅ Extensible via tagged literals
✅ Perfect for Clojure ecosystem
✅ Streaming support
✅ Interactive applications
✅ Cross-platform Clojure/ClojureScript

### Cons
❌ Clojure-specific
❌ Limited cross-language parsers
❌ Unfamiliar syntax outside Clojure
❌ Practical challenges noted in 2024
❌ Transit recommended for production

### Code Example
```edn
;; Nancy Bubble Gum Configuration

{:app {:name "nancy-bubble-gum"
       :version "1.0.0"

       :database {:type :sqlite
                  :path "./data/nancy.db"}

       :features [:intelligence
                  :context-tracking
                  :llm-integration]

       :defaults {:timeout 30
                  :retry 3}

       :services {:api {:port 8080
                        :timeout 30
                        :retry 3}

                  :worker {:concurrency 4
                           :timeout 30
                           :retry 3}}}

 ;; Tagged literal for instant
 :metadata {:created #inst "2026-01-24T10:30:00.000Z"}}

;; Sets (unique collections)
#{:feature-a :feature-b :feature-c}

;; Custom tagged literal
#app/config {:mode :production}
```

### Real-World Adoption
- **Clojure Applications**: Native format
- **Datomic**: Database data transfer
- **ClojureScript**: Full-stack Clojure projects

### References
- [EDN Format GitHub](https://github.com/edn-format/edn)
- [EDN Official Site](https://edn-format.dev/)
- [EDN ClojureDocs](https://clojuredocs.org/clojure.edn)
- [EDN Pitfalls - Nitor](https://nitor.com/en/articles/pitfalls-and-bumps-clojures-extensible-data-notation-edn)

---

## LLM/AI Tool Configuration Preferences

### Key Research Findings (2024-2025)

#### Format Accuracy Performance
Based on empirical testing with LLMs:

1. **YAML**: Highest accuracy - recommended as default for LLM applications
   - Outperformed XML by 17.7 percentage points with GPT-5 Nano
   - Best for structured data that LLMs need to understand

2. **JSON**: Strong performance but more verbose
   - Universal compatibility
   - More tokens required than alternatives

3. **Markdown**: Cost-effective alternative
   - Lower token usage
   - Good for narrative/documentation

4. **XML**: Lowest accuracy
   - Required 80% more tokens than Markdown
   - Nearly twice the inference cost

#### Common LLM Tool Configurations

**LocalAI**: Uses YAML for model configurations
```yaml
model: gpt-4
temperature: 0.7
top_p: 0.9
max_tokens: 2048
context_size: 4096
```

**LiteLLM**: Uses `config.yaml` for model settings
```yaml
model_list:
  - model_name: gpt-4
    litellm_params:
      model: openai/gpt-4
      api_key: os.environ/OPENAI_API_KEY
      temperature: 0.7
```

**ModelYAML**: Open standard for cross-platform AI models
- GitHub: `modelyaml/modelyaml`
- Defines composable AI models in YAML

#### Format Selection Guidance

**For API Responses**: JSON (compatibility)
**For Configuration**: YAML or TOML (readability + structure)
**For UI Components**: HTML, React, Markdown
**For Technical Docs**: LaTeX, Markdown

**Cost vs Accuracy Trade-off**:
- Accuracy priority: **YAML**
- Cost priority: **Markdown** or **TSV**
- Balance: **TOML** or **JSON5**

### References
- [Spring AI Tool Response Formats](https://spring.io/blog/2025/11/25/spring-ai-tool-response-formats/)
- [LLM Output Formats: JSON vs TSV Cost](https://david-gilbertson.medium.com/llm-output-formats-why-json-costs-more-than-tsv-ebaf590bd541)
- [Which Nested Data Format Do LLMs Understand Best?](https://www.improvingagents.com/blog/best-nested-data-format/)
- [LocalAI Model Configuration](https://localai.io/advanced/model-configuration/)
- [LiteLLM Proxy Configs](https://docs.litellm.ai/docs/proxy/configs)

---

## Configuration Composability Patterns

### Multi-File Management Strategies

#### 1. Include/Import Pattern
**Used by**: YAML, HOCON, Grafana Alloy

**Approach**: Explicit file inclusion in configuration
```yaml
# main.yaml
include:
  - database.yaml
  - services.yaml
  - features.yaml
```

**Pros**: Clear dependencies, modular organization
**Cons**: Requires format support

#### 2. Merge/Override Pattern
**Used by**: Docker Compose, YAML, HOCON

**Approach**: Base configuration + environment-specific overrides
```bash
# Docker Compose example
docker-compose -f compose.yml -f compose.override.yml up
```

**Base file**: `compose.yml` (common config)
**Override file**: `compose.override.yml` (environment-specific)

**Pros**: DRY principle, environment flexibility
**Cons**: Merge semantics can be complex

#### 3. Extends Pattern
**Used by**: Docker Compose, ESLint

**Approach**: Share common configurations via named references
```yaml
# common.yaml
x-defaults: &defaults
  timeout: 30
  retry: 3

services:
  api:
    <<: *defaults
    port: 8080
```

**Pros**: Configuration reuse, reduced duplication
**Cons**: Can become hard to trace

#### 4. Glob Import Pattern
**Used by**: ESLint, TypeScript, Webpack

**Approach**: Automatically import matching files
```javascript
// eslint.config.js
import configs from './configs/**/*.js';
```

**Pros**: Automatic discovery, scalable
**Cons**: Implicit ordering, potential conflicts

#### 5. Module/Plugin Pattern
**Used by**: HCL (Terraform), Apache Commons

**Approach**: Hierarchical module composition
```hcl
module "database" {
  source = "./modules/database"
  config = var.db_config
}
```

**Pros**: Encapsulation, reusability, versioning
**Cons**: More complex setup

#### 6. Layer/Priority Pattern
**Used by**: Apache Commons CombinedConfiguration

**Approach**: Multiple configuration sources with priority
```
Priority (highest to lowest):
1. Command-line arguments
2. Environment variables
3. User config file
4. System config file
5. Defaults
```

**Pros**: Flexible overrides, standard precedence
**Cons**: Debugging can be challenging

### Best Practices

1. **Explicit over Implicit**: Make dependencies clear
2. **Environment Separation**: Base + environment-specific files
3. **Validation**: Schema validation for composed config
4. **Documentation**: Document composition strategy
5. **Testing**: Test merged configurations
6. **Version Control**: Track all config files

### References
- [Pkl Multiple Files Discussion](https://github.com/apple/pkl/discussions/421)
- [Docker Compose Multiple Files](https://medium.com/@alireza-aliabadi/multiple-compose-files-management-patterns-fd53a643a23f)
- [Grafana Alloy Import.file](https://grafana.com/docs/alloy/latest/reference/config-blocks/import.file/)
- [ESLint Configuration Files](https://eslint.org/docs/latest/use/configure/configuration-files)

---

## Recommendations for Nancy's Needs

### Context: Nancy Bubble Gum Intelligence System

Nancy requires configuration storage for:
- Intelligence context tracking
- LLM integration settings
- Developer tool workflows
- Composable configuration
- Human-readable, editable configs
- Version control friendly
- Schema validation

### Tier 1 Recommendations: Primary Candidates

#### 1. TOML + SQLite Hybrid
**Use TOML for**: Human-editable configuration
**Use SQLite for**: Runtime state, context history, queryable data

**Rationale**:
- TOML's clarity perfect for hand-edited configs
- SQLite's query power ideal for context retrieval
- Complementary strengths
- Both have excellent tooling

**Example Structure**:
```
nancy/
├── config.toml          # Human-editable settings
├── data/
│   └── context.db       # SQLite for runtime state
```

#### 2. YAML (with StrictYAML validation)
**Primary format with safety guardrails**

**Rationale**:
- Best LLM accuracy (proven in research)
- Universal developer familiarity
- Rich composability features
- StrictYAML adds type safety
- Excellent for complex nested config

**Mitigation**: Use StrictYAML (Python) or schema validation to prevent YAML gotchas

#### 3. JSON5
**Modern, human-friendly JSON**

**Rationale**:
- Familiar to most developers
- Comments + trailing commas = low friction
- JSON Schema validation available
- Lower complexity than YAML
- Good LLM compatibility

### Tier 2 Recommendations: Specialized Use Cases

#### 4. TOML Solo
**If configurations are relatively flat**

**Rationale**:
- Maximum clarity
- Explicit typing
- Growing ecosystem
- Modern tool standard

**Limitation**: Verbose for deep nesting

#### 5. HCL
**If infrastructure-as-code patterns apply**

**Rationale**:
- Strong module system
- Interpolation and functions
- Proven at scale

**Limitation**: Overkill for simple configs

### NOT Recommended for Nancy

❌ **RON**: Too Rust-specific, limited cross-language
❌ **EDN**: Clojure ecosystem lock-in
❌ **HOCON**: JVM/.NET focused, limited broader support
❌ **HJSON**: Smaller ecosystem than JSON5

---

## Final Comparison Matrix for Nancy

| Criteria | TOML+SQLite | YAML | JSON5 | TOML | HCL |
|----------|-------------|------|-------|------|-----|
| **Human Editable** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **LLM Friendly** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Composability** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Type Safety** | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Tooling** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Query Power** | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ | ⭐ | ⭐⭐ |
| **Version Control** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Error Messages** | ⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **Learning Curve** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Ecosystem** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

**Overall Winner**: **TOML + SQLite Hybrid** (Best of both worlds)
**Runner-up**: **YAML** (with validation) for pure config files

---

## Implementation Guidance

### Recommended Approach for Nancy

**Phase 1: Start Simple**
- Use **TOML** for initial configuration
- Clear, explicit, easy to validate
- Low barrier to entry

**Phase 2: Add Structured Storage**
- Introduce **SQLite** for:
  - Context history
  - Intelligence tracking
  - Queryable metadata
  - Performance-critical data

**Phase 3: Composability**
- Implement environment-based overrides
- Use merge patterns for flexibility
- Schema validation for safety

### Example Nancy Structure

```
nancy-bubble-gum/
├── config/
│   ├── nancy.toml              # Main configuration
│   ├── environments/
│   │   ├── development.toml
│   │   ├── staging.toml
│   │   └── production.toml
│   └── schemas/
│       └── config.schema.json
├── data/
│   ├── context.db              # SQLite context storage
│   └── intelligence.db         # SQLite intelligence tracking
└── .nancy/
    └── local.toml              # Local overrides (gitignored)
```

### Configuration Loading Priority
```
1. Environment variables (CLI overrides)
2. .nancy/local.toml (developer-specific)
3. config/environments/{env}.toml (environment)
4. config/nancy.toml (base)
```

### Validation Strategy
- JSON Schema for TOML validation
- SQLite schema constraints
- Application-level validation layer

---

## Conclusion

The research clearly indicates that **no single format is perfect** for all use cases. The optimal approach for Nancy combines:

1. **TOML** for human-editable configuration (clarity, safety)
2. **SQLite** for structured, queryable data (power, performance)
3. **JSON Schema** for validation (safety, documentation)

This hybrid approach leverages the strengths of each format while mitigating weaknesses. It provides:
- Human readability and editability
- Type safety and validation
- Query power for complex retrieval
- Excellent tooling and ecosystem support
- LLM-friendly formats
- Composability and flexibility

For pure configuration file needs, **YAML with validation** remains a strong alternative given its proven LLM compatibility and universal adoption, despite its complexity concerns.

---

**Research compiled**: January 24, 2026
**Next steps**: Prototype TOML+SQLite hybrid for Nancy bubble gum intelligence system
