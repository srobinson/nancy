# Separation of Concerns: Data vs Logic, Content vs Presentation

## Executive Summary

This research explores modern approaches to separation of concerns, specifically the mental models that help teams decide "what goes where" when designing systems. The goal is to inform the nancy-bubble-gum architecture: **what goes in beads (YAML data) vs markdown templates (instructions)**.

Key insight: The best separations aren't technical boundaries—they're **cognitive boundaries** that reduce mental load and make the system's intent obvious at a glance.

---

## 1. MVC/MVVM Separation Patterns

### Core Principles

**MVC (Model-View-Controller):**
- **Model**: Data and business logic
- **View**: Presentation layer and UI
- **Controller**: Mediates interaction between Model and View

**MVVM (Model-View-ViewModel):**
- **Model**: Data layer
- **View**: UI layer (completely separated from logic)
- **ViewModel**: Business logic and data manipulation (mediator)

The primary objective is **separation of concerns to facilitate testability**. MVVM enhances this with better separation—the ViewModel contains business logic completely separate from the UI, making unit testing straightforward.

### Modern Evolution (2024-2026)

**Pattern Selection Guide:**
- **MVC**: Ideal for traditional applications with straightforward requirements
- **MVP**: Best for complex development demanding high testability
- **MVVM**: Suitable where rich data binding is needed—responsive, dynamic UIs with minimal boilerplate

**Modern Enhancements:**
- **MVVM-C**: Adds Coordinator to separate screen transitions/navigation from View layer
- **VIPER**: Further isolates business logic, solving "fat ViewModels" problem

### Clarity Principle

**Testing as a clarity signal**: If your ViewModel (or data layer) can be tested without touching the UI, you've achieved proper separation. The test suite becomes documentation of where concerns live.

**Mental Model**: "Can I test this without mocking the presentation layer?" If yes, separation is clean.

---

## 2. Jamstack Content Modeling

### Structured Content Philosophy

In Jamstack, **content is data**—structured, queryable, reusable across channels. Platforms like Contentful and Sanity exemplify this separation:

**Contentful Approach:**
- User-friendly schema builder
- Define content types (Blog Post, Author, Product)
- Assign fields, set validation rules
- Support multilingual content and role-based access
- **Clarity**: The schema IS the contract

**Sanity Approach:**
- Schema-as-code modeling
- Content Lake stores everything as structured data
- Real-time collaboration on content
- **Clarity**: Content is queryable data, not embedded markup

### Content vs Presentation Separation

**Content (Data Layer):**
- Structured fields (title, author, date, body)
- Validation rules
- Relationships between entities
- Localization/translation data

**Presentation (Template Layer):**
- How content renders in different contexts
- Layout decisions
- Styling and theming
- Device-specific adaptations

**Key Insight**: Global brands use this to run multi-language websites efficiently—content is defined once, presentation adapts per locale/channel.

### Clarity Principle

**The Schema Test**: If you can't define a clear schema for it, it might not be data—it might be logic.

**Mental Model**: "Could a non-developer edit this in a form UI?" If yes, it's data. If it requires understanding control flow, it's logic.

---

## 3. Infrastructure as Code (Terraform/HCL)

### Separation Patterns

**Module-Based Separation:**
- Modules wrap infrastructure pieces into reusable components (VPCs, S3, EKS, databases)
- Good module design: minimal inputs, no exposure of internal details
- Each environment calls modules with environment-specific inputs

**Root Module Separation:**
- Separate by account or layer
- Ensures changes in one area don't impact unrelated resources
- Isolates state, reduces blast radius
- Makes cross-account dependencies predictable

**State File Separation:**
- Split when you need isolation for security, team autonomy, or performance
- Common splits: networking, identity, compute
- Environment isolation: dev, staging, prod

### HCL Language Design

**Declarative Nature**: You declare desired state, not the steps to achieve it. HCL syntax is designed for human readability while supporting declarative logic for complex applications.

**Project Structure Pattern:**
```
├── main.tf           # Core resource definitions
├── variables.tf      # Input parameters (data)
├── outputs.tf        # Exposed values (data)
├── terraform.tfvars  # Environment-specific values (data)
├── terraform.lock.hcl # Version locking (metadata)
└── modules/          # Reusable components (logic)
```

### Clarity Principle

**File naming as intent**: The standard file names (`main.tf`, `variables.tf`, `outputs.tf`) make it immediately clear where to look for different concerns.

**Mental Model**: "Is this a decision that changes per environment?" If yes, it goes in `terraform.tfvars` (data). "Is this infrastructure logic?" It goes in `main.tf` or modules (logic).

---

## 4. React Container/Presentational Pattern

### The Classic Separation

**Container Components:**
- Manage and manipulate state
- Handle complex logic (Redux, Context API, local state)
- Encapsulate business logic
- Know about data sources
- **Role**: "What data is shown"

**Presentational Components:**
- Stateless, pure functions
- No knowledge of data origin
- Focus solely on rendering received data
- Reusable across contexts
- **Role**: "How data is shown"

### Benefits

1. **Better separation of concerns**: Understand app and UI separately
2. **Better reusability**: Presentational components work with any data shape
3. **Easy testing**: Pure functions are predictable—no mocking data stores

### Modern Approach with Hooks

Hooks (since ~2019) provide a more modern alternative. Custom Hooks extract logic from components while keeping them clean:

```javascript
// Logic layer (custom hook)
function useUserData(userId) {
  const [user, setUser] = useState(null);
  // ... fetch and state logic
  return user;
}

// Presentation layer (component)
function UserProfile({ userId }) {
  const user = useUserData(userId);
  return <div>{user.name}</div>;
}
```

**Evolution**: The pattern remains useful for large apps, but Hooks save the "extra layer" previously needed to wrap presentational in container components.

### Clarity Principle

**The Pure Function Test**: If you can't write the component as a pure function of its props, it's doing too much.

**Mental Model**: "Does this component care WHERE the data comes from?" If yes, it's a container. If no, it's presentational.

---

## 5. Configuration Languages: HCL, Dhall, CUE

### Why They Exist

**Problem**: General-purpose programming languages (Python, JavaScript) are too powerful for configuration—they allow complexity that makes configs hard to validate, version, and reason about.

**Solution**: Purpose-built declarative languages that constrain what's possible, making configs safer and more maintainable.

### Language Characteristics

**HCL (HashiCorp Configuration Language):**
- **Style**: Declarative with human readability focus
- **Use case**: Remove boilerplate while staying readable
- **Constraint**: Declares desired state, not steps
- **Recommended when**: Already using Terraform, need readable configs

**CUE:**
- **Style**: Constraint-based, aspect-oriented
- **Use case**: Type system for stability at scale
- **Constraint**: Specify fine-grained constraints on valid values
- **Recommended when**: Need strong typing for large config systems

**Dhall:**
- **Style**: Functional programming oriented
- **Use case**: Type-safe configs with import capabilities
- **Constraint**: Typed like Haskell but for configuration
- **Recommended when**: Familiar with functional languages, need typing

### Declarative vs Imperative

**Declarative** (HCL, CUE, Dhall):
- Tell the system WHAT you want (desired end state)
- System figures out HOW to achieve it
- Results in leaner, safer code
- Better for reasoning about correctness

**Imperative** (Pulumi with Python/JS):
- Tell the system HOW to do it (step-by-step)
- More powerful but more dangerous
- Harder to validate and reason about
- Can lead to inconsistent states

### Clarity Principle

**Language constraints as guardrails**: The inability to write complex logic in config languages isn't a limitation—it's the feature. It prevents the "soft-code" problem.

**Mental Model**: "Could this configuration change produce an invalid state?" Declarative languages make invalid states unrepresentable.

---

## Separation of Concerns: Core Clarity Principles

### The Meta-Principles

**1. Cognitive Boundary Principle**
> "A software system must be decomposed into parts that overlap in functionality as little as possible."

Separation isn't about files or folders—it's about reducing **cognitive load**. When you open a file, you should immediately know its concern.

**2. Focus Principle**
> "Separating concerns allows you to focus attention on a single aspect and analyze it in isolation."

Being able to reason about one concern without loading the entire system into your head is the goal.

**3. Clarity Promotes Comprehension**
> "Separation reduces cognitive overload and improves comprehension."

Clear organization means developers understand the codebase faster. Each module should have a concise, clear API with logically scoped methods.

### Practical "What Goes Where" Tests

**The Form UI Test** (Content vs Logic)
- Can a non-developer edit this in a form?
- **Yes** → It's content/data (YAML/JSON)
- **No** → It's logic (code/templates)

**The Pure Function Test** (Data vs Presentation)
- Can this be a pure function of inputs?
- **Yes** → It's presentation
- **No** → It's business logic

**The Environment Test** (Config vs Code)
- Does this change per environment (dev/prod)?
- **Yes** → It's configuration
- **No** → It's code

**The Testing Test** (Logic vs Data)
- Can I test this without mocking the data layer?
- **Yes** → Separation is clean
- **No** → Concerns are mixed

**The Schema Test** (Structured Data vs Free-Form)
- Can I define a clear schema for this?
- **Yes** → It's structured data
- **No** → It might be instructions/logic

---

## File Organization Strategies

### Separation Through Structure

**Key Principle**: File structures communicate function and purpose through hierarchy, using consistent, chronological, and descriptive names.

### Organizational Approaches

**1. Feature-Based Structure**
- Group by features/functionality (not technical layers)
- Promotes modularity and scalability
- Each feature is self-contained
- **Example**: `/features/user-profile/`, `/features/checkout/`

**2. Layer-Based Structure**
- Separate by technical concern (MVC pattern)
- Controllers, models, routes in separate directories
- **Example**: `/controllers/`, `/models/`, `/views/`

**3. Frontend/Backend Separation**
- Clear delineation promotes modularity
- Easier to scale each part independently
- **Example**: `/frontend/`, `/backend/`

### Best Practices

**Consistency**
- Follow your scheme rigorously
- Inconsistencies lead to confusion
- Success = repeatability for revisiting/revising projects

**Scalability**
- Design for growth from day one
- Use hierarchical structures
- Employ namespaces
- Feature-based organization scales better than layer-based

**Documentation**
- Document your organization scheme
- Makes it easier for collaborators
- Helps you understand it after time away

### Standard File Naming

Frameworks often establish conventions that make intent obvious:

**Terraform:**
- `main.tf` → Core logic
- `variables.tf` → Input data
- `outputs.tf` → Output data
- `terraform.tfvars` → Environment values

**React/Next.js:**
- `pages/` → Routes (structure)
- `components/` → Reusable UI (presentation)
- `lib/` → Business logic
- `data/` → Static content

**Mental Model**: If everyone knows where to look, the structure is working.

---

## When Boundaries Blur (And Why)

### The "Soft-Code" Problem

**Definition**: Soft-code is the middle category between pure code and pure data—configurations that can be modified by both engineers and business users.

**Challenges:**
1. **Versioning conflicts**: IT releases overwrite business config changes
2. **Performance**: Soft-code is slower—must be retrieved, converted to code, then to machine instructions
3. **Maintenance burden**: Configuration becomes another API to maintain
4. **Complexity**: Adds bulk to codebase

### Data-Driven Programming Tension

**Philosophy**: Distinguish code from data structures clearly, design both so logic changes can be made by editing data rather than code.

**Trade-off**: The data actually defines control flow—you're writing as little fixed code as possible. This can blur the line between "what" (data) and "how" (code).

**Warning**: Configuration is just another API. It adds complexity. Don't over-abstract into config what should be code.

### When Blurring is Intentional

**1. DSLs (Domain-Specific Languages)**
- Purpose: Bridge gap between domain experts and developers
- Example: SQL is both declarative (what data) and has logic (joins, subqueries)
- Acceptable because it constrains the domain

**2. Template Languages**
- Purpose: Mix presentation with minimal logic
- Example: Jinja, ERB, Handlebars allow conditionals/loops in templates
- Acceptable for display logic only (hide/show, iterate)

**3. Low-Code Platforms**
- Purpose: Enable non-developers to build applications
- Blurs boundary intentionally for accessibility
- Trade-off: Less flexible, harder to version control

### Red Flags (Bad Blurring)

**Configuration that requires programming knowledge to modify**
- Defeats the purpose of separating config from code

**Business logic in presentation layer**
- Makes testing impossible, violates separation

**Data that can't be validated independently**
- Suggests it's not really data, it's code in disguise

**Templates that contain complex control flow**
- Should be moved to logic layer

### Mental Model for the Blur

**Ask**: "Who is the primary editor of this concern?"
- **Developers only** → It's code
- **Non-developers only** → It's data/content
- **Both** → You're in the blur zone—proceed with caution

**Ask**: "Can this be validated without executing it?"
- **Yes** → It's data (schema validation)
- **No** → It's logic (needs runtime)

---

## Examples of Good vs Bad Separation

### Example 1: Web Content

**GOOD Separation:**
```yaml
# content/posts/welcome.yaml (Data)
title: "Welcome to Our Blog"
author: "Jane Doe"
date: 2026-01-24
tags: ["announcement", "welcome"]
body: |
  We're excited to launch our new blog...
```

```markdown
<!-- templates/post.md (Presentation) -->
# {{ title }}

By **{{ author }}** on {{ date | format_date }}

{{ body }}

Tags: {{ tags | join(', ') }}
```

**Why it's good:**
- Content editor can modify posts without touching templates
- Designer can change layout without touching content
- Schema validation ensures content structure

**BAD Separation:**
```markdown
<!-- posts/welcome.md (Mixed) -->
# Welcome to Our Blog

By **Jane Doe** on {{ get_current_date() | format_special }}

{{ fetch_latest_comments() }}

We're excited to launch...
```

**Why it's bad:**
- Mixing content with function calls
- Can't validate content independently
- Content editor must understand template syntax
- Can't reuse content in different contexts

---

### Example 2: Infrastructure Configuration

**GOOD Separation:**
```hcl
# modules/database/main.tf (Logic)
resource "aws_db_instance" "main" {
  allocated_storage    = var.storage_gb
  engine               = "postgres"
  engine_version       = var.postgres_version
  instance_class       = var.instance_class
  db_name              = var.database_name
  username             = var.username
  password             = var.password
}
```

```hcl
# environments/prod/terraform.tfvars (Data)
storage_gb       = 100
postgres_version = "14.7"
instance_class   = "db.t3.large"
database_name    = "production_db"
```

**Why it's good:**
- Infrastructure logic is reusable across environments
- Environment-specific values are isolated
- Can validate values against variable constraints
- Clear what changes between environments

**BAD Separation:**
```hcl
# environments/prod/main.tf (Mixed)
resource "aws_db_instance" "prod" {
  allocated_storage  = 100
  engine             = "postgres"
  engine_version     = "14.7"
  instance_class     = "db.t3.large"

  # Copy-pasted logic that should be a module
  backup_retention_period = var.enable_backups ? 7 : 0
  backup_window          = var.enable_backups ? "03:00-04:00" : null

  tags = {
    # Mixing data with logic
    Environment = terraform.workspace
    ManagedBy   = "terraform"
    CostCenter  = lookup(var.cost_centers, terraform.workspace, "unknown")
  }
}
```

**Why it's bad:**
- Logic duplicated per environment (not DRY)
- Can't reuse infrastructure pattern
- Hard to ensure consistency across environments
- Mixing conditional logic with configuration

---

### Example 3: React Components

**GOOD Separation:**
```javascript
// components/UserCard.jsx (Presentational)
export function UserCard({ user, onEdit }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={onEdit}>Edit</button>
    </div>
  );
}
```

```javascript
// containers/UserCardContainer.jsx (Container/Logic)
export function UserCardContainer({ userId }) {
  const user = useUserData(userId);
  const [isEditing, setIsEditing] = useState(false);

  const handleEdit = () => {
    setIsEditing(true);
    trackEvent('user_edit_started', { userId });
  };

  if (!user) return <LoadingSpinner />;

  return <UserCard user={user} onEdit={handleEdit} />;
}
```

**Why it's good:**
- UserCard is pure, testable without mocking
- Container handles all side effects
- UserCard is reusable in different contexts
- Clear boundary: data fetching vs rendering

**BAD Separation:**
```javascript
// components/UserCard.jsx (Mixed)
export function UserCard({ userId }) {
  const [user, setUser] = useState(null);
  const [isEditing, setIsEditing] = useState(false);

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);

  const handleEdit = () => {
    setIsEditing(true);
    trackEvent('user_edit_started', { userId });
    // Complex business logic mixed with UI
    if (user.role === 'admin') {
      // Show different edit UI
    }
  };

  return (
    <div className="user-card">
      {user ? (
        <>
          <img src={user.avatar} alt={user.name} />
          <h2>{user.name}</h2>
          {/* More mixed presentation and logic */}
        </>
      ) : (
        <LoadingSpinner />
      )}
    </div>
  );
}
```

**Why it's bad:**
- Can't test rendering without mocking API
- Can't reuse with different data sources
- Mixing data fetching, business logic, and UI
- Hard to reason about component behavior

---

## Mental Models That Work

### 1. The Layers Model

```
┌─────────────────────────────────────┐
│         PRESENTATION LAYER           │  ← How things look
│  (Templates, Components, Styling)   │
└─────────────────────────────────────┘
              ↕ (consumes)
┌─────────────────────────────────────┐
│           LOGIC LAYER                │  ← How things work
│  (Business rules, Transformations)  │
└─────────────────────────────────────┘
              ↕ (operates on)
┌─────────────────────────────────────┐
│            DATA LAYER                │  ← What things are
│     (Content, Configuration)        │
└─────────────────────────────────────┘
```

**Rule**: Dependencies flow downward only. Presentation depends on logic, logic depends on data. Never reverse.

---

### 2. The "Ask Questions" Model

When you can't decide where something belongs, ask:

1. **The Audience Question**: Who needs to modify this?
   - Developers → Code
   - Content team → Data
   - Designers → Presentation

2. **The Change Frequency Question**: How often does it change?
   - Rarely → Code
   - Per environment → Config
   - Per content update → Data

3. **The Reusability Question**: Will this be used in multiple contexts?
   - Yes, with same behavior → Logic (module/function)
   - Yes, with different data → Presentation (template)
   - No → Might be okay to inline

4. **The Testing Question**: How do you test this?
   - Unit test in isolation → Logic
   - Schema validation → Data
   - Visual regression → Presentation

---

### 3. The File Extension Model

Use file extensions as mental shortcuts:

- `.yaml`, `.json`, `.toml` → Pure data
- `.md`, `.mdx` → Content (maybe with presentation hints)
- `.jsx`, `.vue`, `.svelte` → Presentation components
- `.js`, `.py`, `.go` → Logic
- `.hcl`, `.tf` → Infrastructure as data
- `.css`, `.scss` → Presentation styling

**Principle**: If you're writing complex logic in a `.yaml` file, you're doing it wrong.

---

### 4. The "Who's the Customer?" Model

**For each file/component, ask: Who is the primary consumer?**

- **Humans reading content** → Data/Content files
- **Developers extending behavior** → Logic/Code
- **End users seeing UI** → Presentation layer
- **Systems parsing config** → Configuration/Data

**Corollary**: If a file serves multiple customers with different needs, consider splitting it.

---

## Application to nancy-bubble-gum: Beads vs Templates

### The Core Question

**What belongs in beads (YAML data) vs markdown templates (instructions)?**

### Beads (YAML) - Data Layer

**Should contain:**
- Structured, validated content
- Configuration that varies per context
- Relationships between entities
- Metadata (tags, dates, authors)
- Lists of items with consistent schema

**Mental tests:**
- Can this be validated with a JSON schema? → YAML
- Could a non-developer edit this safely? → YAML
- Does this represent facts about the domain? → YAML
- Is this data that might be queried or filtered? → YAML

**Examples:**
```yaml
# Good: Structured project data
project:
  name: "User Authentication"
  status: "in-progress"
  priority: "high"
  assignees: ["alice", "bob"]
  tags: ["security", "backend"]
  due_date: 2026-02-15

# Good: Configuration
settings:
  max_retries: 3
  timeout_seconds: 30
  enable_logging: true
```

**Anti-examples:**
```yaml
# Bad: Logic in YAML
processing:
  steps:
    - type: "transform"
      function: "capitalize_first_letter"  # This is logic
      apply_if: "user.is_admin"            # This is conditional logic
```

---

### Templates (Markdown) - Instruction Layer

**Should contain:**
- Instructions for LLMs
- Control flow for processing
- Transformation logic
- Display/formatting rules
- Conditional rendering

**Mental tests:**
- Does this describe HOW to process data? → Template
- Does this contain conditional logic? → Template
- Is this instructions for behavior? → Template
- Would changing this alter system behavior? → Template

**Examples:**
```markdown
# Good: Instructions with data injection
Process the project "{{ project.name }}" as follows:

1. Validate all assignees are active users
2. If priority is "high", notify stakeholders
3. Generate status report using this format:
   - Status: {{ project.status }}
   - Due: {{ project.due_date | format_date }}
```

**Anti-examples:**
```markdown
# Bad: Data embedded in template
Process the project "User Authentication" as follows:

Status: in-progress
Priority: high
Assignees: alice, bob

<!-- This data should be in YAML, injected via template -->
```

---

### The Boundary Zone

**Structured instructions** live in an interesting middle ground:

```yaml
# workflow.yaml - Is this data or logic?
workflow:
  steps:
    - name: "Validate inputs"
      action: "validate"
      schema: "user_schema"

    - name: "Transform data"
      action: "transform"
      template: "user_transform"

    - name: "Save result"
      action: "save"
      destination: "database"
```

**Analysis:**
- It's **data** if the interpreter is code (a workflow engine reads this)
- It's **declarative** (what to do, not how)
- It's **validatable** (schema for workflow structure)

**Guideline**: This is acceptable when:
1. You have a well-defined workflow engine
2. Actions are constrained to a known set
3. You can validate the workflow structure
4. The "logic" is declaring steps, not implementing them

**Red flag**: If you're building a programming language in YAML, stop. Use actual code.

---

### Recommended Approach for nancy-bubble-gum

**Beads (YAML):**
```yaml
# beads/reviews/monthly-review.yaml
review:
  type: "monthly"
  period: "2026-01"
  focus_areas:
    - "project_progress"
    - "team_health"
    - "technical_debt"

  projects:
    - id: "auth-system"
      status: "on-track"
      health: "green"
      notes: "All milestones met"

    - id: "data-pipeline"
      status: "at-risk"
      health: "yellow"
      notes: "Performance issues identified"

  metrics:
    velocity: 42
    bug_count: 12
    test_coverage: 87
```

**Templates (Markdown):**
```markdown
# templates/review-prompt.md

You are conducting a {{ review.type }} review for {{ review.period }}.

Focus areas for this review:
{% for area in review.focus_areas %}
- {{ area | humanize }}
{% endfor %}

For each project, analyze:

{% for project in review.projects %}
## {{ project.id | title }}

Current status: **{{ project.status }}**
Health: {{ project.health | status_emoji }}

{{ project.notes }}

{% if project.health == "yellow" or project.health == "red" %}
REQUIRED: Provide specific recommendations to improve this project's health.
{% endif %}

---
{% endfor %}

Summary requirements:
1. Identify patterns across projects
2. Highlight risks requiring immediate attention
3. Suggest process improvements based on metrics:
   - Team velocity: {{ metrics.velocity }}
   - Open bugs: {{ metrics.bug_count }}
   - Test coverage: {{ metrics.test_coverage }}%
```

**Why this works:**
- **Beads** contain all the facts (status, metrics, notes)
- **Template** contains all the instructions (how to analyze, what to focus on)
- Non-developers can update project status in beads
- Developers can refine prompts in templates
- You can validate bead structure independently
- You can version control and test templates separately

---

## Key Takeaways

### 1. Separation is About Cognition, Not Files

The goal isn't "put all data in one place"—it's "reduce the mental load required to understand and modify the system."

### 2. Use the Right Tests

- **Form UI test** → Determines content vs logic
- **Pure function test** → Determines presentation vs business logic
- **Environment test** → Determines config vs code
- **Schema test** → Determines structured data vs instructions

### 3. File Structure Communicates Intent

Standard naming conventions (`variables.tf`, `components/`, `data/`) make it obvious where concerns live. Consistency is more important than perfection.

### 4. Boundaries Will Blur—Have Principles

When they do blur (DSLs, workflows, template logic), have clear principles:
- Is the domain constrained?
- Can it be validated independently?
- Does it make the system more accessible to the right people?

### 5. Declarative > Imperative for Data

Configuration languages exist because general-purpose languages are too powerful for config. Constraints make invalid states unrepresentable.

### 6. Test Separately, Deploy Together

Good separation means you can:
- Test data schemas independently
- Test logic without data
- Test presentation with mock data
- But compose them at runtime

### 7. For nancy-bubble-gum

**Beads (YAML):**
- Facts, metrics, status, relationships
- Things content editors should modify
- Data that gets queried/filtered
- Validatable with schema

**Templates (Markdown):**
- Instructions for LLM behavior
- Control flow and conditionals
- Transformation and formatting rules
- Things developers modify to change behavior

---

## Sources

### MVC/MVVM Patterns
- [Architecture Patterns for Beginners: MVC, MVP, and MVVM](https://dev.to/chiragagg5k/architecture-patterns-for-beginners-mvc-mvp-and-mvvm-2pe7)
- [MVVM & MVC: Separation of Concerns](https://medium.com/@pradeepgpre/mvvm-mvc-7e36f508018c)
- [Software Architecture Patterns: MVC, MVP, MVVM, MVVM-C, and VIPER](https://drraghavendra99.medium.com/software-architecture-patterns-mvc-mvp-mvvm-mvvm-c-and-viper-differ-in-their-approach-to-90af79d57697)
- [Understanding the Differences: MVC vs. MVVM](https://brightmarbles.io/blog/differences-between-mvc-and-mvvm/)
- [A story on Frontend Architectures - MVVM](https://dev.to/purnez/a-story-on-frontend-architectures-mvvm-the-separation-of-concerns-imf)

### Jamstack & Content Modeling
- [10 Best Jamstack CMS Platforms in 2025](https://www.webstacks.com/blog/best-jamstack-cms)
- [Enterprise Jamstack CMS - Sanity](https://www.sanity.io/jamstack-cms)
- [Contentful vs Sanity: Which Headless CMS is Best for You?](https://www.trantorinc.com/blog/contentful-vs-sanity)
- [Understanding Content Modeling in a Headless World](https://www.stackbit.com/blog/content-modeling-headless)
- [A guide to using JAMstack with Contentful](https://www.contentful.com/help/jamstack-for-developers-and-editors/)

### Infrastructure as Code
- [Terraform Infrastructure as Code Guide - Firefly](https://www.firefly.ai/academy/terraform-iac)
- [What is Terraform Configuration Language (HCL)](https://www.geeksforgeeks.org/devops/what-is-terraform-configuration-language-hcl/)
- [Master Terraform HCL: Simplify Infrastructure as Code](https://cyberpanel.net/blog/terraform-hcl)
- [IaC with Terraform: A Practical Guide](https://codefresh.io/learn/infrastructure-as-code/iac-with-terraform-a-practical-guide/)
- [What is Infrastructure as Code with Terraform?](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/infrastructure-as-code)

### React Patterns
- [Container/Presentational Pattern - Patterns.dev](https://www.patterns.dev/react/presentational-container-pattern/)
- [Container-presentational pattern in React](https://tsh.io/blog/container-presentational-pattern-react)
- [Separation of Concerns in React - FreeCodeCamp](https://www.freecodecamp.org/news/separation-of-concerns-react-container-and-presentational-components/)
- [Presentational and Container Components - Dan Abramov](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
- [Understanding the Container Component Pattern with React Hooks](https://blog.openreplay.com/understanding-the-container-component-pattern-with-react-hooks/)

### Configuration Languages
- [Why CUE for Configuration](https://holos.run/blog/why-cue-for-configuration/)
- [The Landscape of Declarative Configuration - KCL](https://www.kcl-lang.io/blog/2022-declarative-config-overview)
- [Can Configuration Languages solve configuration complexity?](https://itnext.io/can-configuration-languages-dsls-solve-configuration-complexity-eee8f124e13a)
- [HashiCorp Configuration Language (HCL): Overview & Tutorial](https://spacelift.io/blog/hcl-hashicorp-configuration-language)

### Separation of Concerns Principles
- [Separation of Concerns - Wikipedia](https://en.wikipedia.org/wiki/Separation_of_concerns)
- [Separation of Concerns (SoC) - GeeksforGeeks](https://www.geeksforgeeks.org/software-engineering/separation-of-concerns-soc/)
- [Separation of Concerns in Software Design - Alexey Naumov](https://nalexn.github.io/separation-of-concerns/)
- [What Is Separation Of Concerns?](https://medium.com/hepsiburadatech/what-is-separation-of-concern-b6715b2e0f75)
- [Separation of Concerns | Effective Software Design](https://effectivesoftwaredesign.com/2012/02/05/separation-of-concerns/)

### Configuration vs Code
- [The boundary between "Data" and "Code" is blurring](https://www.linkedin.com/pulse/boundary-between-data-code-blurring-joris-lochy)
- [Data-Driven Programming](https://homepage.cs.uri.edu/~thenry/resources/unix_art/ch09s01.html)
- [Config Versus Code](https://blog.urth.org/2011/01/06/config-versus-code/)

### File Organization
- [File Structure - Broad Institute](https://mitcommlab.mit.edu/broad/commkit/file-structure/)
- [Project Folder Structure: Best Practices](https://test.charlestonwv.com/news/project-folder-structure-best-practices)
- [A Comprehensive Guide on Project Codebase Organization](https://www.iteratorshq.com/blog/a-comprehensive-guide-on-project-folder-organization/)
- [Organizing Project Folder Structure: Function-Based vs Feature-Based](https://medium.com/@ikonija.bogojevic/organizing-project-folder-structure-function-based-vs-feature-based-168596b6d169)
- [Folder Structure Best Practices](https://compresto.app/blog/folder-structure-best-practices)
