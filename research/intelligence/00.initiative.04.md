# Initiative 04: Discoverability in Developer Tools and Frameworks

**Research Focus**: Modern approaches to making capabilities, schemas, and configurations discoverable in developer tools - both for human browsing and programmatic detection.

**Date**: 2026-01-24

---

## Executive Summary

Discoverability is the fundamental challenge in CLI and developer tooling. The best modern tools solve this through a combination of:

1. **Interactive Discovery**: Menu-driven interfaces that surface capabilities without requiring memorization
2. **Schema Introspection**: Self-documenting APIs and configs that can be queried programmatically
3. **IDE Integration**: Real-time autocomplete and validation through Language Server Protocol
4. **Living Documentation**: Auto-generated, always-synchronized documentation from code/schemas
5. **Progressive Disclosure**: Layered help systems from quick hints to comprehensive docs

---

## 1. CLI Discovery Patterns

### 1.1 The Discoverability Problem

> "The biggest problem with CLI is discoverability... when autocomplete doesn't show available features, users resort to manual documentation lookup rather than discovering features naturally through the interface." - [Hacker News discussion](https://news.ycombinator.com/item?id=23329723)

### 1.2 Help Systems & Documentation

**Layered Help Architecture**:
- `--help` flags for immediate context-specific guidance
- Man pages for comprehensive reference
- Interactive modes for exploration
- Web-based documentation for tutorials and examples

**Best Practices**:
- Show examples alongside descriptions
- Group related commands logically
- Provide both short and long help formats
- Include common usage patterns

### 1.3 Shell Autocomplete & Completion

Modern CLIs provide shell completion for bash, zsh, fish, and PowerShell. This is a critical discoverability feature.

**kubectl Example**:
- Autocomplete for commands, flags, and even resource names
- Dynamic completion based on current cluster state
- Acts as a "learning tool that helps discover new kubectl commands you might not have been aware of"
- Helps avoid constantly referencing cheat sheets ([Komodor](https://komodor.com/learn/kubectl-autocomplete-enabling-and-using-in-bash-zsh-and-powershell/), [Spacelift](https://spacelift.io/blog/kubectl-auto-completion))

**Setup Pattern**:
```bash
# kubectl completion bash > /etc/bash_completion.d/kubectl
source <(kubectl completion bash)
```

Shell completion frameworks:
- [kubectl completion](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_completion/)
- npm/yarn completion
- git completion (built-in)

### 1.4 Interactive Menus & Prompts

**Azure CLI Interactive Mode**:
Makes it easier to learn capabilities through:
- Autocompletion dropdowns
- Auto-cached suggestions
- Runtime documentation
- Inline examples ([Microsoft Learn](https://learn.microsoft.com/en-us/cli/azure/interactive-azure-cli?view=azure-cli-latest))

**Git Interactive Staging** (`git add -i`):
- Menu-driven interface with 8 commands
- Commands: [s]tatus, [u]pdate, [r]evert, [a]dd untracked, [p]atch, [d]iff, [q]uit, [h]elp
- Type '?' to display all available commands
- Patch mode allows selective staging of hunks
- "Particularly useful when multiple changes exist in a single file" ([Git SCM](https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging), [Epic Web Dev](https://www.epicweb.dev/tutorials/git-fundamentals/commands/interactive-git-staging))

### 1.5 Modern Interactive CLI Frameworks (2025)

**[@clack/prompts](https://www.blacksrc.com/blog/elevate-your-cli-tools-with-clack-prompts)**:
- Modern design and developer-friendly API
- Focus on usability and developer experience
- Rich feature set and extensibility
- Published January 2025

**[Inquirer.js](https://www.npmjs.com/package/@inquirer/prompts)** (@inquirer/prompts):
- Recently rewritten from ground up
- Reduced package size, improved performance
- Modern multiselect with search/filter
- Supports both ESM and CommonJS
- Used by major tools (ESLint, Webpack, Yarn)

**[Cliffy](https://cliffy.io/)**:
- Type-safe framework for Deno
- Simple yet powerful interactive prompts
- Type-aware prompt objects

**Benefits**:
> "Making CLIs interactive significantly enhances the user experience and eliminates the hurdle by prompting the user for input, thus improving both usability and accessibility." ([Smashing Magazine](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/))

---

## 2. Schema Introspection

### 2.1 GraphQL Introspection

**The Gold Standard for Schema Discovery**:
> "GraphQL APIs are self-documenting, meaning that you can find out everything you need to know to use an API from the API itself, without needing external documentation and tools like Swagger." - [Hasura](https://hasura.io/learn/graphql/intro-graphql/introspection/)

**How It Works**:
- Special fields: `__schema` and `__type` for introspection queries
- Query the schema at runtime to discover types, fields, queries, mutations
- Powers GraphiQL and GraphQL Playground auto-documentation
- Enables tooling to auto-generate SDKs and type definitions ([GraphQL.org](https://graphql.org/learn/introspection/), [Contentful](https://www.contentful.com/blog/graphql-introspection-queries/))

**Introspection Query Example**:
```graphql
{
  __schema {
    types {
      name
      fields {
        name
        type {
          name
        }
      }
    }
  }
}
```

**Security Note**:
> "Although introspection can be helpful, especially in the dev environment, turning off the introspection in production is recommended." - [Medium](https://medium.com/@osamaavvan/unauthenticated-graphql-introspection-and-api-calls-92f1d9d86bcf)

### 2.2 OpenAPI / Swagger

**Interactive Documentation**:
- Swagger UI provides interactive API docs
- Can be explored and tested directly from browser
- JSON/YAML schema defines all endpoints, parameters, responses
- Auto-generates client SDKs in multiple languages ([APIs You Won't Hate](https://apisyouwonthate.com/blog/top-5-best-api-docs-tools/))

**Developer Experience**:
> "Swagger UI is the best tool for publishing OpenAPI specs with no setup and no headaches." - [Bump.sh](https://bump.sh/blog/top-5-api-docs-tools-in-2025/)

### 2.3 JSON Schema

**Configuration Validation**:
- SchemaStore.org provides JSON schemas for 700+ config files
- IDEs use schemas for autocomplete and validation
- Example: `tsconfig.json`, `.eslintrc.json`, `package.json`
- Prettier config schema: `https://www.schemastore.org/prettierrc.json` ([Prettier Docs](https://prettier.io/docs/configuration))

**Runtime Validation with Type Inference**:

**Zod** (TypeScript-first schema validation):
> "After parsing, config is fully typed according to your schema, allowing TypeScript to provide complete autocomplete and safety throughout the rest of your codebase." - [SuperJSON AI](https://superjson.ai/blog/2025-08-25-json-schema-validation-typescript-zod-guide/)

Benefits:
- Define schema once, get TypeScript types automatically via `z.infer<>`
- Runtime validation + compile-time type safety
- Full IDE autocomplete support
- Tested against TypeScript v5.5+ ([Zod](https://zod.dev/), [GitHub](https://github.com/colinhacks/zod))

---

## 3. Documentation Generation from Code/Config

### 3.1 Living Documentation Systems (2025 Trends)

**Spec-Driven Development**:
> "AI-assisted code generation allows developers to elevate their abstraction and express what a system should do, while intelligent tooling materializes how it is actually done." - [InfoQ](https://www.infoq.com/articles/spec-driven-development/)

Key concepts:
- Living specifications that define system contracts
- Specifications are **executable by design**
- Auto-generate: code, documentation, SDKs, mocks, service infrastructure
- Schema engineering as a first-class architectural discipline

**Google Code Wiki** (2025):
> "Keeps software documentation continuously synchronized with code, generating a structured wiki for each repository that automatically updates after every change. Architecture diagrams, class relationships, and sequence flows are generated on the fly." - [InfoQ](https://www.infoq.com/news/2025/11/google-code-wiki/)

**Swimm**:
> "Allows developers to document code directly within their workflow with 'live' documentation that automatically syncs with code changes, reducing the overhead of manual updates." - [HeroThemes](https://herothemes.com/blog/software-documentation-tools/)

### 3.2 Documentation Tools (2025)

**Static Site Generators**:

**[Docusaurus](https://docusaurus.io/)**:
- React-based from Meta
- Markdown/MDX support
- Versioning and localization built-in
- Go-to choice for open-source projects
- Easy customization

**API Documentation Tools**:

**Redoc**:
- Beautiful "Stripe-like" 2-3 panel layout
- Open source, generates from OpenAPI
- Clean, professional appearance ([Redocly GitHub](https://github.com/Redocly/redoc))

**Stoplight Elements**:
- Great developer experience
- Best-in-class OpenAPI documentation
- Easy migration from ReDoc/Swagger UI
- Handles multiple APIs and Markdown guides ([Stoplight](https://stoplight.io/open-source/elements))

### 3.3 DDD Living Documentation

> "If teams can agree on the schema of architecture.json files (or whatever system is used) and each domain produces that information consistently, the job of the aggregator shouldn't be too difficult." - [Medium](https://medium.com/nick-tune-tech-strategy-blog/enterprise-wide-software-architecture-as-ddd-living-documentation-33f3d8b4ddfc)

Trend: Teams using DrawIO diagrams as part of source code itself - versioned, editable, always in sync.

---

## 4. IDE Integration Patterns

### 4.1 Language Server Protocol (LSP)

**What is LSP**:
> "The Language Server Protocol defines the protocol used between an editor or IDE and a language server that provides language features like auto complete, go to definition, find all references etc." - [Microsoft](https://microsoft.github.io/language-server-protocol/)

**Key Benefits**:
- **For Developers**: Single language server works across multiple IDEs
- **For Tool Vendors**: No need to implement language services for each language
- **For Languages**: Implement once, works everywhere ([Wikipedia](https://en.wikipedia.org/wiki/Language_Server_Protocol))

**Features Provided**:
- Code completion (autocomplete)
- Documentation on hover
- Go to definition
- Find all references
- Error checking (diagnostics)
- Code formatting
- Refactoring support ([VS Code Docs](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide))

**Platform Support**:
- VS Code (native support)
- JetBrains IDEs (IntelliJ, WebStorm, PyCharm, etc.)
- Eclipse
- Vim/Neovim
- Emacs

**Protocol**: JSON-RPC-based, latest version 3.17

### 4.2 Autocomplete & Validation

**TypeScript + JSON Schema**:
- Modern configs use JSON Schema for IDE autocomplete
- ESLint flat config (ESLint 9+) uses JavaScript/TypeScript for full type safety
- Prettier, tsconfig, package.json all have schema support ([typescript-eslint](https://typescript-eslint.io/users/configs/), [Advanced Frontends](https://advancedfrontends.com/eslint-flat-config-typescript-javascript/))

**Schema-Driven Autocomplete Flow**:
1. Config file references JSON schema (via `$schema` property)
2. IDE downloads and caches schema
3. Schema defines available properties, types, enums
4. IDE provides autocomplete, validation, hover docs

---

## 5. Plugin & Extension Discovery

### 5.1 Plugin Marketplaces

**Claude Code Plugin Marketplace**:
- Centralized registry via `.claude-plugin/marketplace.json`
- 40+ plugins with metadata and source locations
- Discovery methods:
  - CLI: `/plugin install {plugin-name}@claude-plugin-directory`
  - UI: `/plugin > Discover` tab
  - Automated scanning: Daily GitHub discovery ([Claude Code Docs](https://code.claude.com/docs/en/discover-plugins), [Claude Marketplaces](https://claudemarketplaces.com/))

**VS Code Marketplace**:
- Centralized web marketplace
- In-editor search and install
- Category browsing
- Rating and review system

### 5.2 Convention-Based Discovery

**OpenCode Marketplace**:
- Zero-config convention-based discovery
- Supports local directories and GitHub repos
- Discovers commands, agents, and skills automatically ([GitHub](https://github.com/nikiforovall/opencode-marketplace))

### 5.3 Community & Ecosystem

Emerging pattern: Automated marketplace discovery
> "Claude Code Marketplaces continuously searches GitHub to find and catalog every available Claude Code plugin marketplace, discovering, validating, and updating marketplace information daily." - [Claude Marketplaces About](https://claudemarketplaces.com/about)

---

## 6. Patterns Summary: Interactive vs Static Discovery

### 6.1 Interactive Discovery

**When to Use**: Initial exploration, learning, configuration setup

**Patterns**:
- Interactive prompts (Inquirer, Clack)
- Menu-driven interfaces (git add -i, Azure CLI)
- Shell autocomplete (kubectl, npm)
- IDE autocomplete (LSP-powered)
- GraphQL/API explorers (GraphiQL, Swagger UI)

**Benefits**:
- Lower cognitive load
- Self-explanatory
- Guides users to success
- Reduces need for external documentation

### 6.2 Static Discovery

**When to Use**: Reference, automation, integration

**Patterns**:
- `--help` flags and man pages
- Schema introspection queries
- OpenAPI/GraphQL schema files
- JSON Schema validation
- Auto-generated documentation

**Benefits**:
- Fast lookup
- Scriptable/automatable
- Consistent format
- Version controlled

### 6.3 Hybrid Approaches (Best Practice)

Modern tools combine both:

1. **Progressive Help**:
   - Quick: `cmd --help`
   - Interactive: `cmd interactive`
   - Comprehensive: Web docs + examples

2. **Schema + Autocomplete**:
   - Define schema once
   - Get validation, autocomplete, docs
   - Works in CLI, IDE, and web

3. **Self-Documenting + Interactive**:
   - GraphQL introspection
   - Swagger UI exploration
   - CLI with --help + autocomplete + interactive mode

---

## 7. How Great Tools Surface Capabilities

### 7.1 kubectl (Kubernetes CLI)

**Multi-Layer Discoverability**:

1. **Shell Completion**:
   - Command autocomplete
   - Flag autocomplete
   - Resource name autocomplete (dynamic from cluster)

2. **Help System**:
   - `kubectl --help` - overview
   - `kubectl get --help` - command-specific
   - `kubectl explain pod.spec` - schema documentation

3. **Interactive Exploration**:
   - `kubectl api-resources` - list all resource types
   - `kubectl api-versions` - list API versions
   - `kubectl explain` - introspect resource schemas

**Developer Experience**:
> "kubectl autocomplete is a learning tool that helps discover new kubectl commands you might not have been aware of... helps avoid having to reference a cheat sheet constantly." - [Komodor](https://komodor.com/learn/kubectl-autocomplete-enabling-and-using-in-bash-zsh-and-powershell/)

### 7.2 npm (Node Package Manager)

**Discovery Mechanisms**:

1. **Interactive Init**:
   - `npm init` prompts for all config options
   - Guides new users through setup

2. **Help System**:
   - `npm help` - main help
   - `npm help install` - command docs
   - `npm help npm` - general usage

3. **Package Discovery**:
   - npmjs.com search
   - `npm search <term>` CLI search
   - Dependency suggestions

### 7.3 git

**Layered Discovery**:

1. **Basic Help**:
   - `git --help` - common commands
   - `git help <command>` - detailed man pages

2. **Interactive Staging**:
   - `git add -i` - interactive menu
   - `git add -p` - interactive patch mode
   - Visual feedback for each hunk

3. **Autocomplete**:
   - Command completion
   - Branch name completion
   - File path completion

**Progressive Disclosure**:
- Beginners: Interactive prompts guide usage
- Intermediate: Autocomplete speeds up known commands
- Advanced: Direct commands for automation

---

## 8. Key Takeaways for Nancy Bubble Gum

### 8.1 Fragment Discovery

**Question**: "What fragments exist?"

**Recommended Patterns**:

1. **CLI Discovery**:
   ```bash
   nancy list fragments              # List all available fragments
   nancy list fragments --filter=<type>   # Filter by type
   nancy describe fragment <name>    # Get fragment details
   nancy fragment --help             # Interactive help
   ```

2. **Interactive Mode**:
   ```bash
   nancy interactive                 # Browse all capabilities
   nancy add                         # Interactive prompt to select fragment
   ```

3. **Shell Completion**:
   ```bash
   nancy add <TAB><TAB>              # Autocomplete fragment names
   nancy configure <fragment> <TAB>  # Autocomplete config keys
   ```

4. **Programmatic**:
   ```bash
   nancy introspect fragments --json # JSON output for tooling
   nancy schema fragments            # Get fragment schemas
   ```

### 8.2 Bead Configuration Discovery

**Question**: "What beads can I configure?"

**Recommended Patterns**:

1. **Schema Introspection**:
   ```bash
   nancy schema bead <bead-name>     # Get bead configuration schema
   nancy schema bead <bead-name> --format=json-schema
   ```

2. **Interactive Configuration**:
   ```bash
   nancy configure bead <name>       # Interactive prompt with validation
   # Uses Inquirer/Clack to show available options
   ```

3. **IDE Integration**:
   - Provide JSON Schema for bead configs
   - Enable autocomplete in editors
   - Real-time validation

4. **Documentation Generation**:
   ```bash
   nancy docs generate               # Auto-generate from schemas
   nancy docs serve                  # Local docs server
   ```

### 8.3 Schema Discovery

**Question**: "What's the schema?"

**Recommended Patterns**:

1. **Built-in Introspection**:
   ```bash
   nancy schema                      # List all schemas
   nancy schema fragments            # Fragment registry schema
   nancy schema bead <name>          # Specific bead schema
   nancy schema --output-format=json # For tooling integration
   ```

2. **GraphQL-Style Query** (if applicable):
   ```bash
   nancy query --schema fragments    # Introspect fragment types
   nancy query --schema beads        # Introspect bead types
   ```

3. **Export Schemas**:
   ```bash
   nancy export-schema --format=json-schema
   nancy export-schema --format=typescript
   nancy export-schema --format=graphql
   ```

### 8.4 Recommended Implementation Stack

**For CLI**:
- **Interactive Prompts**: @clack/prompts or Inquirer.js
- **Shell Completion**: Support bash, zsh, fish
- **Help System**: Layered --help with examples

**For Schema**:
- **Definition**: JSON Schema + TypeScript types
- **Validation**: Zod for runtime + compile-time safety
- **Generation**: Auto-generate from single source of truth

**For IDE Integration**:
- **LSP Server**: Provide language server for nancy configs
- **JSON Schema**: Publish schemas to SchemaStore
- **Autocomplete**: Config file intelligence

**For Documentation**:
- **Living Docs**: Auto-generate from schemas
- **Examples**: Include in --help and docs
- **Interactive**: Swagger/Redoc-style explorer for fragments/beads

---

## 9. References & Sources

### CLI Discovery & Autocomplete
- [Hacker News: CLI Discoverability](https://news.ycombinator.com/item?id=23329723)
- [Azure CLI Interactive Mode](https://learn.microsoft.com/en-us/cli/azure/interactive-azure-cli?view=azure-cli-latest)
- [kubectl Autocomplete Guide - Komodor](https://komodor.com/learn/kubectl-autocomplete-enabling-and-using-in-bash-zsh-and-powershell/)
- [kubectl Autocomplete - Spacelift](https://spacelift.io/blog/kubectl-auto-completion)
- [kubectl completion - Kubernetes Docs](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_completion/)

### Interactive CLI Frameworks
- [@clack/prompts](https://www.blacksrc.com/blog/elevate-your-cli-tools-with-clack-prompts)
- [Inquirer.js](https://www.npmjs.com/package/@inquirer/prompts)
- [Cliffy](https://cliffy.io/)
- [Smashing Magazine: Interactive CLI with Node.js](https://www.smashingmagazine.com/2017/03/interactive-command-line-application-node-js/)

### Git Interactive Features
- [Git Interactive Staging - Git SCM](https://git-scm.com/book/en/v2/Git-Tools-Interactive-Staging)
- [Interactive Git Staging - Epic Web Dev](https://www.epicweb.dev/tutorials/git-fundamentals/commands/interactive-git-staging)

### Schema Introspection
- [GraphQL Introspection](https://graphql.org/learn/introspection/)
- [GraphQL Introspection - Hasura](https://hasura.io/learn/graphql/intro-graphql/introspection/)
- [GraphQL Introspection Queries - Contentful](https://www.contentful.com/blog/graphql-introspection-queries/)

### Schema Validation & Type Safety
- [Zod](https://zod.dev/)
- [Zod GitHub](https://github.com/colinhacks/zod)
- [TypeScript JSON Schema Validation with Zod](https://superjson.ai/blog/2025-08-25-json-schema-validation-typescript-zod-guide/)
- [Prettier Configuration](https://prettier.io/docs/configuration)

### Language Server Protocol
- [Language Server Protocol](https://microsoft.github.io/language-server-protocol/)
- [LSP Wikipedia](https://en.wikipedia.org/wiki/Language_Server_Protocol)
- [VS Code Language Server Extension Guide](https://code.visualstudio.com/api/language-extensions/language-server-extension-guide)

### Living Documentation (2025)
- [Spec-Driven Development - InfoQ](https://www.infoq.com/articles/spec-driven-development/)
- [Google Code Wiki - InfoQ](https://www.infoq.com/news/2025/11/google-code-wiki/)
- [DDD Living Documentation](https://medium.com/nick-tune-tech-strategy-blog/enterprise-wide-software-architecture-as-ddd-living-documentation-33f3d8b4ddfc)
- [Living Documentation - Medium](https://medium.com/@rasmus-haapaniemi/living-documentation-how-to-let-your-documentation-grow-naturally-and-be-self-sustainable-24feac57a041)
- [Software Documentation Tools 2025](https://herothemes.com/blog/software-documentation-tools/)

### API Documentation Tools
- [Top 5 Best API Docs Tools 2025 - APIs You Won't Hate](https://apisyouwonthate.com/blog/top-5-best-api-docs-tools/)
- [Top 5 API Docs Tools - Bump.sh](https://bump.sh/blog/top-5-api-docs-tools-in-2025/)
- [Redoc GitHub](https://github.com/Redocly/redoc)
- [Stoplight Elements](https://stoplight.io/open-source/elements)

### TypeScript & ESLint Configuration
- [typescript-eslint Shared Configs](https://typescript-eslint.io/users/configs/)
- [Modern Linting 2025: ESLint Flat Config](https://advancedfrontends.com/eslint-flat-config-typescript-javascript/)

### Plugin Discovery
- [Claude Code Plugin Marketplace](https://code.claude.com/docs/en/discover-plugins)
- [Claude Marketplaces](https://claudemarketplaces.com/)
- [OpenCode Marketplace GitHub](https://github.com/nikiforovall/opencode-marketplace)

---

## 10. Conclusion

Modern developer tools solve discoverability through **progressive disclosure** and **schema-driven design**:

1. **For Humans**: Interactive prompts, autocomplete, and layered help systems
2. **For Machines**: Schema introspection, JSON Schema, and programmatic APIs
3. **For Both**: Living documentation that stays synchronized with code

The best tools don't force users to choose between exploration and automation - they provide both seamlessly integrated. Nancy Bubble Gum should follow this pattern: make fragments, beads, and schemas discoverable through CLI introspection, interactive modes, IDE integration, and auto-generated documentation.

**The Golden Rule**:
> If a capability exists but isn't discoverable, it might as well not exist. Great tools make their power visible and accessible from the first interaction.
