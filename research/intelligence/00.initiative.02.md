# Research: Composability in Configuration and Prompt Systems

**Date:** 2026-01-24
**Context:** Assembling prompts from fragments (markdown templates + YAML data)
**Use Case:** user identity + project context + TypeScript rules + Linear workflow = complete system prompt

## Executive Summary

Modern composition systems converge on several key patterns:
1. **Template inheritance** (Jinja2-style extends/blocks)
2. **Deep merging** for configuration layering
3. **Component composition** (React-style declarative assembly)
4. **Partial application** for reusable fragments
5. **Pipeline/chain patterns** for sequential transformation

The most successful approaches combine declarative composition with explicit precedence rules and context-aware merging strategies.

---

## 1. Template Composition Systems

### 1.1 Traditional Template Engines

#### Jinja2 (Python)
Jinja2 remains the gold standard for template inheritance with its `extends`/`block` mechanism.

**Key Features:**
- Template inheritance via `{% extends "base.html" %}`
- Named blocks for override points: `{% block content %}...{% endblock %}`
- `super()` function to include parent content
- Composition is hierarchical and declarative

**Code Example:**
```jinja2
{# base.html #}
<!DOCTYPE html>
<html>
<head>
    <title>{% block title %}Default Title{% endblock %}</title>
</head>
<body>
    <header>{% block header %}Default Header{% endblock %}</header>
    <main>{% block content %}{% endblock %}</main>
</body>
</html>

{# child.html #}
{% extends "base.html" %}

{% block title %}Custom Page{% endblock %}

{% block header %}
    {{ super() }}  {# Include parent content #}
    <nav>Additional navigation</nav>
{% endblock %}

{% block content %}
    <h1>Page-specific content</h1>
{% endblock %}
```

**Precedence:** Child blocks completely override parent blocks unless `super()` is called.

**Sources:**
- [Jinja2 Template Inheritance](https://tedboy.github.io/jinja2/templ9.html)
- [Jinja Template Designer Documentation](https://jinja.palletsprojects.com/en/stable/templates/)

#### Handlebars (JavaScript)
Handlebars provides partial inclusion and helper-based composition.

**Key Features:**
- Partials: `{{> header}}`
- Helpers for conditional logic
- Context-based variable replacement
- More limited than Jinja2 for inheritance

**Use Case:** Best for simple variable interpolation and partial inclusion rather than complex hierarchical composition.

**Sources:**
- [Handlebars vs Jinja Comparison](https://stackshare.io/stackups/handlebars-vs-jinja)
- [Template Engines in JavaScript](https://medium.com/@asifazad114/demystifying-template-engines-in-javascript-ejs-handlebars-pug-and-more-69202b78b5b9)

### 1.2 Modern Alternatives (2025)

#### Eta (JavaScript)
Fast, lightweight, configurable alternative to EJS with significantly better performance.

**Advantages:**
- Modern JavaScript features
- Better performance than traditional engines
- Clean syntax

#### Zare (JavaScript)
Component-based template engine focusing on modular, clean templates.

**Key Innovation:** Component-style templates for server-side rendering with modern syntax.

#### MiniJinja (Rust/WASM)
Jinja2 syntax implemented in Rust, available for JavaScript via WASM and as Python extension.

**Advantages:**
- Cross-language compatibility
- High performance
- Familiar Jinja2 syntax

**Sources:**
- [Top 10 Template Engines in 2025](https://beyondthestack.hashnode.dev/top-10-template-engines)
- [MiniJinja GitHub](https://github.com/mitsuhiko/minijinja)

### 1.3 Markdown Template Systems

#### markdown-subtemplate (Python)
Designed specifically for markdown composition with imports and variable replacement.

**Features:**
```python
# Template with imports
# IMPORT: fragments/header.md
# IMPORT: fragments/section-{{topic}}.md

# Variables in Variables.json
{
    "topic": "architecture",
    "project": "nancy-bubble-gum"
}
```

**Process:**
1. Replace IMPORT statements with file contents
2. Substitute variables (dictionary-based)
3. Process through markdown-to-HTML converter

**Sources:**
- [markdown-subtemplate on PyPI](https://pypi.org/project/markdown-subtemplate/)
- [markdown-subtemplate GitHub](https://github.com/mikeckennedy/markdown-subtemplate)

#### md2md (JavaScript)
Auto-generates markdown with fragments and variable support.

**Key Concepts:**
- **Fragments:** Split markdown into independent, reusable pieces
- **Variables:** Defined in Variables.json or at top of markdown
- **Templates:** Composable structures for different output types

**Example:**
```javascript
// Variables.json
{
    "user_role": "senior_engineer",
    "project_name": "nancy-bubble-gum"
}

// fragment: identity.md
User Role: {{user_role}}
Project: {{project_name}}

// main.md
{{fragment:identity.md}}
{{fragment:typescript-rules.md}}
```

**Sources:**
- [md2md GitHub](https://github.com/zilliztech/md2md)

#### marc (JavaScript)
Makes markdown dynamic with integrated templates and auto-update capabilities.

**Features:**
- Variable substitution with `{{variable}}`
- Filters and partials
- Dynamic content from databases
- Auto-update when data changes

**Sources:**
- [marc GitHub](https://github.com/bredele/marc)

---

## 2. Declarative Composition Patterns

### 2.1 React Component Composition

React's composition model provides excellent patterns for assembling complex structures from simple parts.

#### Core Patterns

**1. Children Prop Pattern**
```jsx
// Container component with "hole"
function Card({ children, title }) {
    return (
        <div className="card">
            <h2>{title}</h2>
            <div className="card-content">
                {children}
            </div>
        </div>
    );
}

// Usage - fill the "hole" with content
<Card title="User Profile">
    <UserIdentity />
    <ProjectContext />
    <TypeScriptRules />
</Card>
```

**Prompt System Analog:**
```typescript
// Prompt container with placeholder
interface PromptContainer {
    systemRole: string;
    fragments: Fragment[];
}

const systemPrompt = createPrompt({
    systemRole: "AI Assistant",
    fragments: [
        userIdentityFragment,
        projectContextFragment,
        typescriptRulesFragment,
        linearWorkflowFragment
    ]
});
```

**2. Compound Component Pattern**
```jsx
// Components share internal state via Context
function Prompt({ children }) {
    const [context, setContext] = useState({});

    return (
        <PromptContext.Provider value={{ context, setContext }}>
            {children}
        </PromptContext.Provider>
    );
}

Prompt.Identity = ({ data }) => {
    const { setContext } = useContext(PromptContext);
    // Merge identity into shared context
    return null;
};

// Usage
<Prompt>
    <Prompt.Identity data={userIdentity} />
    <Prompt.ProjectContext data={project} />
    <Prompt.TypeScriptRules />
    <Prompt.LinearWorkflow />
</Prompt>
```

**3. Render Props / Function as Children**
```jsx
function PromptBuilder({ children }) {
    const context = usePromptContext();
    const merge = useMergeStrategy();

    return children({
        context,
        merge,
        addFragment: (fragment) => merge(context, fragment)
    });
}

// Usage
<PromptBuilder>
    {({ addFragment, context }) => (
        <>
            {addFragment(identityFragment)}
            {addFragment(rulesFragment)}
            <FinalPrompt context={context} />
        </>
    )}
</PromptBuilder>
```

**4. Slot Pattern (Multiple "Holes")**
```jsx
function SystemPrompt({ identity, context, rules, workflow }) {
    return (
        <>
            <PromptSection name="identity">{identity}</PromptSection>
            <PromptSection name="context">{context}</PromptSection>
            <PromptSection name="rules">{rules}</PromptSection>
            <PromptSection name="workflow">{workflow}</PromptSection>
        </>
    );
}

// Usage
<SystemPrompt
    identity={<UserIdentity />}
    context={<ProjectContext />}
    rules={<TypeScriptRules />}
    workflow={<LinearWorkflow />}
/>
```

**Key Principles:**
- **Declarative:** Express what you want, not how to build it
- **Flexible:** Arrange components in any order
- **Implicit State Sharing:** Components communicate without explicit prop drilling
- **Composition over Inheritance:** Build complex from simple

**Sources:**
- [React Composition vs Inheritance](https://legacy.reactjs.org/docs/composition-vs-inheritance.html)
- [Advanced React Component Composition](https://frontendmastery.com/posts/advanced-react-component-composition-guide/)
- [Compound Pattern in React](https://pasquale-favella.github.io/blog/28)

### 2.2 Functional Pipeline Patterns

#### Custom Hooks (React)
Extract reusable logic into composable functions:

```typescript
// Custom hooks for prompt composition
function usePromptFragment(fragmentId: string) {
    const [content, setContent] = useState('');

    useEffect(() => {
        loadFragment(fragmentId).then(setContent);
    }, [fragmentId]);

    return content;
}

function usePromptComposition(fragmentIds: string[]) {
    const fragments = fragmentIds.map(usePromptFragment);
    const merge = useMergeStrategy();

    return useMemo(
        () => merge(fragments),
        [fragments, merge]
    );
}

// Usage
function SystemPromptBuilder() {
    const prompt = usePromptComposition([
        'user-identity',
        'project-context',
        'typescript-rules',
        'linear-workflow'
    ]);

    return <PromptDisplay content={prompt} />;
}
```

**Benefits:**
- Self-contained, reusable logic
- Easy to test in isolation
- Composable across components
- Fights complexity growth

**Sources:**
- [Understanding React Composition Patterns](https://medium.com/@ch.venkat668/the-power-of-component-composition-0b6e41feb17d)
- [React Component Composition Guide](https://www.robinwieruch.de/react-component-composition/)

---

## 3. Aspect-Oriented Patterns (Cross-Cutting Concerns)

### 3.1 Core Concepts

**Aspect-Oriented Programming (AOP)** separates cross-cutting concerns into standalone modules called **aspects**.

**Cross-Cutting Concerns:** Functionality used across multiple parts of a system:
- Logging
- Security
- Data validation
- Error handling
- **Prompt System:** Identity, formatting rules, safety guidelines

### 3.2 Key Terminology

- **Point Cut:** Regular expression defining what methods/points to intercept
- **Advice:** Logic within the aspect method (what to do)
- **Aspect:** Combination of pointcut + advice
- **Weaving:** Process of combining aspects with components

### 3.3 Application to Prompt Systems

**Example: Applying Safety Guidelines Across All Prompts**

```typescript
// Aspect: Safety Guidelines
interface PromptAspect {
    pointcut: (prompt: Prompt) => boolean;
    advice: (prompt: Prompt) => Prompt;
}

const safetyAspect: PromptAspect = {
    // Apply to all user-facing prompts
    pointcut: (prompt) => prompt.type === 'user-facing',

    // Inject safety guidelines
    advice: (prompt) => ({
        ...prompt,
        sections: [
            safetyGuidelinesSection,
            ...prompt.sections
        ]
    })
};

const loggingAspect: PromptAspect = {
    pointcut: (prompt) => prompt.environment === 'production',
    advice: (prompt) => {
        console.log('Generating prompt:', prompt.id);
        return prompt;
    }
};

// Aspect weaver
function weaveAspects(prompt: Prompt, aspects: PromptAspect[]): Prompt {
    return aspects.reduce(
        (acc, aspect) =>
            aspect.pointcut(acc) ? aspect.advice(acc) : acc,
        prompt
    );
}

// Usage
const rawPrompt = buildPrompt([identity, context, rules]);
const finalPrompt = weaveAspects(rawPrompt, [
    safetyAspect,
    loggingAspect,
    formattingAspect
]);
```

**Benefits:**
- Clean separation of cross-cutting concerns
- Reusable aspects across different prompts
- No code duplication
- Easy to add/remove aspects

**Sources:**
- [Aspect-Oriented Programming Wikipedia](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
- [Introduction to AOP and Cross-Cutting Concerns](https://www.springboottutorial.com/introduction-to-aspect-oriented-programming-and-cross-cutting-concerns)
- [How AOP Solves Cross-Cutting Concerns](https://ardijorganxhi.medium.com/how-can-aspect-oriented-programming-aop-solve-cross-cutting-concerns-of-your-application-18332c0e2f9a)

---

## 4. CMS Content Assembly Systems

### 4.1 Component Content Management Systems (CCMS)

CCMS manage content at a granular level in small, reusable chunks called "components" rather than entire documents.

**Key Innovation:** Structured content approach separates page elements into distinct components:
- Author
- Title
- Body
- Image + description
- Metadata
- Product pricing
- Terms

**Benefits:**
- Reusable content
- Consistent information across project
- Multi-frontend delivery
- Personalized assembly for different audiences

### 4.2 Composable CMS Architecture

**Principle:** Break responsibilities into specialized tools connected via APIs.

**MACH Architecture:**
- **M**icroservices: Independent, specialized services
- **A**PI-first: All communication via APIs
- **C**loud-native: Scalable infrastructure
- **H**eadless: Separated presentation and content

**Prompt System Analog:**
```typescript
// Microservices for different concerns
interface PromptService {
    getIdentity(): Promise<IdentityFragment>;
    getProjectContext(): Promise<ContextFragment>;
    getRules(language: string): Promise<RulesFragment>;
    getWorkflow(tool: string): Promise<WorkflowFragment>;
}

// API-first composition
async function assemblePrompt(
    services: PromptService,
    config: PromptConfig
): Promise<string> {
    const [identity, context, rules, workflow] = await Promise.all([
        services.getIdentity(),
        services.getProjectContext(),
        services.getRules(config.language),
        services.getWorkflow(config.tool)
    ]);

    return composeFragments([identity, context, rules, workflow]);
}
```

### 4.3 Headless CMS Pattern

Separation of content management (backend) from presentation (frontend).

**Application to Prompts:**
- **Backend:** Fragment storage, versioning, YAML configs
- **Frontend:** Assembly engine, interpolation, rendering
- **API:** Fragment retrieval, composition rules

**Sources:**
- [Component Content Management System](https://hygraph.com/blog/what-is-a-component-content-management-system)
- [Composable CMS Explained](https://www.webstacks.com/blog/composable-cms)
- [Headless CMS Explained](https://www.contentful.com/headless-cms/)

---

## 5. LLM Prompt Chaining and Composition

### 5.1 LangChain Framework

LangChain is the dominant framework for prompt composition in 2025, built around chain abstraction.

#### Core Components

**1. PromptTemplate**
```python
from langchain_core.prompts import PromptTemplate

# Basic template
prompt = PromptTemplate.from_template(
    "As a {role}, analyze this {content_type}: {content}"
)

# Format with specific values
filled = prompt.format(
    role="senior engineer",
    content_type="TypeScript code",
    content="interface User { id: string; }"
)
```

**2. Partial Templates (Fragment Composition)**
```python
# Base template
base_template = PromptTemplate.from_template(
    "As a {role}, analyze this {content_type}: {content}"
)

# Specialized versions (pre-filled fragments)
typescript_template = base_template.partial(
    role="TypeScript expert",
    content_type="TypeScript code"
)

security_template = base_template.partial(
    role="security analyst",
    content_type="code for vulnerabilities"
)

# Use with specific content
prompt = typescript_template.format(
    content="interface User { id: string; }"
)
```

**3. Chat Templates (Multi-Section Composition)**
```python
from langchain_core.prompts import ChatPromptTemplate

# Compose multiple message types
template = ChatPromptTemplate.from_messages([
    ("system", "You are a {role}. Follow these rules:\n{rules}"),
    ("system", "Project context:\n{context}"),
    ("human", "{user_input}"),
])

# Fill in sections
prompt = template.format_messages(
    role="senior TypeScript engineer",
    rules=typescript_rules,
    context=project_context,
    user_input="How should I structure this component?"
)
```

**4. Pipeline Composition (LangChain.js)**
```typescript
import { PipelinePromptTemplate } from 'langchain/prompts';

// Define sub-prompts
const identityPrompt = new PromptTemplate({
    template: "User: {user_name}\nRole: {user_role}",
    inputVariables: ["user_name", "user_role"]
});

const contextPrompt = new PromptTemplate({
    template: "Project: {project}\nStack: {stack}",
    inputVariables: ["project", "stack"]
});

// Combine into pipeline
const pipelinePrompt = new PipelinePromptTemplate({
    pipelinePrompts: [
        { name: "identity", prompt: identityPrompt },
        { name: "context", prompt: contextPrompt }
    ],
    finalPrompt: new PromptTemplate({
        template: "{identity}\n\n{context}\n\nTask: {task}",
        inputVariables: ["identity", "context", "task"]
    })
});
```

**5. Few-Shot Composition**
```python
from langchain_core.prompts import FewShotPromptTemplate

# Example-based composition
examples = [
    {"input": "2+2", "output": "4"},
    {"input": "3+3", "output": "6"}
]

example_prompt = PromptTemplate(
    input_variables=["input", "output"],
    template="Input: {input}\nOutput: {output}"
)

few_shot_prompt = FewShotPromptTemplate(
    examples=examples,
    example_prompt=example_prompt,
    prefix="Solve these math problems:",
    suffix="Input: {input}\nOutput:",
    input_variables=["input"]
)
```

### 5.2 Prompt Chaining Concepts

**Sequential Chaining:** Output of one prompt serves as input for the next.

```python
from langchain.chains import LLMChain, SequentialChain

# Chain 1: Extract requirements
extract_chain = LLMChain(
    llm=llm,
    prompt=PromptTemplate.from_template(
        "Extract key requirements from: {user_input}"
    ),
    output_key="requirements"
)

# Chain 2: Generate implementation
implement_chain = LLMChain(
    llm=llm,
    prompt=PromptTemplate.from_template(
        "Given requirements:\n{requirements}\n\nGenerate TypeScript code:"
    ),
    output_key="code"
)

# Combine chains
overall_chain = SequentialChain(
    chains=[extract_chain, implement_chain],
    input_variables=["user_input"],
    output_variables=["requirements", "code"]
)

# Execute
result = overall_chain({"user_input": "Build a user authentication system"})
```

**Benefits:**
- Break complex tasks into smaller steps
- Structured reasoning process
- Intermediate results available for inspection
- Easy to modify individual steps

### 5.3 Alternative Frameworks (2025)

**Semantic Kernel (Microsoft)**
- Plugin-based architecture
- Flexible, extensible design
- Easy LLM integration

**Haystack**
- Focus on search systems
- Strong RAG (Retrieval-Augmented Generation) support
- Production-ready pipelines

**Sources:**
- [Prompt Chaining with LangChain](https://www.ibm.com/think/tutorials/prompt-chaining-langchain)
- [LangChain Prompt Templates Guide](https://latenode.com/blog/langchain-prompt-templates-complete-guide-with-examples)
- [Agentic AI with LangChain 2025](https://adspyder.io/blog/agentic-ai-with-langchain/)
- [Open Source Prompt Chain Frameworks 2025](https://askbyai.com/blog/24/open-source-prompt-chain-frameworks-2025)

### 5.4 Best Practices for Prompt Composition

#### Template Structure Components
1. **Instruction:** The task to perform
2. **Input:** The data to process
3. **Context:** Extra information for relevance
4. **Exemplars:** Examples showing expected output

#### Design Principles

**1. Clarity and Specificity**
- Simple, unambiguous language
- Avoid jargon
- Provide sufficient context
- Be specific about expected output

**2. Variable Naming**
```python
# Bad: Ambiguous placeholder
template = "Process this: {text}"

# Good: Clear, meaningful variable names
template = "Analyze this {language} code for {concern_type}: {code_snippet}"
```

**3. Avoid Placeholder Ambiguity**
Research shows ~5% of templates use ambiguous placeholders like "text" which lacks meaningful context and complicates maintenance.

**4. Template Integrity**
Each fine-tuned LLM relies on specific chat template structure. Even minor deviations can significantly impact performance.

**5. Contextual Prompting with RAG**
```python
# Retrieval-Augmented Generation pattern
def create_contextual_prompt(query: str, context_sources: list):
    # Retrieve relevant context
    context = retrieve_from_sources(query, context_sources)

    # Compose with context
    return PromptTemplate.from_template(
        "Context:\n{context}\n\nQuery: {query}\n\nAnswer:"
    ).format(context=context, query=query)
```

**6. Iterative Refinement**
Constructing effective prompts involves creatively combining elements based on the problem, with continuous testing and refinement.

**Sources:**
- [Mastering LLM Prompts](https://www.codesmith.io/blog/mastering-llm-prompts)
- [From Prompts to Templates: Systematic Analysis](https://arxiv.org/html/2504.02052v2)
- [Template Syntax Basics for LLM Prompts](https://latitude-blog.ghost.io/blog/template-syntax-basics-for-llm-prompts/)

---

## 6. Configuration Composition and Merging

### 6.1 YAML Composition Patterns

#### Native YAML Features

**Anchors and Aliases:**
```yaml
# Define anchor
defaults: &defaults
  timeout: 30
  retry: 3
  log_level: info

# Reference anchor
development:
  <<: *defaults  # Merge anchor
  log_level: debug  # Override specific value

production:
  <<: *defaults
  timeout: 60
```

**Limitation:** Anchors only valid within the same file.

#### Framework Implementations

**GitLab CI/CD - `extends` Keyword:**
```yaml
# Base template
.typescript_base:
  image: node:18
  before_script:
    - npm install
  cache:
    paths:
      - node_modules/

# Extend template
lint:
  extends: .typescript_base
  script:
    - npm run lint

test:
  extends: .typescript_base
  script:
    - npm test
```

**Features:**
- Multi-level inheritance (up to 11 levels, recommend max 3)
- Simpler than anchors
- Works with includes

**Magnolia CMS - Custom Directives:**
```yaml
# base-config.yaml
database: &database
  host: localhost
  port: 5432

# app-config.yaml
app:
  !include base-config.yaml  # Include entire file
  settings:
    !inherit database  # Inherit specific section
    database: !override  # Completely replace
      host: prod-db.example.com
```

**Directives:**
- `!include`: Reuse arbitrary resources
- `!inherit`: Extend definitions (can modify)
- `!override`: Ignore inherited properties

**HyperExecute - Parent/Child Override:**
```yaml
# base.yaml
version: 1.0
runtime: typescript
timeout: 30

# test.yaml
!inherit base.yaml
timeout: 60  # Override
parallel: 4  # Add new property
```

**Rule:** All values from base YAML are overwritten by parent YAML.

### 6.2 Deep Merge Strategies

#### Merge Behaviors

**1. First (No Merge)**
- Use first encountered value
- Ignore subsequent values
- Fast but limited

**2. Unique (Array Merge)**
- Concatenate arrays
- Remove duplicates
- Useful for lists

**3. Hash/Shallow Merge**
- Merge top-level keys
- Overwrite nested objects completely

**4. Deep Merge**
- Recursively merge nested structures
- Preserve nested properties
- Most powerful but complex

#### Deep Merge Algorithm

**JavaScript Implementation:**
```javascript
function deepMerge(target, source, options = {}) {
    const output = { ...target };

    for (const key in source) {
        const targetValue = output[key];
        const sourceValue = source[key];

        // Both values are objects - recurse
        if (isObject(targetValue) && isObject(sourceValue)) {
            output[key] = deepMerge(targetValue, sourceValue, options);
        }
        // Arrays - merge based on strategy
        else if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
            output[key] = options.mergeArrays
                ? [...targetValue, ...sourceValue]
                : sourceValue;  // Replace
        }
        // Primitive - source overwrites target
        else {
            output[key] = sourceValue;
        }
    }

    return output;
}

// Usage for prompt composition
const baseConfig = {
    system: {
        role: "assistant",
        rules: ["be helpful", "be concise"]
    },
    user: {
        name: "unknown"
    }
};

const userConfig = {
    system: {
        rules: ["use TypeScript"]  // Add to rules
    },
    user: {
        name: "John",
        role: "engineer"
    }
};

const merged = deepMerge(baseConfig, userConfig, { mergeArrays: true });
// Result:
// {
//     system: {
//         role: "assistant",
//         rules: ["be helpful", "be concise", "use TypeScript"]
//     },
//     user: {
//         name: "John",
//         role: "engineer"
//     }
// }
```

**Python Implementation (deepmerge):**
```python
from deepmerge import always_merger, merge_or_raise

# Strategy 1: Always merge (last wins)
config = always_merger.merge(base_config, user_config)

# Strategy 2: Raise on conflict
try:
    config = merge_or_raise.merge(base_config, user_config)
except ValueError as e:
    print(f"Merge conflict: {e}")

# Custom merge strategy
def merge_prompt_configs(base, override):
    """Custom merge for prompt configurations."""
    result = base.copy()

    for key, value in override.items():
        if key not in result:
            result[key] = value
        elif isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = merge_prompt_configs(result[key], value)
        elif isinstance(result[key], list) and isinstance(value, list):
            # Concatenate arrays for sections/rules
            result[key] = result[key] + value
        else:
            # Override scalar values
            result[key] = value

    return result
```

**Elixir Implementation:**
```elixir
# Deep merge maps recursively
DeepMerge.deep_merge(
  %{user: %{name: "John", role: "engineer"}},
  %{user: %{role: "senior engineer", team: "platform"}}
)
# => %{user: %{name: "John", role: "senior engineer", team: "platform"}}
```

### 6.3 Precedence and Conflict Resolution

#### Precedence Rules

**1. Renovate (Configuration Merging):**
```javascript
// extends processed left-to-right
{
    "extends": [
        "config:base",      // Applied first
        "config:typescript", // Overrides base
        "config:local"      // Final precedence
    ]
}
```

**Rule:** Later configurations override earlier ones on property conflicts.

**2. Spring Boot (YAML Documents):**
```yaml
# application.yaml
spring:
  profiles:
    active: development

---
# Later document has precedence
spring:
  profiles:
    active: production  # This value wins
```

**Rule:** Later YAML documents override earlier ones.

**3. Elasticsearch (Template Composition):**
```json
{
    "index_patterns": ["logs-*"],
    "composed_of": [
        "component_template_1",
        "component_template_2"  // Higher precedence
    ]
}
```

**Rule:** Later component templates override earlier ones. `dynamic_templates` are appended (additive).

#### Conflict Resolution Strategies

**1. Last-Wins (Most Common)**
```typescript
const configs = [baseConfig, teamConfig, userConfig];
const final = configs.reduce(deepMerge);  // userConfig wins
```

**2. Explicit Precedence**
```typescript
interface ConfigLayer {
    priority: number;
    config: Config;
}

function mergeWithPrecedence(layers: ConfigLayer[]): Config {
    return layers
        .sort((a, b) => a.priority - b.priority)
        .map(l => l.config)
        .reduce(deepMerge);
}
```

**3. Additive Merge**
```javascript
// Bloomreach: Multiple boost rules are additive
const finalBoost = rule1.boost + rule2.boost + rule3.boost;

// For prompt fragments
const fragments = [
    { type: 'identity', boost: 1.0 },
    { type: 'context', boost: 1.2 },
    { type: 'rules', boost: 1.5 }
];
const totalWeight = fragments.reduce((sum, f) => sum + f.boost, 0);
```

**4. Array Handling Strategies**
```typescript
enum ArrayMergeStrategy {
    REPLACE,     // Source replaces target
    CONCAT,      // Concatenate arrays
    UNIQUE,      // Concatenate + deduplicate
    CUSTOM       // Custom merge function
}

function mergeArrays<T>(
    target: T[],
    source: T[],
    strategy: ArrayMergeStrategy
): T[] {
    switch (strategy) {
        case ArrayMergeStrategy.REPLACE:
            return source;
        case ArrayMergeStrategy.CONCAT:
            return [...target, ...source];
        case ArrayMergeStrategy.UNIQUE:
            return [...new Set([...target, ...source])];
        case ArrayMergeStrategy.CUSTOM:
            return customMerge(target, source);
    }
}
```

**Sources:**
- [GitLab CI/CD YAML Optimization](https://docs.gitlab.com/ci/yaml/yaml_optimization/)
- [YAML inherit and include - Magnolia CMS](https://docs.magnolia-cms.com/product-docs/6.2/Developing/Reusing-configuration/YAML-inherit-and-include.html)
- [Configuration Inheritance and Merging](https://deepwiki.com/suzuki-shunsuke/renovate-config-validator-workflow/3.2-configuration-inheritance-and-merging)
- [deepmerge NPM Package](https://www.npmjs.com/package/deepmerge)
- [Deep Merge Strategy - Puppet](https://www.puppet.com/docs/puppet/7/hiera_merging.html)

---

## 7. Conditional Inclusion Patterns

### 7.1 Modern Framework Approaches (2025)

#### Angular 17+ - New Control Flow
```typescript
// Old approach: *ngIf
<div *ngIf="showRules">...</div>

// New approach (2025): @if
@if (userRole === 'engineer') {
  <typescript-rules />
} @else if (userRole === 'designer') {
  <design-rules />
} @else {
  <general-rules />
}

// Switch blocks
@switch (projectType) {
  @case ('typescript') {
    <ts-config />
  }
  @case ('python') {
    <py-config />
  }
  @default {
    <generic-config />
  }
}

// Local variables
@let userName = user.profile.name;
@let isAdmin = user.role === 'admin';
```

**Benefits:**
- More intuitive than `*ngIf`
- Better performance
- Aligns with modern web standards

#### Lightning Web Components - New Directives
```html
<!-- Old approach: if:true -->
<template if:true={showIdentity}>
    <c-user-identity></c-user-identity>
</template>

<!-- New approach (2025): lwc:if -->
<template>
    <template lwc:if={showIdentity}>
        <c-user-identity></c-user-identity>
    </template>
    <template lwc:elseif={showGeneric}>
        <c-generic-profile></c-generic-profile>
    </template>
    <template lwc:else>
        <c-anonymous></c-anonymous>
    </template>
</template>
```

**Benefits:**
- More efficient than legacy directives
- Clearer syntax
- Future-proof

#### Vue.js - Directive-Based
```vue
<template>
    <!-- Basic conditional -->
    <user-identity v-if="user.isAuthenticated" />
    <login-prompt v-else />

    <!-- Multiple conditions -->
    <div v-if="projectType === 'typescript'">
        <typescript-rules />
    </div>
    <div v-else-if="projectType === 'python'">
        <python-rules />
    </div>
    <div v-else>
        <generic-rules />
    </div>

    <!-- Show/hide (keeps in DOM) -->
    <optional-section v-show="showAdvanced" />
</template>
```

**Difference:**
- `v-if`: Removes from DOM (conditional rendering)
- `v-show`: Toggles CSS display (always in DOM)

#### React - Conditional Rendering Patterns
```tsx
// Pattern 1: Ternary operator
function PromptBuilder({ user }) {
    return (
        <div>
            {user.isAuthenticated ? (
                <UserIdentity user={user} />
            ) : (
                <AnonymousPrompt />
            )}
        </div>
    );
}

// Pattern 2: Logical AND
function PromptWithRules({ projectType }) {
    return (
        <div>
            <BasePrompt />
            {projectType === 'typescript' && <TypeScriptRules />}
            {projectType === 'python' && <PythonRules />}
        </div>
    );
}

// Pattern 3: Early return
function PromptSection({ enabled, content }) {
    if (!enabled) return null;

    return <section>{content}</section>;
}

// Pattern 4: Switch/case pattern
function RuleSelector({ language }) {
    const rules = (() => {
        switch (language) {
            case 'typescript':
                return <TypeScriptRules />;
            case 'python':
                return <PythonRules />;
            case 'rust':
                return <RustRules />;
            default:
                return <GenericRules />;
        }
    })();

    return <div>{rules}</div>;
}
```

### 7.2 Template Engine Conditional Logic

#### Jinja2
```jinja2
{# Simple condition #}
{% if user.role == 'engineer' %}
    Include TypeScript rules
{% endif %}

{# If/elif/else #}
{% if project.language == 'typescript' %}
    {{ typescript_rules }}
{% elif project.language == 'python' %}
    {{ python_rules }}
{% else %}
    {{ generic_rules }}
{% endif %}

{# Conditional with filters #}
{% if fragments|length > 0 %}
    {% for fragment in fragments %}
        {{ fragment.render() }}
    {% endfor %}
{% endif %}

{# Existence check #}
{% if user.identity is defined %}
    User: {{ user.identity.name }}
{% endif %}
```

#### Handlebars
```handlebars
{{! Basic conditional }}
{{#if showIdentity}}
    <div>{{identity}}</div>
{{/if}}

{{! If/else }}
{{#if userRole}}
    Role: {{userRole}}
{{else}}
    Role: Guest
{{/if}}

{{! Custom helpers for complex logic }}
{{#ifEquals projectType "typescript"}}
    {{> typescriptRules}}
{{/ifEquals}}
```

### 7.3 YAML-Based Conditional Configuration

#### GitLab CI/CD Rules
```yaml
# Conditional job execution
lint:
  script: npm run lint
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$PROJECT_TYPE == "typescript"'
      when: always
    - when: never

# Multiple conditions
build:
  script: npm run build
  rules:
    - if: '$CI_COMMIT_TAG && $PROJECT_TYPE == "typescript"'
      variables:
        BUILD_MODE: production
    - if: '$CI_COMMIT_BRANCH == "develop"'
      variables:
        BUILD_MODE: development
```

#### Ansible Conditionals
```yaml
- name: Include TypeScript configuration
  include_vars: "typescript-config.yaml"
  when: project_language == "typescript"

- name: Apply rules conditionally
  template:
    src: "{{ item }}.j2"
    dest: "/config/{{ item }}"
  with_items:
    - identity
    - context
    - "{{ 'typescript-rules' if language == 'typescript' else 'generic-rules' }}"
```

### 7.4 Prompt System Implementation

**TypeScript Example:**
```typescript
interface ConditionalFragment {
    id: string;
    content: string;
    condition: (context: Context) => boolean;
    priority?: number;
}

interface Context {
    user: {
        role: string;
        authenticated: boolean;
    };
    project: {
        type: string;
        language: string;
    };
    environment: string;
}

function composePrompt(
    fragments: ConditionalFragment[],
    context: Context
): string {
    return fragments
        // Filter by condition
        .filter(f => f.condition(context))
        // Sort by priority
        .sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0))
        // Compose content
        .map(f => f.content)
        .join('\n\n');
}

// Usage
const fragments: ConditionalFragment[] = [
    {
        id: 'identity',
        content: 'User: {{user.name}}',
        condition: ctx => ctx.user.authenticated,
        priority: 100
    },
    {
        id: 'typescript-rules',
        content: 'TypeScript Guidelines:\n...',
        condition: ctx => ctx.project.language === 'typescript',
        priority: 50
    },
    {
        id: 'production-safety',
        content: 'Production Safety Rules:\n...',
        condition: ctx => ctx.environment === 'production',
        priority: 90
    },
    {
        id: 'linear-workflow',
        content: 'Linear Workflow:\n...',
        condition: ctx => ctx.project.type === 'saas',
        priority: 30
    }
];

const context: Context = {
    user: { role: 'engineer', authenticated: true },
    project: { type: 'saas', language: 'typescript' },
    environment: 'production'
};

const prompt = composePrompt(fragments, context);
// Includes: identity, production-safety, typescript-rules, linear-workflow
// Ordered by priority: identity > production-safety > typescript-rules > linear-workflow
```

**Sources:**
- [Conditional Rendering in LWC - Modern Upgrade](https://blogs.perficient.com/2025/01/06/conditional-rendering-in-lwc-gets-a-modern-upgrade/)
- [Modern Techniques for Template Rendering](https://medium.com/@angir777/modern-techniques-for-controlling-rendering-in-templates-366c03df6fd2)
- [Conditional Rendering in React 2025](https://blog.newtum.com/conditional-rendering-in-react-for-beginner-apps/)
- [Vue Conditional Rendering - MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_conditional_rendering)

---

## 8. Recommended Approach for Prompt Assembly System

### 8.1 Hybrid Architecture

Based on the research, here's a recommended approach for assembling prompts from markdown templates + YAML data:

```
┌─────────────────────────────────────────────────────────┐
│                   Prompt Assembly System                │
└─────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
   ┌────▼────┐         ┌────▼────┐        ┌────▼────┐
   │ Fragment│         │  YAML   │        │Template │
   │ Storage │         │ Config  │        │ Engine  │
   └────┬────┘         └────┬────┘        └────┬────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
                    ┌───────▼────────┐
                    │ Composition    │
                    │ Engine         │
                    │ • Deep Merge   │
                    │ • Conditional  │
                    │ • Precedence   │
                    └───────┬────────┘
                            │
                    ┌───────▼────────┐
                    │ Interpolation  │
                    │ Engine         │
                    └───────┬────────┘
                            │
                    ┌───────▼────────┐
                    │ Final Prompt   │
                    └────────────────┘
```

### 8.2 Implementation Pattern

**1. Fragment Definition (Markdown + YAML Frontmatter)**

```markdown
---
id: typescript-rules
priority: 50
conditions:
  - project.language == "typescript"
  - user.role in ["engineer", "architect"]
variables:
  style_guide: "Airbnb"
  strict_mode: true
---

# TypeScript Development Rules

You are working with TypeScript following {{style_guide}} style guide.

## Type Safety
- Always use strict mode: {{strict_mode}}
- Prefer interfaces over types for object shapes
- Use explicit return types for functions

## Best Practices
{{#if strict_mode}}
- Enable all strict compiler options
- No implicit any
{{/if}}
```

**2. YAML Configuration (Deep Merge Layers)**

```yaml
# base-config.yaml (lowest priority)
system:
  role: "AI Assistant"
  tone: "professional"

fragments:
  - id: base-identity
    priority: 100
  - id: safety-guidelines
    priority: 95

# project-config.yaml (overrides base)
project:
  name: "nancy-bubble-gum"
  language: "typescript"

fragments:
  - id: typescript-rules
    priority: 50
  - id: project-context
    priority: 60

# user-config.yaml (highest priority)
user:
  name: "John Doe"
  role: "senior_engineer"

fragments:
  - id: user-identity
    priority: 100
```

**3. Composition Engine**

```typescript
interface Fragment {
    id: string;
    priority: number;
    conditions?: Condition[];
    content: string;
    variables?: Record<string, any>;
}

interface Condition {
    field: string;
    operator: 'eq' | 'in' | 'gt' | 'lt';
    value: any;
}

interface Config {
    system?: Record<string, any>;
    project?: Record<string, any>;
    user?: Record<string, any>;
    fragments?: Fragment[];
}

class PromptComposer {
    private fragments: Map<string, Fragment> = new Map();
    private config: Config = {};

    // Load configuration layers (deep merge)
    async loadConfigs(configPaths: string[]): Promise<void> {
        const configs = await Promise.all(
            configPaths.map(path => this.loadYAML(path))
        );

        // Deep merge: base -> project -> user
        this.config = configs.reduce(
            (acc, cfg) => this.deepMerge(acc, cfg),
            {}
        );
    }

    // Load fragment templates
    async loadFragments(fragmentPaths: string[]): Promise<void> {
        for (const path of fragmentPaths) {
            const fragment = await this.parseMarkdownWithFrontmatter(path);
            this.fragments.set(fragment.id, fragment);
        }
    }

    // Evaluate condition against context
    private evaluateCondition(
        condition: Condition,
        context: Config
    ): boolean {
        const value = this.getNestedValue(context, condition.field);

        switch (condition.operator) {
            case 'eq':
                return value === condition.value;
            case 'in':
                return Array.isArray(condition.value) &&
                       condition.value.includes(value);
            case 'gt':
                return value > condition.value;
            case 'lt':
                return value < condition.value;
            default:
                return false;
        }
    }

    // Select fragments based on conditions
    private selectFragments(): Fragment[] {
        const fragmentIds = this.config.fragments?.map(f => f.id) || [];

        return fragmentIds
            .map(id => this.fragments.get(id))
            .filter(f => f !== undefined)
            .filter(f => {
                // Check all conditions
                if (!f.conditions || f.conditions.length === 0) {
                    return true;
                }
                return f.conditions.every(c =>
                    this.evaluateCondition(c, this.config)
                );
            })
            .sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
    }

    // Interpolate variables in template
    private interpolate(template: string, context: Config): string {
        // Simple variable replacement
        let result = template.replace(
            /\{\{([^}]+)\}\}/g,
            (match, path) => {
                const value = this.getNestedValue(context, path.trim());
                return value !== undefined ? String(value) : match;
            }
        );

        // Conditional blocks (simplified Handlebars-style)
        result = result.replace(
            /\{\{#if ([^}]+)\}\}([\s\S]*?)\{\{\/if\}\}/g,
            (match, condition, content) => {
                const value = this.getNestedValue(context, condition.trim());
                return value ? content : '';
            }
        );

        return result;
    }

    // Main composition method
    async compose(): Promise<string> {
        const selectedFragments = this.selectFragments();

        // Merge fragment variables into context
        const fullContext = selectedFragments.reduce(
            (ctx, fragment) => ({
                ...ctx,
                ...fragment.variables
            }),
            this.config
        );

        // Interpolate and join fragments
        const sections = selectedFragments.map(fragment =>
            this.interpolate(fragment.content, fullContext)
        );

        return sections.join('\n\n---\n\n');
    }

    // Deep merge helper
    private deepMerge(target: any, source: any): any {
        if (!this.isObject(target) || !this.isObject(source)) {
            return source;
        }

        const output = { ...target };

        for (const key in source) {
            if (this.isObject(source[key])) {
                output[key] = this.deepMerge(target[key] || {}, source[key]);
            } else if (Array.isArray(source[key])) {
                // Concatenate arrays
                output[key] = [
                    ...(Array.isArray(target[key]) ? target[key] : []),
                    ...source[key]
                ];
            } else {
                output[key] = source[key];
            }
        }

        return output;
    }

    // Get nested value helper
    private getNestedValue(obj: any, path: string): any {
        return path.split('.').reduce(
            (current, key) => current?.[key],
            obj
        );
    }

    private isObject(item: any): boolean {
        return item && typeof item === 'object' && !Array.isArray(item);
    }
}

// Usage
async function buildSystemPrompt() {
    const composer = new PromptComposer();

    // Load configs in precedence order (base -> specific)
    await composer.loadConfigs([
        'config/base-config.yaml',
        'config/project-config.yaml',
        'config/user-config.yaml'
    ]);

    // Load fragment templates
    await composer.loadFragments([
        'fragments/base-identity.md',
        'fragments/user-identity.md',
        'fragments/project-context.md',
        'fragments/typescript-rules.md',
        'fragments/linear-workflow.md',
        'fragments/safety-guidelines.md'
    ]);

    // Compose final prompt
    const prompt = await composer.compose();

    return prompt;
}
```

### 8.3 Key Features

1. **Layered Configuration (Deep Merge)**
   - Base config → Project config → User config
   - Later layers override earlier ones
   - Arrays are concatenated
   - Objects are merged recursively

2. **Conditional Inclusion**
   - Fragments have conditions evaluated against context
   - Support for multiple operators (eq, in, gt, lt)
   - Only matching fragments are included

3. **Priority-Based Ordering**
   - Fragments sorted by priority (high to low)
   - Ensures predictable output order
   - Critical fragments (identity, safety) get high priority

4. **Variable Interpolation**
   - Simple: `{{user.name}}`
   - Nested: `{{project.config.language}}`
   - Conditional blocks: `{{#if strict_mode}}...{{/if}}`

5. **Markdown + YAML Frontmatter**
   - Fragment metadata in YAML frontmatter
   - Content in Markdown
   - Clean separation of config and content

6. **Separation of Concerns**
   - Fragment storage (templates)
   - Configuration (YAML)
   - Composition logic (engine)
   - Interpolation (template processing)

### 8.4 Alternative: LangChain-Based Approach

For LLM-specific use cases, leverage LangChain's proven patterns:

```python
from langchain_core.prompts import (
    ChatPromptTemplate,
    PromptTemplate,
    PipelinePromptTemplate
)

# Define fragment templates
identity_prompt = PromptTemplate.from_template(
    "User: {user_name}\nRole: {user_role}"
)

context_prompt = PromptTemplate.from_template(
    "Project: {project_name}\nLanguage: {project_language}"
)

rules_prompt = PromptTemplate.from_template(
    "{language}_rules:\n{rules_content}"
)

# Compose via pipeline
pipeline = PipelinePromptTemplate(
    pipelinePrompts=[
        {"name": "identity", "prompt": identity_prompt},
        {"name": "context", "prompt": context_prompt},
        {"name": "rules", "prompt": rules_prompt}
    ],
    finalPrompt=PromptTemplate.from_template(
        "{identity}\n\n{context}\n\n{rules}\n\nTask: {task}"
    )
)

# Generate
prompt = pipeline.format(
    user_name="John Doe",
    user_role="senior_engineer",
    project_name="nancy-bubble-gum",
    project_language="TypeScript",
    language="typescript",
    rules_content="...",
    task="Build authentication system"
)
```

**Benefits:**
- Battle-tested framework
- Built-in LLM integration
- Strong community support
- Production-ready

---

## 9. Summary and Recommendations

### 9.1 Best Patterns by Use Case

| Use Case | Recommended Pattern | Key Features |
|----------|-------------------|--------------|
| Simple variable replacement | Handlebars, Mustache | Fast, simple syntax |
| Template inheritance | Jinja2, Nunjucks | Block-based override |
| Markdown composition | markdown-subtemplate, md2md | Fragment imports |
| Configuration merging | Deep merge + YAML | Layered configs |
| LLM prompts | LangChain, Semantic Kernel | Chain composition |
| Complex conditionals | Jinja2, custom engine | Advanced logic |
| React-like composition | Component pattern | Declarative assembly |
| Cross-cutting concerns | AOP pattern | Aspect weaving |

### 9.2 Handling Conflicts and Precedence

**Recommended Strategy:**

1. **Explicit Ordering:** Load configs in precedence order (base → specific)
2. **Deep Merge:** Recursively merge nested objects
3. **Array Strategy:** Concatenate by default (allows additive composition)
4. **Last-Wins:** Later values override earlier ones for scalars
5. **Priority Field:** Use explicit priority numbers for fragment ordering

**Example Precedence Chain:**
```
System Defaults (priority: 0)
  ↓
Base Configuration (priority: 10)
  ↓
Project Configuration (priority: 50)
  ↓
User Configuration (priority: 100)
  ↓
Runtime Overrides (priority: 200)
```

### 9.3 Implementation Checklist

For building a prompt assembly system:

- [ ] Choose template format (recommend: Markdown + YAML frontmatter)
- [ ] Implement deep merge for configuration layers
- [ ] Add conditional evaluation for fragment selection
- [ ] Support variable interpolation (simple and nested)
- [ ] Implement priority-based ordering
- [ ] Define clear precedence rules
- [ ] Add support for aspect-like cross-cutting concerns (safety, logging)
- [ ] Consider LangChain for LLM-specific features
- [ ] Test with realistic fragment combinations
- [ ] Document composition rules for maintainers

### 9.4 Future Considerations

1. **Caching:** Cache compiled templates and merged configs
2. **Validation:** JSON Schema validation for YAML configs
3. **Versioning:** Version fragments for backward compatibility
4. **Testing:** Unit tests for each fragment and composition rules
5. **Performance:** Lazy loading for large fragment libraries
6. **Debugging:** Trace which fragments were included and why
7. **Extensions:** Plugin system for custom conditions/interpolators

---

## 10. Complete Sources

### Template Systems
- [Handlebars vs Jinja Comparison](https://stackshare.io/stackups/handlebars-vs-jinja)
- [Comparing Jinja to Other Templating Engines](https://www.geeksforgeeks.org/python/comparing-jinja-to-other-templating-engines/)
- [Top 10 Template Engines in 2025](https://beyondthestack.hashnode.dev/top-10-template-engines)
- [Template Engines in JavaScript](https://medium.com/@asifazad114/demystifying-template-engines-in-javascript-ejs-handlebars-pug-and-more-69202b78b5b9)
- [MiniJinja GitHub](https://github.com/mitsuhiko/minijinja)
- [Jinja2 Template Inheritance](https://tedboy.github.io/jinja2/templ9.html)
- [Jinja Template Designer Documentation](https://jinja.palletsprojects.com/en/stable/templates/)
- [Jinja Template Inheritance Guide](https://theworldsgonemad.net/2020/jinja-inheritance/)
- [Template Inheritance - Python](https://pyneng.readthedocs.io/en/latest/book/20_jinja2/template_inheritance.html)

### Markdown Composition
- [markdown-subtemplate on PyPI](https://pypi.org/project/markdown-subtemplate/)
- [markdown-subtemplate GitHub](https://github.com/mikeckennedy/markdown-subtemplate)
- [md2md GitHub](https://github.com/zilliztech/md2md)
- [marc GitHub](https://github.com/bredele/marc)
- [Typesetting Markdown - Interpolation](https://dave.autonoma.ca/blog/2019/07/06/typesetting-markdown-part-5/)

### React Composition
- [React Composition vs Inheritance](https://legacy.reactjs.org/docs/composition-vs-inheritance.html)
- [Advanced React Component Composition](https://frontendmastery.com/posts/advanced-react-component-composition-guide/)
- [Compound Pattern in React](https://pasquale-favella.github.io/blog/28)
- [React Composition Patterns](https://krasimir.gitbooks.io/react-in-patterns/content/chapter-04/)
- [Understanding React Composition Patterns](https://medium.com/@ch.venkat668/the-power-of-component-composition-0b6e41feb17d)
- [React Component Composition Guide](https://www.robinwieruch.de/react-component-composition/)
- [React children composition patterns](https://medium.com/@martin_hotell/react-children-composition-patterns-with-typescript-56dfc8923c64)
- [Compound Pattern](https://www.patterns.dev/react/compound-pattern/)
- [Children Props in React](https://medium.com/@nnpk0410/children-props-in-react-enhancing-component-composition-2e7465a1b5e3)

### Aspect-Oriented Programming
- [Aspect-Oriented Programming Wikipedia](https://en.wikipedia.org/wiki/Aspect-oriented_programming)
- [Cross-cutting concern Wikipedia](https://en.wikipedia.org/wiki/Cross-cutting_concern)
- [Introduction to AOP and Cross-Cutting Concerns](https://www.springboottutorial.com/introduction-to-aspect-oriented-programming-and-cross-cutting-concerns)
- [How AOP Solves Cross-Cutting Concerns](https://ardijorganxhi.medium.com/how-can-aspect-oriented-programming-aop-solve-cross-cutting-concerns-of-your-application-18332c0e2f9a)
- [Handling Cross-Cutting Concerns - GitHub](https://docs.github.com/en/copilot/copilot-chat-cookbook/refactoring-code/handling-cross-cutting-concerns)

### CMS Content Assembly
- [Component Content Management System](https://hygraph.com/blog/what-is-a-component-content-management-system)
- [Headless CMS Explained](https://www.contentful.com/headless-cms/)
- [Composable CMS](https://www.webstacks.com/blog/composable-cms)
- [Composable CMS - Crafter](https://craftercms.com/blog/2024/02/composable-cms-the-key-to-increased-agility-and-flexibility)
- [What is a CCMS](https://www.heretto.com/blog/component-content-management-system)

### LangChain and LLM Frameworks
- [Prompt Chaining with LangChain](https://www.ibm.com/think/tutorials/prompt-chaining-langchain)
- [Agentic AI with LangChain 2025](https://adspyder.io/blog/agentic-ai-with-langchain/)
- [LangChain Prompt Templates Guide](https://latenode.com/blog/langchain-prompt-templates-complete-guide-with-examples)
- [Open Source Prompt Chain Frameworks 2025](https://askbyai.com/blog/24/open-source-prompt-chain-frameworks-2025)
- [LangChain Prompt Engineering](https://www.pinecone.io/learn/series/langchain/langchain-prompt-templates/)
- [Prompt Templates in LangChain](https://medium.com/@princekrampah/prompt-templates-in-langchain-248c015be3e0)
- [LangChain.js Prompt Templates](https://www.js-craft.io/blog/langchain-js-prompttemplate/)
- [Mastering LLM Prompts](https://www.codesmith.io/blog/mastering-llm-prompts)
- [From Prompts to Templates: Systematic Analysis](https://arxiv.org/html/2504.02052v2)
- [Template Syntax Basics for LLM Prompts](https://latitude-blog.ghost.io/blog/template-syntax-basics-for-llm-prompts/)

### YAML Configuration
- [GitLab CI/CD YAML Optimization](https://docs.gitlab.com/ci/yaml/yaml_optimization/)
- [YAML inherit and include - Magnolia CMS](https://docs.magnolia-cms.com/product-docs/6.2/Developing/Reusing-configuration/YAML-inherit-and-include.html)
- [HyperExecute YAML Inheritance](https://www.lambdatest.com/support/docs/hyperexecute-inherit-config/)
- [yaml_extend GitHub](https://github.com/magynhard/yaml_extend)
- [Understanding YAML Inheritance - Spring Boot](https://medium.com/@mbanaee61/understanding-yaml-inheritance-and-its-implementation-in-spring-boot-with-junit-tests-6b39d9474dc8)
- [Configuration Inheritance and Merging](https://deepwiki.com/suzuki-shunsuke/renovate-config-validator-workflow/3.2-configuration-inheritance-and-merging)

### Deep Merge
- [deepmerge NPM Package](https://www.npmjs.com/package/deepmerge)
- [Deep Merge Strategy - Puppet](https://www.puppet.com/docs/puppet/7/hiera_merging.html)
- [Fastify deepmerge GitHub](https://github.com/fastify/deepmerge)
- [Deep Merge in TypeScript](https://sandtoken.com/writing/typescript-deep-merge-explained/)
- [Implementing Deep Merge in JavaScript](https://madprofessorblog.org/articles/implementing-a-deep-merge-function-in-javascript/)

### Conditional Rendering
- [Conditional Rendering in LWC - Modern Upgrade](https://blogs.perficient.com/2025/01/06/conditional-rendering-in-lwc-gets-a-modern-upgrade/)
- [Modern Techniques for Template Rendering](https://medium.com/@angir777/modern-techniques-for-controlling-rendering-in-templates-366c03df6fd2)
- [Conditional Rendering in React 2025](https://blog.newtum.com/conditional-rendering-in-react-for-beginner-apps/)
- [Vue Conditional Rendering - MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_conditional_rendering)
- [JavaScript Templating Engines](https://caisy.io/blog/top-javascript-templating-engines)

---

**Research compiled:** 2026-01-24
**For project:** nancy-bubble-gum
**Use case:** Assembling system prompts from composable fragments
