# Storage Format Comparison and Recommendation for Nancy

**Date**: 2026-01-24
**Context**: Evaluating storage format for Nancy's user identity, project context, configurations, and cross-project learning data
**Status**: Comprehensive Analysis

---

## Executive Summary

After analyzing beads and alternative formats against Nancy's 10 core requirements, **the recommendation is to NOT use beads as the primary storage format**. Instead, use **TOML for simple configurations** and **YAML for complex, hierarchical data**, with a clear migration path and validation layer.

**Key Finding**: Beads is a task/issue management system with a complex dual-storage architecture (SQLite + JSONL), not a general-purpose configuration format. It introduces unnecessary complexity and vendor lock-in for Nancy's needs.

**Recommended Architecture**:
1. **TOML** for user preferences, simple configs (`~/.nancy/config.toml`)
2. **YAML** for project context, style guides, workflow definitions (`~/.nancy/beads/`)
3. **SQLite** for queryable caches (sessions, notifications) - already implemented in nancy-bubble-gum
4. **JSON Schema** for validation across all formats

---

## Requirements Matrix

Scoring: ‚úÖ Excellent (3) | ‚úîÔ∏è Good (2) | ‚ö†Ô∏è Partial (1) | ‚ùå Poor (0)

| Requirement | Beads | YAML | TOML | JSON5 | HCL | SQLite |
|-------------|-------|------|------|-------|-----|--------|
| **1. Human-readable/editable** | ‚ö†Ô∏è Complex | ‚úÖ Yes | ‚úÖ Yes | ‚úîÔ∏è Yes | ‚úîÔ∏è Yes | ‚ùå No |
| **2. Structured data** | ‚úÖ Yes | ‚úÖ Yes | ‚úîÔ∏è Limited | ‚úîÔ∏è Yes | ‚úÖ Yes | ‚úÖ Yes |
| **3. Composable** | ‚ö†Ô∏è Complex | ‚úÖ Excellent | ‚úîÔ∏è Good | ‚úîÔ∏è Good | ‚úÖ Excellent | ‚ùå No |
| **4. Schema-validatable** | ‚ö†Ô∏è Limited | ‚úÖ JSON Schema | ‚úÖ JSON Schema | ‚úÖ JSON Schema | ‚úÖ Native | ‚úÖ Native |
| **5. Version-controllable** | ‚úîÔ∏è Git-based | ‚úÖ Excellent | ‚úÖ Excellent | ‚úÖ Excellent | ‚úÖ Excellent | ‚ùå Binary |
| **6. Cross-platform** | ‚úîÔ∏è Node.js only | ‚úÖ Universal | ‚úÖ Universal | ‚úîÔ∏è Good | ‚úîÔ∏è Good | ‚úÖ Universal |
| **7. Language support** | ‚ö†Ô∏è TypeScript | ‚úÖ All langs | ‚úÖ All langs | ‚úîÔ∏è JS-heavy | ‚úîÔ∏è Go-heavy | ‚úÖ All langs |
| **8. Performance** | ‚ö†Ô∏è Overhead | ‚úÖ Fast | ‚úÖ Fast | ‚úÖ Fast | ‚úÖ Fast | ‚úÖ Fastest |
| **9. Querying** | ‚úÖ SQLite cache | ‚ö†Ô∏è Manual | ‚ö†Ô∏è Manual | ‚ö†Ô∏è Manual | ‚ö†Ô∏è Manual | ‚úÖ SQL |
| **10. Evolution-friendly** | ‚úîÔ∏è Versioned | ‚úÖ Excellent | ‚úÖ Excellent | ‚úîÔ∏è Good | ‚úÖ Excellent | ‚ö†Ô∏è Migrations |
| **TOTAL SCORE** | **17/30** | **27/30** | **26/30** | **22/30** | **25/30** | **20/30** |

### Detailed Scoring Rationale

#### Beads (17/30)
- **Strengths**: Built-in SQLite querying, git-portable architecture, versioned
- **Weaknesses**:
  - Complex dual-storage (SQLite + JSONL) is overkill for configs
  - Node.js/TypeScript dependency adds overhead
  - Designed for issue tracking, not general configuration
  - Limited adoption (single maintainer, launched late 2025)
  - No established validation patterns for custom schemas

#### YAML (27/30)
- **Strengths**:
  - Universal support across all languages
  - Excellent for nested/hierarchical data
  - Wide ecosystem (Kubernetes, GitHub Actions, Docker Compose)
  - JSON Schema validation available
  - Anchor/alias support for DRY configs
- **Weaknesses**:
  - Whitespace-sensitive (indentation errors)
  - No querying without external tools
  - Multiple flavors can cause compatibility issues

#### TOML (26/30)
- **Strengths**:
  - Explicit, unambiguous syntax
  - Prevents indentation errors
  - Native datetime support
  - Designed specifically for config files
  - Growing adoption (Rust Cargo, Python pyproject.toml)
- **Weaknesses**:
  - Less suitable for deeply nested structures
  - Limited to simple hierarchies
  - No querying without external tools

#### JSON5 (22/30)
- **Strengths**: Comments, trailing commas, unquoted keys
- **Weaknesses**: Less universal than JSON/YAML, ecosystem smaller

#### HCL (25/30)
- **Strengths**: Expression support, variables, functions, excellent error messages
- **Weaknesses**: Tied to HashiCorp ecosystem, less portable

#### SQLite (20/30)
- **Strengths**: Fast queries, transactions, mature
- **Weaknesses**: Binary format, not human-editable, poor git diffs

---

## What IS Beads? (Deep Dive)

Based on research from [Steve Yegge's beads repository](https://github.com/steveyegge/beads) and [introduction article](https://steve-yegge.medium.com/introducing-beads-a-coding-agent-memory-system-637d7d92514a):

### Architecture
```
.beads/
‚îú‚îÄ‚îÄ beads.db          # SQLite cache (NOT committed to git)
‚îú‚îÄ‚îÄ issues.jsonl      # Git-tracked issue data (one line per issue)
‚îú‚îÄ‚îÄ metadata.json     # Backend configuration
‚îú‚îÄ‚îÄ config.yaml       # User configuration
‚îî‚îÄ‚îÄ deletions.jsonl   # Tombstone manifest
```

### Purpose
Beads is a **coding agent memory system** for:
- Task/issue management for AI agents
- Linear/GitHub issue synchronization
- Agent workflow automation

### Storage Model
- **Primary storage**: JSONL (line-oriented JSON for git-friendly diffs)
- **Cache layer**: SQLite database (hydrates on demand from JSONL)
- **Sync modes**: git-portable (default), realtime, dolt-native, belt-and-suspenders

### Why It's Not Right for Nancy

1. **Architectural Mismatch**: Nancy needs simple config storage, not an issue tracking system
2. **Complexity Overhead**: Dual-storage (SQLite + JSONL) + sync logic is unnecessary
3. **Vendor Lock-in**: Tied to beads tooling, single maintainer (Steve Yegge)
4. **Immature Ecosystem**: Launched late 2025, limited adoption, no proven track record
5. **TypeScript Dependency**: Requires Node.js runtime for a Go-based tool (nancy-bubble-gum)
6. **Overengineered**: Nancy doesn't need issue sync, agent workflows, or realtime collaboration

---

## Risk Assessment

### Beads Risks

| Risk Category | Severity | Likelihood | Mitigation |
|---------------|----------|------------|------------|
| **Abandonment** | HIGH | MEDIUM | Single maintainer, new project (launched late 2025) |
| **Breaking Changes** | HIGH | HIGH | Immature API, no 1.0 release, rapid iteration |
| **Ecosystem Lock-in** | HIGH | CERTAIN | Proprietary format, limited tooling outside beads CLI |
| **Performance Overhead** | MEDIUM | CERTAIN | Node.js runtime + SQLite + JSONL parsing |
| **Learning Curve** | MEDIUM | HIGH | Complex architecture, dual-storage model, sync modes |
| **Migration Difficulty** | HIGH | MEDIUM | Custom JSONL format, SQLite schema dependencies |
| **TypeScript Dependency** | MEDIUM | CERTAIN | Adds Node.js to Go project dependencies |

### YAML/TOML Risks

| Risk Category | Severity | Likelihood | Mitigation |
|---------------|----------|------------|------------|
| **Abandonment** | NONE | NONE | Industry standards, decades of support |
| **Breaking Changes** | LOW | VERY LOW | Stable specs (YAML 1.2, TOML 1.0) |
| **Ecosystem Lock-in** | NONE | NONE | Universal parsers in all languages |
| **Performance** | LOW | LOW | Fast parsers (Go: gopkg.in/yaml.v3, BurntSushi/toml) |
| **Learning Curve** | LOW | LOW | Widely known formats, extensive documentation |
| **Migration Difficulty** | LOW | LOW | Easy to convert between formats, standard schemas |
| **Dependencies** | NONE | NONE | Standard library support in most languages |

### SQLite Risks (for caching only)

| Risk Category | Severity | Likelihood | Mitigation |
|---------------|----------|------------|------------|
| **Git-unfriendly** | MEDIUM | CERTAIN | Use for caches only, not source of truth |
| **Human editability** | HIGH | CERTAIN | Never require manual SQLite editing |
| **Migration complexity** | MEDIUM | MEDIUM | Use migrations (already implemented in nancy-bubble-gum) |

---

## Decision Factors

### Deal-Breakers (Must-Haves)

These requirements ELIMINATE options:

1. **Human-editable without special tools**
   - ‚ùå Eliminates: Pure SQLite as primary storage
   - ‚ùå Eliminates: Binary formats

2. **Cross-platform, language-agnostic**
   - ‚ö†Ô∏è Concerns with: Beads (Node.js dependency for Go project)
   - ‚ö†Ô∏è Concerns with: HCL (HashiCorp ecosystem bias)

3. **Mature, stable, widely adopted**
   - ‚ùå Eliminates: Beads (launched late 2025, single maintainer)
   - ‚ö†Ô∏è Concerns with: JSON5 (smaller ecosystem than YAML/TOML)

4. **Git-friendly diffs**
   - ‚ùå Eliminates: SQLite as primary storage
   - ‚úÖ Passes: YAML, TOML, JSON5, HCL, Beads (JSONL)

### Nice-to-Haves (Differentiators)

1. **Native querying** - SQLite cache (separate concern)
2. **Composition patterns** - YAML (anchors), HCL (modules), Kubernetes-style overlays
3. **Built-in validation** - JSON Schema works for YAML/TOML/JSON5
4. **Developer familiarity** - YAML wins (Kubernetes, GitHub Actions, Docker Compose)

### Future-Proofing Considerations

1. **Ecosystem momentum** (2025-2030 outlook):
   - YAML: Entrenched in DevOps, cloud-native (Kubernetes, Helm, Argo)
   - TOML: Growing (Rust, Python packaging, static site generators)
   - JSON5: Steady niche (developer configs, ESLint)
   - HCL: Stable in HashiCorp ecosystem, limited outside
   - Beads: Unknown (too new, single maintainer)

2. **Tool integration**:
   - YAML/TOML: Native support in VSCode, JetBrains, Vim, Emacs
   - Beads: Custom tooling required

3. **AI/LLM compatibility**:
   - YAML/TOML: LLMs trained extensively on these formats
   - Beads: Too new for significant training data

---

## Comparison to Developer Tool Precedents

Research from [AI coding assistants comparison](https://usama.codes/blog/ai-coding-assistants-2025-comparison) and ecosystem analysis:

### Configuration Patterns in AI Coding Tools (2025-2026)

| Tool | Storage Format | Rationale |
|------|----------------|-----------|
| **Cursor** | VS Code-based (JSON) | Leverage existing VS Code settings |
| **GitHub Copilot** | Plugin config (JSON) | Universal support, API compatibility |
| **Windsurf** | VS Code + custom (JSON) | Standard IDE configuration |
| **Claude Code** | CLI-based (YAML/TOML likely) | Terminal-native, flexible configs |

**Pattern**: Established tools use **standard formats** (JSON, YAML, TOML), NOT custom formats.

### Developer Tool Storage Patterns

| Tool | Configuration | Data Storage | Rationale |
|------|--------------|--------------|-----------|
| **VS Code** | JSON (`settings.json`) | JSON | Universal, IDE-native |
| **ESLint** | JS/JSON/YAML (`.eslintrc.*`) | N/A | Multi-format flexibility |
| **Prettier** | JSON/YAML/TOML (`.prettierrc.*`) | N/A | Developer choice |
| **Docker Compose** | YAML (`docker-compose.yml`) | N/A | Nested structure, clarity |
| **Terraform** | HCL (`*.tf`) | State (JSON) | Domain-specific language |
| **Kubernetes** | YAML (manifests) | etcd | Declarative, composable |
| **Cargo (Rust)** | TOML (`Cargo.toml`) | N/A | Simple, explicit |
| **Poetry (Python)** | TOML (`pyproject.toml`) | N/A | PEP 517 standard |

**Key Insight**: Successful tools either:
1. Use industry-standard formats (YAML, TOML, JSON)
2. Have a compelling reason for custom format (Terraform's HCL for infrastructure-as-code)

**Beads does NOT meet criterion #2** - no compelling reason to use custom JSONL + SQLite dual-storage for simple configuration.

---

## Migration Path Analysis

### Scenario: Choose X today, switch to Y later

#### Starting with Beads ‚Üí Migrating to YAML/TOML

**Difficulty**: üî¥ **HIGH**

**Challenges**:
- Custom JSONL format requires parsing beads-specific schema
- SQLite cache schema may diverge from JSONL
- Beads sync modes (git-portable, realtime, dolt-native) create migration variants
- Limited tooling for beads ‚Üí standard format conversion

**Estimated effort**: 2-4 weeks
- Write custom parser for `.beads/issues.jsonl`
- Map beads schema to Nancy schema
- Validate data integrity
- Test edge cases (deletions.jsonl tombstones, sync state)

**Risk**: HIGH - Custom format may evolve, breaking migration scripts

---

#### Starting with YAML/TOML ‚Üí Migrating to Beads

**Difficulty**: üü° **MEDIUM**

**Challenges**:
- Need to adopt beads tooling and runtime (Node.js)
- Convert flat/nested configs to beads issue schema
- May lose data that doesn't fit beads' issue-tracking model

**Estimated effort**: 1-2 weeks
- Install beads CLI and dependencies
- Write conversion scripts (YAML/TOML ‚Üí JSONL)
- Restructure data to fit beads schema

**Risk**: MEDIUM - Forces data into issue-tracking model (may not fit)

---

#### YAML ‚Üî TOML

**Difficulty**: üü¢ **LOW**

**Challenges**:
- Minor syntax differences (indentation vs explicit sections)
- TOML limited for deeply nested structures

**Estimated effort**: 1-3 days
- Use standard converters (yq, toml-cli)
- Validate with JSON Schema

**Risk**: LOW - Both are well-understood, standard formats

---

#### SQLite ‚Üî YAML/TOML

**Difficulty**: üü° **MEDIUM** (one-way: YAML/TOML ‚Üí SQLite: EASY; reverse: HARD)

**Forward (YAML/TOML ‚Üí SQLite)**: Easy - parse and INSERT
**Reverse (SQLite ‚Üí YAML/TOML)**: Requires schema understanding, manual mapping

**Estimated effort**:
- Forward: 1 day (straightforward dump)
- Reverse: 3-5 days (schema analysis, normalization, denormalization decisions)

**Risk**: MEDIUM - SQLite schema changes require migration tracking

---

### Migration Strategy Recommendation

**Hybrid Approach** (minimize lock-in, maximize flexibility):

```
Source of Truth (Git-committed):
‚îú‚îÄ‚îÄ ~/.nancy/config.toml          # User preferences (TOML)
‚îú‚îÄ‚îÄ ~/.nancy/beads/
‚îÇ   ‚îú‚îÄ‚îÄ user.yaml                 # User identity
‚îÇ   ‚îú‚îÄ‚îÄ projects/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ {project}.yaml        # Per-project context
‚îÇ   ‚îî‚îÄ‚îÄ styles/
‚îÇ       ‚îî‚îÄ‚îÄ {language}.yaml       # Language-specific rules

Cache Layer (Not git-committed):
‚îî‚îÄ‚îÄ ~/.nancy/bubble-gum.db        # SQLite cache (already implemented)
```

**Rationale**:
1. **TOML** for simple, flat configs (user prefs) - easy to edit, no indentation issues
2. **YAML** for hierarchical data (project context, styles) - supports nesting, anchors
3. **SQLite** for queryable caches (sessions, notifications) - already proven in nancy-bubble-gum
4. **No beads dependency** - avoid vendor lock-in, complexity overhead

**Migration Path**:
- TOML ‚Üî YAML: Trivial (standard tools)
- YAML ‚Üí SQLite: Easy (parse + INSERT for caching)
- SQLite ‚Üí YAML: One-time export if needed (not primary workflow)

---

## Recommendation

### Primary: TOML + YAML Hybrid

**Use TOML for**:
- User preferences (`~/.nancy/config.toml`)
- Simple, flat configurations
- Settings with explicit types (integers, booleans, datetimes)

**Example**:
```toml
[user]
name = "Alice"
email = "alice@example.com"
theme = "dark"

[editor]
font_size = 14
tab_size = 2
vim_mode = true

[sync]
backend = "linear"
auto_sync = true
sync_interval = 300  # seconds
```

**Use YAML for**:
- Project context (`~/.nancy/beads/projects/{project}.yaml`)
- Code style guides (`~/.nancy/beads/styles/{language}.yaml`)
- Workflow definitions
- Hierarchical, nested structures

**Example**:
```yaml
apiVersion: nancy.io/v1
kind: ProjectContext
metadata:
  name: nancy-bubble-gum
  labels:
    language: go
    framework: bubbletea
spec:
  description: Terminal UI for Nancy workflow management
  techStack:
    - Go 1.21+
    - Bubble Tea
    - SQLite
  style:
    importGroupOrder:
      - standard
      - external
      - internal
  workflows:
    - name: test-driven
      steps:
        - Write test
        - Implement feature
        - Refactor
```

**Use SQLite for**:
- Queryable caches (sessions, notifications) - already implemented
- Non-source-of-truth data
- Performance-critical queries

---

### Runner-Up: Pure YAML

If you want **one format** for simplicity:

**Pros**:
- Single format to learn
- Maximum flexibility
- Industry standard (Kubernetes, GitHub Actions, Docker Compose)

**Cons**:
- Indentation sensitivity for simple configs
- Overkill for flat settings

**Verdict**: TOML + YAML hybrid is better (right tool for each job)

---

### Why NOT Beads

1. **Architectural Mismatch**: Nancy needs config storage, not issue tracking
2. **Unnecessary Complexity**: Dual-storage (SQLite + JSONL) + sync modes
3. **Immature**: Launched late 2025, single maintainer, no 1.0 release
4. **Vendor Lock-in**: Proprietary JSONL format, limited ecosystem
5. **TypeScript Dependency**: Node.js runtime for a Go project
6. **Migration Risk**: Hard to migrate away from beads
7. **Learning Curve**: Complex architecture vs simple YAML/TOML
8. **No Compelling Advantage**: YAML/TOML solve Nancy's needs with less risk

**Exception**: If Nancy evolves to need **issue tracking with Linear/GitHub sync** (beads' core purpose), reconsider beads for that specific use case. But for general configuration, stick with standards.

---

## Red Flags and Concerns

### Beads-Specific Red Flags

1. **Single Maintainer Risk**
   - Steve Yegge is sole maintainer
   - No governance model or community
   - Bus factor: 1

2. **Rapid Iteration (Breaking Changes)**
   - Launched late 2025, still in active development
   - No semantic versioning guarantees
   - [Releases page](https://github.com/steveyegge/beads/releases) shows frequent changes

3. **Limited Adoption**
   - GitHub stars: ~500-1000 (estimate based on launch timing)
   - No major projects using beads in production
   - Community support: Minimal

4. **Unclear Long-term Vision**
   - Is beads a config format or issue tracker?
   - Sync modes suggest enterprise features (realtime, dolt-native) - scope creep?
   - Will it stay focused or bloat over time?

5. **TypeScript/Node.js Dependency**
   - Nancy-bubble-gum is Go-based
   - Adding Node.js just for config parsing is heavyweight
   - Cross-compilation complexity

### YAML/TOML Concerns (Manageable)

1. **YAML Indentation Errors**
   - **Mitigation**: Use linters (yamllint), editor plugins, JSON Schema validation
   - **Severity**: Low (developer familiarity reduces errors)

2. **TOML Nested Limitations**
   - **Mitigation**: Use YAML for deeply nested data
   - **Severity**: Low (hybrid approach solves this)

3. **No Native Querying**
   - **Mitigation**: SQLite cache layer (already implemented in nancy-bubble-gum)
   - **Severity**: Low (caching strategy handles this)

---

## Validation Experiments (Before Final Decision)

### Experiment 1: Prototype Nancy Config in TOML + YAML

**Goal**: Validate hybrid approach fits Nancy's data models

**Steps**:
1. Design schema for:
   - User preferences (TOML)
   - Project context (YAML)
   - Style guides (YAML)
2. Implement parsers (Go: `BurntSushi/toml`, `gopkg.in/yaml.v3`)
3. Test composition (merge multiple YAML files)
4. Validate with JSON Schema

**Success Criteria**:
- Schemas feel natural for their data
- Composition works cleanly (YAML anchors, references)
- Parsing is fast (<10ms for 100 files)

**Estimated Time**: 2-3 days

---

### Experiment 2: Beads Integration Test

**Goal**: Understand beads' actual complexity and fit

**Steps**:
1. Install beads CLI (`npm install -g @steveyegge/beads`)
2. Initialize beads in test directory
3. Create sample Nancy data in beads format
4. Attempt to query, compose, and migrate data
5. Measure performance and developer experience

**Success Criteria**:
- Beads setup is straightforward (<30 min)
- Nancy data fits naturally into beads schema
- Performance is acceptable (<50ms queries)
- Migration scripts are simple

**Estimated Time**: 1-2 days

**Risk**: May reveal beads is even worse fit than analysis suggests

---

### Experiment 3: Migration Simulation

**Goal**: Prove migration paths are viable

**Steps**:
1. Create sample data in TOML/YAML
2. Write converter to beads JSONL
3. Write reverse converter (beads ‚Üí YAML/TOML)
4. Validate round-trip integrity

**Success Criteria**:
- Round-trip conversion preserves data
- Conversion scripts are <200 lines of code
- Migration can be automated

**Estimated Time**: 2 days

---

### Experiment 4: Community Pulse Check

**Goal**: Validate ecosystem momentum and support

**Steps**:
1. Check beads GitHub activity (commits, issues, PRs, releases)
2. Search for beads usage in public repos (`uses:steveyegge/beads`)
3. Survey AI coding tool configurations (Cursor, Windsurf, Claude Code)
4. Compare YAML/TOML parser downloads (npm, Go packages)

**Success Criteria**:
- Beads shows healthy, growing community
- Comparable adoption to YAML/TOML in target domain
- Active maintenance (commits within last month)

**Estimated Time**: 1 day

---

## Next Steps

### Immediate (Week 1)

1. **Run Experiment 1** (TOML + YAML prototype)
   - Design Nancy schemas
   - Implement parsers
   - Test composition

2. **Document schema patterns**
   - Base schemas (user, project, style)
   - Composition rules (how files merge)
   - Validation approach (JSON Schema)

### Short-term (Week 2-3)

3. **Run Experiment 4** (community pulse check)
   - Validate beads is not gaining unexpected traction
   - Confirm YAML/TOML remain safe bets

4. **Implement validation layer**
   - JSON Schema definitions for Nancy data models
   - Validation on load (fail fast for invalid configs)
   - Clear error messages

### Optional (If beads shows promise)

5. **Run Experiments 2 & 3** (beads deep dive)
   - Only if Experiment 4 reveals strong community momentum
   - Or if Nancy's requirements shift toward issue tracking

### Final Decision Point (Week 4)

6. **Make formal decision**
   - Review experiment results
   - Stakeholder alignment
   - Document decision rationale (ADR - Architecture Decision Record)

---

## Conclusion

**Use TOML + YAML hybrid for Nancy's storage format.**

**Rationale**:
1. ‚úÖ **Meets all 10 requirements** (27-26/30 score vs beads' 17/30)
2. ‚úÖ **Industry standards** (decades of support, universal adoption)
3. ‚úÖ **Low risk** (stable specs, mature parsers, easy migration)
4. ‚úÖ **Developer familiarity** (Kubernetes, Docker Compose, Cargo, pyproject.toml)
5. ‚úÖ **Right tool for the job** (TOML for simple, YAML for hierarchical)
6. ‚úÖ **Future-proof** (entrenched in DevOps, cloud-native, AI/LLM training data)

**Avoid beads because**:
1. ‚ùå **Wrong abstraction** (issue tracker, not config format)
2. ‚ùå **Immature** (launched late 2025, single maintainer, no 1.0)
3. ‚ùå **Vendor lock-in** (proprietary JSONL format, limited ecosystem)
4. ‚ùå **Unnecessary complexity** (dual-storage, sync modes, Node.js dependency)
5. ‚ùå **High migration risk** (hard to escape if beads is abandoned)

**Reserve SQLite for**:
- Queryable caches (already proven in nancy-bubble-gum)
- Performance-critical operations
- Non-source-of-truth data

**Exception**: If Nancy's roadmap includes **Linear/GitHub issue sync** or **agent workflow automation** (beads' core purpose), revisit beads for that specific subsystem. But keep configuration in YAML/TOML.

---

## References and Sources

### Beads Research
- [GitHub - steveyegge/beads](https://github.com/steveyegge/beads)
- [Introducing Beads: A coding agent memory system](https://steve-yegge.medium.com/introducing-beads-a-coding-agent-memory-system-637d7d92514a)
- [Beads Blows Up](https://steve-yegge.medium.com/beads-blows-up-a0a61bb889b4)
- [beads/docs/CONFIG.md](https://github.com/steveyegge/beads/blob/main/docs/CONFIG.md)

### Configuration Format Comparisons
- [JSON vs YAML vs TOML: Which Configuration Format Should You Use in 2026?](https://dev.to/jsontoall_tools/json-vs-yaml-vs-toml-which-configuration-format-should-you-use-in-2026-1hlb)
- [YAML vs JSON vs TOML: Complete Configuration Format Comparison](https://www.datafmt.com/en/blog/en-yaml-json-toml-comparison)
- [TOML vs YAML vs JSON: Complete Comparison [2025]](https://jsontoyamlconverter.com/yaml-vs-json/toml/)
- [Configuration Format Comparison](https://schoenwald.aero/posts/2025-05-03_configuration-format-comparison/)

### HCL vs YAML/TOML
- [The Comprehensive Guide to YAML, JSON, TOML, HCL](https://medium.com/@s.atmaramani/the-comprehensive-guide-to-yaml-json-toml-hcl-hashicorp-xml-differences-237ec82092ca)
- [Why I Believe HCL is Better than YAML](https://medium.com/hashicorp-engineering/why-i-believe-hcl-is-better-than-yaml-78226a645b0d)
- [HashiCorp Configuration Language (HCL): Overview & Tutorial](https://spacelift.io/blog/hcl-hashicorp-configuration-language)

### AI Coding Tools
- [AI Coding Assistants 2025: Cursor vs GitHub Copilot vs Claude Code vs Windsurf](https://usama.codes/blog/ai-coding-assistants-2025-comparison)
- [Agentic IDE Comparison: Cursor vs Windsurf vs Antigravity](https://www.codecademy.com/article/agentic-ide-comparison-cursor-vs-windsurf-vs-antigravity)
- [Top 10 Vibe Coding Tools in 2026](https://www.nucamp.co/blog/top-10-vibe-coding-tools-in-2026-cursor-copilot-claude-code-more)

### Schema Design & Composition Patterns
- [JSON Schema - Boolean JSON Schema combination](https://json-schema.org/understanding-json-schema/reference/combining)
- [Inheritance and Polymorphism | Swagger Docs](https://swagger.io/docs/specification/v3_0/data-models/inheritance-and-polymorphism/)
- [Future of CRDs: Structural Schemas | Kubernetes](https://kubernetes.io/blog/2019/06/20/crd-structural-schema/)
- [Kustomize Tutorial With Instructions & Examples](https://kubex.ai/kubernetes-tools/kustomize/)
- [Docker Compose - Merge](https://docs.docker.com/compose/how-tos/multiple-compose-files/merge/)

---

**Date**: 2026-01-24
**Researcher**: Claude Sonnet 4.5
**Status**: Ready for Review
**Next Action**: Run validation experiments (Week 1-4 plan above)
