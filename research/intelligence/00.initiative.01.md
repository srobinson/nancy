# Schema Design for Composable Data Systems: Research Findings

**Date**: 2026-01-24
**Research Focus**: Battle-tested patterns for composable, extensible schema design
**Context**: Nancy Bubble Gum prompt factory with YAML "beads"

---

## Executive Summary

Modern composable systems use layered approaches combining:
1. **Base schemas with composition operators** (allOf, oneOf, merge)
2. **Overlay/patch patterns** (Kustomize, Docker Compose overrides)
3. **Optional fields with defaults** (schema evolution best practice)
4. **Discriminated unions** (polymorphism without rigidity)
5. **unevaluatedProperties** (modern alternative to additionalProperties: false)

The key insight: **Avoid rigid schemas**. Successful systems use "expand-contract" patterns and treat schemas as documentation/validation hints rather than strict contracts.

---

## 1. JSON Schema Composition Patterns

### Pattern: allOf for Schema Intersection

**Description**: Combine multiple schemas where data must satisfy ALL schemas simultaneously.

**Real-World Usage**:
- OpenAPI schema composition
- Configuration validation across systems
- Type narrowing in strongly-typed systems

**Example**:
```yaml
# Base user preferences
UserPreferences:
  type: object
  properties:
    theme:
      type: string
      enum: [light, dark, auto]

# Extended for developers
DeveloperPreferences:
  allOf:
    - $ref: '#/components/schemas/UserPreferences'
    - type: object
      properties:
        editorFontSize:
          type: number
          default: 14
        tabSize:
          type: number
          default: 2
```

**Pros for Beads**:
- Clear inheritance hierarchy
- Reuse base schemas
- Type safety through intersection

**Cons for Beads**:
- `additionalProperties: false` breaks composition (see solutions below)
- Can become overly complex with deep nesting
- Validation tools may struggle with merged schemas

**Sources**:
- [JSON Schema - Boolean JSON Schema combination](https://json-schema.org/understanding-json-schema/reference/combining)
- [JSON Schema - Modular JSON Schema combination](https://json-schema.org/understanding-json-schema/structuring)
- [Combining schemas | Ajv JSON schema validator](https://ajv.js.org/guide/combining-schemas.html)

---

### Pattern: oneOf/anyOf for Polymorphic Data

**Description**: Define multiple alternative schemas where data must match ONE (oneOf) or ANY (anyOf) schema.

**Real-World Usage**:
- OpenAPI discriminated unions
- Plugin manifest variants (different plugin types)
- Multi-format configuration files

**Example**:
```yaml
# Different bead types for different contexts
Bead:
  oneOf:
    - $ref: '#/components/schemas/UserBead'
    - $ref: '#/components/schemas/ProjectBead'
    - $ref: '#/components/schemas/StyleBead'
  discriminator:
    propertyName: beadType
    mapping:
      user: '#/components/schemas/UserBead'
      project: '#/components/schemas/ProjectBead'
      style: '#/components/schemas/StyleBead'

UserBead:
  type: object
  required: [beadType, userId]
  properties:
    beadType:
      type: string
      const: user
    userId:
      type: string
    preferences:
      type: object

ProjectBead:
  type: object
  required: [beadType, projectName]
  properties:
    beadType:
      type: string
      const: project
    projectName:
      type: string
    techStack:
      type: array
      items:
        type: string
```

**Pros for Beads**:
- Clear type discrimination
- Different beads can have completely different structures
- Self-documenting (beadType field indicates structure)

**Cons for Beads**:
- Requires discriminator field in every bead
- Validation complexity increases with many variants
- Can be overkill for simple variations

**Sources**:
- [Inheritance and Polymorphism | Swagger Docs](https://swagger.io/docs/specification/v3_0/data-models/inheritance-and-polymorphism/)
- [oneOf, allOf, anyOf: composition and inheritance in OpenAPI](https://www.speakeasy.com/openapi/schemas/objects/polymorphism)
- [How to use the OpenAPI discriminator](https://redocly.com/learn/openapi/discriminator)
- [A Comprehensive Guide to OpenAPI Discriminator](https://apidog.com/blog/openapi-discriminator-guide/)

---

### Pattern: unevaluatedProperties (Modern Alternative to additionalProperties)

**Description**: Like `additionalProperties: false` but works correctly with schema composition (allOf, oneOf, etc.).

**Problem It Solves**:
`additionalProperties: false` only recognizes properties in the SAME subschema, breaking composition patterns.

**Example**:
```yaml
# OLD WAY - BREAKS WITH COMPOSITION
BaseConfig:
  type: object
  properties:
    name: { type: string }
  additionalProperties: false  # ❌ Won't recognize properties from extending schemas

# NEW WAY - WORKS WITH COMPOSITION
BaseConfig:
  type: object
  properties:
    name: { type: string }
  unevaluatedProperties: false  # ✅ Recognizes properties from all composed schemas

ExtendedConfig:
  allOf:
    - $ref: '#/components/schemas/BaseConfig'
    - type: object
      properties:
        version: { type: string }
```

**Pros for Beads**:
- Enables strict validation WITH composition
- Catches typos/invalid fields
- Modern JSON Schema 2019-09+ feature

**Cons for Beads**:
- Requires modern validators (not all tools support it yet)
- May need fallback for older systems

**Sources**:
- [JSON Schema - object](https://json-schema.org/understanding-json-schema/reference/object)
- [Mastering JSON Schema additionalProperties for Flexible Validation](https://deepdocs.dev/json-schema-additionalproperties/)

---

## 2. Kubernetes CRD Patterns (Battle-Tested Extensibility)

### Pattern: Structural Schemas with OpenAPI Extensions

**Description**: Kubernetes requires "structural schemas" - well-defined types with clear boundaries, enhanced with special x-kubernetes-* extensions.

**Real-World Usage**:
- All Kubernetes Custom Resource Definitions (CRDs)
- ArgoCD applications
- Istio virtual services
- Any k8s operator pattern

**Key Extensions**:
```yaml
# Embedded Kubernetes resources
x-kubernetes-embedded-resource: true
# Tells validators: this field contains a full k8s resource with apiVersion, kind, metadata

# Polymorphic int-or-string types
x-kubernetes-int-or-string: true
# Common for ports (80 or "http"), resource limits ("100m" or 100)

# Preserve unknown fields (escape hatch for extensibility)
x-kubernetes-preserve-unknown-fields: true
# Within this field, don't prune unknown properties
```

**Example CRD Schema**:
```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: projects.nancy.io
spec:
  versions:
    - name: v1
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                # Strict validation for known fields
                language:
                  type: string
                  enum: [typescript, go, python, rust]
                framework:
                  type: string

                # Extensibility escape hatch
                customConfig:
                  type: object
                  x-kubernetes-preserve-unknown-fields: true

                # Required fields
                name:
                  type: string
              required:
                - name
                - language
```

**Pros for Beads**:
- Battle-tested at massive scale (every k8s cluster)
- Clear extensibility model (preserve-unknown-fields)
- Strong versioning support (v1, v1alpha1, v2)
- Validation happens automatically

**Cons for Beads**:
- K8s-specific extensions may not work outside k8s validators
- Structural schema requirements can feel rigid
- Learning curve for OpenAPI v3 spec

**Sources**:
- [Future of CRDs: Structural Schemas | Kubernetes](https://kubernetes.io/blog/2019/06/20/crd-structural-schema/)
- [In-Depth Guide to Custom Resource Definitions (CRDs) in Kubernetes](https://medium.com/@thamunkpillai/in-depth-guide-to-custom-resource-definitions-crds-in-kubernetes-ad63e86ee3f0)
- [Kubernetes CRDs Explained: A Beginner-Friendly Guide](https://devoriales.com/kubernetes-crds-explained-a-beginner-friendly-guide-to-extending-the-kubernetes-api)

---

### Pattern: API Versioning for Schema Evolution

**Description**: Support multiple schema versions simultaneously with conversion webhooks.

**Real-World Usage**:
- Kubernetes API versioning (v1beta1 → v1)
- Database migration patterns
- API deprecation paths

**Example**:
```yaml
# In Nancy beads context
versions:
  - name: v1
    served: true
    storage: true
    schema:
      # Current schema

  - name: v1beta1
    served: true
    storage: false
    deprecated: true
    schema:
      # Old schema (still accepted, auto-converted to v1)
```

**Pros for Beads**:
- Graceful evolution without breaking old beads
- Can introduce breaking changes with new versions
- Clear migration path

**Cons for Beads**:
- Requires conversion logic
- Complexity of maintaining multiple versions
- Storage version must be chosen

**Sources**:
- [Kubernetes CRD - Abilian Innovation Lab](https://lab.abilian.com/Tech/Containers/Kubernetes%20CRD/)
- [Understanding Custom Resource Definitions (CRD) in Kubernetes](https://www.cloudthat.com/resources/blog/understanding-custom-resource-definitions-crd-in-kubernetes)

---

## 3. Configuration Management Overlay Patterns

### Pattern: Kustomize Overlays (Patch-Based Composition)

**Description**: Start with a base configuration, then apply patches/overlays for different environments without templating.

**Real-World Usage**:
- Kubernetes manifest management
- Multi-environment deployments (dev/staging/prod)
- Team-specific configurations

**Directory Structure**:
```
beads/
├── base/
│   ├── kustomization.yaml
│   ├── user-defaults.yaml
│   └── style-defaults.yaml
├── overlays/
│   ├── personal/
│   │   ├── kustomization.yaml
│   │   └── preferences-patch.yaml
│   └── team-acme/
│       ├── kustomization.yaml
│       └── team-standards-patch.yaml
```

**Example**:
```yaml
# base/user-defaults.yaml
apiVersion: nancy.io/v1
kind: UserPreferences
metadata:
  name: default-user
spec:
  theme: light
  editorFontSize: 14
  tabSize: 2

# overlays/personal/preferences-patch.yaml
apiVersion: nancy.io/v1
kind: UserPreferences
metadata:
  name: default-user
spec:
  theme: dark  # Override
  vimMode: true  # Add new field

# overlays/personal/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
bases:
  - ../../base
patches:
  - preferences-patch.yaml
```

**Pros for Beads**:
- No templating logic (pure data)
- Clear separation: base + specific changes
- Composable (can apply multiple overlays)
- Git-friendly (each overlay in separate files)

**Cons for Beads**:
- Requires kustomize tooling (or reimplementation)
- Patch syntax can be verbose
- Strategic merge vs JSON patch confusion

**Sources**:
- [Kustomize Tutorial With Instructions & Examples](https://kubex.ai/kubernetes-tools/kustomize/)
- [Configure Kubernetes with Kustomize | Config Sync](https://docs.cloud.google.com/kubernetes-engine/config-sync/docs/concepts/kustomize)
- [The Power of Kustomize and Helm](https://medium.com/@brent.gruber77/the-power-of-kustomize-and-helm-5773d0f4d95e)

---

### Pattern: Docker Compose Overrides (File Merging)

**Description**: Automatically merge `docker-compose.yaml` + `docker-compose.override.yaml` with predictable rules.

**Real-World Usage**:
- Docker development environments
- CI/CD pipeline variations
- Developer-specific local settings

**Merge Rules**:
- **Maps/Objects**: Merged recursively
- **Lists/Arrays**: Replaced entirely (later file wins)
- **Simple values**: Overridden (later file wins)
- **Special handling**: environment, labels, volumes, devices are merged

**Example**:
```yaml
# docker-compose.yaml (base)
version: '3.8'
services:
  app:
    image: myapp:latest
    environment:
      NODE_ENV: production
      LOG_LEVEL: info
    ports:
      - "3000:3000"

# docker-compose.override.yaml (local dev)
version: '3.8'
services:
  app:
    environment:
      NODE_ENV: development  # Override
      DEBUG: "true"  # Merge
    ports:
      - "3001:3000"  # Replace entire array
    volumes:
      - ./src:/app/src  # Add new field
```

**Pros for Beads**:
- Simple mental model (base + override)
- Works automatically (just create override file)
- Environment/labels merge intelligently
- Widely understood pattern

**Cons for Beads**:
- Array replacement can be surprising (not merged)
- Only 2-level override (base + one override)
- Not designed for deep composition

**Sources**:
- [Merge | Docker Docs](https://docs.docker.com/compose/how-tos/multiple-compose-files/merge/)
- [How to Run Multiple Docker Compose Files Together](https://oneuptime.com/blog/post/2026-01-16-docker-multiple-compose-files/view)
- [Fragments | Docker Docs](https://docs.docker.com/reference/compose-file/fragments/)

---

### Pattern: Helm Values (Templating + Defaults)

**Description**: Define default values.yaml, allow users to override with custom values, render templates.

**Real-World Usage**:
- Kubernetes package management
- Application deployment across environments
- Team/organization standards

**Structure**:
```yaml
# values.yaml (defaults)
replicaCount: 1
image:
  repository: nginx
  tag: "1.21"
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 80

# values-production.yaml (overrides)
replicaCount: 3
image:
  tag: "1.21.6"  # Specific version
service:
  type: LoadBalancer  # Different service type

# Usage
helm install myapp ./chart -f values-production.yaml
```

**Combining with Kustomize**:
Many teams use **Helm for packaging + Kustomize for environment-specific patches**:
- Helm manages the complex templating
- Kustomize overlays handle environment differences
- Best of both worlds

**Pros for Beads**:
- Deep merge of values (nested objects combine)
- Template logic keeps data files simple
- Widely adopted ecosystem

**Cons for Beads**:
- Templating adds complexity
- Helm-specific tooling required
- Can become "too flexible" (logic creep into templates)

**Sources**:
- [When and How to Use Helm and Kustomize Together](https://trstringer.com/helm-kustomize/)
- [How to use Helm charts with Kustomize for managing multiple environments](https://diptochakrabarty.medium.com/how-to-use-helm-charts-with-kustomize-for-managing-multiple-environments-ccfa3dfed738)
- [Kustomize vs. Helm - How to Use & Comparison](https://spacelift.io/blog/kustomize-vs-helm)

---

## 4. Plugin Manifest Designs

### Pattern: VSCode Extension Manifest (Contribution Points)

**Description**: `package.json` with standard npm fields + VSCode-specific `contributes` section for declarative extensibility.

**Real-World Usage**:
- All VSCode extensions (~40,000 extensions)
- Visual Studio extensions
- Similar patterns in Atom, Sublime Text

**Example**:
```json
{
  "name": "my-extension",
  "version": "1.0.0",
  "engines": {
    "vscode": "^1.60.0"
  },
  "contributes": {
    "commands": [
      {
        "command": "myext.doSomething",
        "title": "Do Something"
      }
    ],
    "configuration": {
      "title": "My Extension",
      "properties": {
        "myext.fontSize": {
          "type": "number",
          "default": 14,
          "description": "Font size for the editor"
        },
        "myext.theme": {
          "type": "string",
          "enum": ["light", "dark", "auto"],
          "default": "auto"
        }
      }
    },
    "keybindings": [
      {
        "command": "myext.doSomething",
        "key": "ctrl+shift+d"
      }
    ]
  }
}
```

**Key Pattern**: **Contribution Points**
- Extensions declare WHAT they provide (commands, config, keybindings)
- Host (VSCode) handles HOW to integrate
- Schema validates structure
- Extensible: new contribution types added over time

**Pros for Beads**:
- Self-describing (manifest tells you what the extension does)
- Strongly typed (JSON schema validation)
- Discoverable (VSCode shows available extensions/features)
- Composable (multiple extensions coexist)

**Cons for Beads**:
- Requires central schema definition
- Can become verbose with many contributions
- Limited to declarative features (complex logic needs code)

**Sources**:
- [Extension Manifest | Visual Studio Code Extension API](https://code.visualstudio.com/api/references/extension-manifest)
- [Building VS Code Extensions in 2026: The Complete Guide](https://abdulkadersafi.com/blog/building-vs-code-extensions-in-2026-the-complete-modern-guide)
- [Extension Anatomy | Visual Studio Code Extension API](https://code.visualstudio.com/api/get-started/extension-anatomy)

---

### Pattern: ESLint Config Composition (Extends + Overrides)

**Description**: Base config + extends (inheritance) + overrides (file-specific rules).

**Real-World Usage**:
- ESLint, Prettier, Stylelint configs
- Build tool configs (Vite, Webpack)
- Test framework configs (Jest, Vitest)

**Example**:
```javascript
// .eslintrc.js
module.exports = {
  // Inherit from shared configs
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react/recommended'
  ],

  // Base rules for all files
  rules: {
    'no-console': 'warn',
    'prefer-const': 'error'
  },

  // File-specific overrides
  overrides: [
    {
      files: ['*.test.ts', '*.spec.ts'],
      extends: ['plugin:jest/recommended'],
      rules: {
        'no-console': 'off'  // Allow console in tests
      }
    },
    {
      files: ['scripts/**/*.js'],
      env: {
        node: true
      },
      rules: {
        'no-console': 'off'  // Allow console in scripts
      }
    }
  ]
};
```

**How It Works**:
1. `extends` configs are merged left-to-right (later overrides earlier)
2. Base `rules` override extended configs
3. `overrides` are applied based on file globs
4. Override `extends` can further extend configs
5. Works like `Object.assign()` for merging

**Pros for Beads**:
- Widely understood pattern
- Clear hierarchy (base → extends → overrides)
- File-glob based overrides (useful for different bead types)
- Flat config evolution brings back extends in modern way

**Cons for Beads**:
- Can get complex with deep inheritance chains
- Order matters (confusing for newcomers)
- Merge behavior not always intuitive

**Sources**:
- [Configuration Files - ESLint](https://eslint.org/docs/latest/use/configure/configuration-files)
- [Evolving flat config with extends - ESLint](https://eslint.org/blog/2025/03/flat-config-extends-define-config-global-ignores/)
- [Share Configurations - ESLint](https://eslint.org/docs/latest/extend/shareable-configs)

---

## 5. Terraform Module Composition

### Pattern: Dependency Inversion (Modules Accept Dependencies)

**Description**: Instead of modules creating their own dependencies, they accept them as inputs, enabling composition.

**Example**:
```hcl
# ❌ BAD: Module creates its own VPC
module "app" {
  source = "./modules/app"

  # Module internally creates VPC, subnet, etc.
}

# ✅ GOOD: Module accepts VPC as input
module "vpc" {
  source = "./modules/vpc"
  cidr   = "10.0.0.0/16"
}

module "app" {
  source = "./modules/app"

  vpc_id    = module.vpc.id
  subnet_id = module.vpc.public_subnets[0]
}
```

**Pros for Beads**:
- Beads can reference other beads
- Enables composition (user bead + project bead → context bead)
- Flexible reuse

**Cons for Beads**:
- Requires dependency resolution
- Can create circular dependencies if not careful

---

### Pattern: Facade Modules (High-Level API)

**Description**: Create a simple module that orchestrates multiple complex modules under the hood.

**Example**:
```hcl
# Facade module provides simple API
module "complete_app" {
  source = "./modules/complete-app-facade"

  app_name    = "myapp"
  environment = "production"
}

# Internally, it uses multiple modules
# - VPC module
# - Database module
# - App module
# - Monitoring module
```

**Pros for Beads**:
- Simple API for common cases
- Advanced users can use lower-level modules
- Progressive disclosure

**Cons for Beads**:
- Hides complexity (can be good or bad)
- Harder to customize edge cases

**Sources**:
- [Module Composition | Terraform | HashiCorp Developer](https://developer.hashicorp.com/terraform/language/modules/develop/composition)
- [Terraform Module Composition | Brainboard Blog](https://blog.brainboard.co/terraform-module-composition/)
- [Terraform Infrastructure Design Patterns](https://www.opencredo.com/blogs/terraform-infrastructure-design-patterns)

---

## 6. Schema Evolution Patterns

### Pattern: Expand-Contract for Backward Compatibility

**Description**: Three-phase approach to schema changes:
1. **Expand**: Add new field alongside old field
2. **Migrate**: Update writers/readers to use new field
3. **Contract**: Remove old field

**Real-World Usage**:
- Database schema migrations
- API versioning
- Message queue schema evolution (Kafka, Pulsar)

**Example**:
```yaml
# Phase 1: Expand (both fields exist)
User:
  username: "alice"  # Old field
  user_id: "alice"   # New field (duplicate)
  email: "alice@example.com"

# Phase 2: Migrate (code switches to user_id)
# Old readers still work (read username)
# New readers prefer user_id

# Phase 3: Contract (remove username)
User:
  user_id: "alice"
  email: "alice@example.com"
```

**Pros for Beads**:
- Zero-downtime migrations
- Backward compatibility guaranteed
- Clear migration path

**Cons for Beads**:
- Temporary duplication
- Requires discipline (can't skip to phase 3)
- Need migration tooling

**Sources**:
- [Schema Evolution and Compatibility | Confluent](https://docs.confluent.io/platform/current/schema-registry/fundamentals/schema-evolution.html)
- [Schema Evolution Patterns with Backward/Forward Compatibility](https://dev3lop.com/schema-evolution-patterns-with-backward-forward-compatibility/)
- [Schema Evolution in Data Pipelines: Tools, Versioning & Zero-Downtime](https://dataengineeracademy.com/module/best-practices-for-managing-schema-evolution-in-data-pipelines/)

---

### Pattern: Optional Fields with Defaults

**Description**: All new fields are optional with sensible defaults. Old readers ignore new fields.

**Real-World Usage**:
- Avro schema evolution
- Protocol Buffers
- JSON Schema evolution

**Example**:
```yaml
# V1 schema
User:
  type: object
  required:
    - username
  properties:
    username: { type: string }

# V2 schema (backward compatible)
User:
  type: object
  required:
    - username  # Same required fields as V1
  properties:
    username: { type: string }
    theme:  # New optional field
      type: string
      default: "light"
    notifications:  # New optional field
      type: boolean
      default: true
```

**Rules for Backward Compatibility**:
- ✅ Add optional fields
- ✅ Remove fields (readers ignore unknown fields)
- ✅ Change field defaults
- ❌ Add required fields (breaks old data)
- ❌ Change field types (breaks validation)
- ❌ Rename fields (same as remove + add)

**Pros for Beads**:
- Simple mental model
- Works with most validators
- Natural evolution path

**Cons for Beads**:
- Can accumulate cruft over time
- Defaults may not fit all contexts

**Sources**:
- [Best Practices for Evolving Schemas in Schema Registry](https://docs.solace.com/Schema-Registry/schema-registry-best-practices.htm)
- [How do you handle schema evolution in data pipelines](https://leonidasgorgo.medium.com/how-do-you-handle-schema-evolution-in-data-pipelines-and-ensure-backward-compatibility-48c01efebf71)

---

### Pattern: Union Types for Flexibility

**Description**: Allow fields to accept multiple types, enabling gradual type changes.

**Example**:
```yaml
# Start with string port
Service:
  port: "8080"

# Evolve to support int OR string
Service:
  port:
    oneOf:
      - type: integer
      - type: string

# Data can be either
port: 8080      # Valid
port: "8080"    # Valid
port: "http"    # Valid (named port)
```

**Pros for Beads**:
- Smooth type evolution
- Supports multiple input formats
- Common in k8s (int-or-string pattern)

**Cons for Beads**:
- Validation complexity
- May need normalization logic

**Sources**:
- [Schema Evolution in Change Data Capture Pipelines](https://www.decodable.co/blog/schema-evolution-in-change-data-capture-pipelines)
- [Schema Evolution in Real-Time Systems](https://estuary.dev/blog/real-time-schema-evolution/)

---

## 7. Data Format Evolution: Avro vs Protobuf

### Avro Approach

**Key Characteristics**:
- Schema stored with data OR in schema registry
- Reader schema + writer schema → resolution rules
- All fields have defaults → implicitly optional
- Schema is JSON (human-readable)

**Example**:
```json
// Writer schema (V1)
{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "username", "type": "string"}
  ]
}

// Reader schema (V2) - backward compatible
{
  "type": "record",
  "name": "User",
  "fields": [
    {"name": "username", "type": "string"},
    {"name": "email", "type": ["null", "string"], "default": null}
  ]
}
```

**Evolution Rules**:
- Field with default → can be added (backward compatible)
- Field → can be removed (forward compatible)
- Union type can be expanded

**Pros**:
- Schemas are data (JSON, easy to version)
- Dynamic typing (reader/writer schema resolution)
- Excellent for data lakes, Kafka topics

**Cons**:
- Requires schema registry for best results
- Less compact than Protobuf
- Tooling ecosystem smaller than Protobuf

---

### Protobuf Approach

**Key Characteristics**:
- Field numbers (tags) never change
- Optional/required/repeated modifiers
- Unknown fields ignored
- Binary format (compact)

**Example**:
```protobuf
// V1
message User {
  string username = 1;
}

// V2 - backward compatible
message User {
  string username = 1;
  optional string email = 2;  // New optional field
  reserved 3, 4;  // Reserved for future use or deleted fields
}
```

**Evolution Rules**:
- Never change field numbers
- New fields must be optional
- Can delete fields (mark reserved)
- Can't reuse field numbers

**Pros**:
- No schema registry required (self-describing)
- Very compact binary format
- Excellent tooling (protoc, grpc)
- Explicit optional/required

**Cons**:
- Less flexible than Avro (fixed field numbers)
- Schema changes need recompilation
- Not human-readable (binary)

**Sources**:
- [Schema evolution in Avro, Protocol Buffers and Thrift](https://martin.kleppmann.com/2012/12/05/schema-evolution-in-avro-protocol-buffers-thrift.html)
- [Schema Evolution in Apache Avro, Protobuf, and JSON Schema](https://www.javacodegeeks.com/2025/06/schema-evolution-in-apache-avro-protobuf-and-json-schema.html)
- [Real-Time Schema Evolution with Avro and Protobuf](https://medium.com/@balachandra.keley/real-time-schema-evolution-with-avro-and-protobuf-ensuring-backward-compatibility-d4b96aacb4e3)

---

## 8. Ansible Patterns

### Pattern: Variable Precedence Hierarchy

**Description**: Variables can be defined at multiple levels with clear precedence order.

**Precedence (lowest to highest)**:
1. Role defaults (`roles/*/defaults/main.yml`)
2. Inventory variables (`group_vars/`, `host_vars/`)
3. Playbook variables
4. Extra variables (`-e` flag)

**Example**:
```yaml
# roles/webserver/defaults/main.yml (lowest precedence)
webserver_port: 80
webserver_ssl: false

# group_vars/production.yml (higher precedence)
webserver_ssl: true

# playbook.yml (even higher)
- hosts: webservers
  vars:
    webserver_port: 8080

# Command line (highest precedence)
ansible-playbook playbook.yml -e "webserver_port=9000"
```

**Pros for Beads**:
- Clear override hierarchy
- Different contexts (global, group, individual)
- CLI overrides for testing

**Cons for Beads**:
- Can be confusing which value "wins"
- Requires understanding precedence

**Sources**:
- [Using variables — Ansible Community Documentation](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html)
- [Mastering Ansible Variables: Practical Guide with Examples](https://medium.com/env0/mastering-ansible-variables-practical-guide-with-examples-0de631c34799)

---

## Recommendations for Nancy Beads

Based on this research, here are battle-tested patterns for the Nancy bead system:

### 1. **Base Schema with unevaluatedProperties**

```yaml
# Base bead schema
Bead:
  type: object
  required:
    - apiVersion
    - kind
    - metadata
  properties:
    apiVersion:
      type: string
      pattern: "^nancy\\.io/v[0-9]+$"
    kind:
      type: string
    metadata:
      type: object
      required: [name]
      properties:
        name: { type: string }
        labels:
          type: object
          additionalProperties: { type: string }
    spec:
      type: object
  unevaluatedProperties: false  # Strict validation with composition support
```

### 2. **Discriminated Bead Types (oneOf pattern)**

```yaml
# Different bead kinds
kind: UserPreferences
spec:
  theme: dark
  editorFontSize: 14

---
kind: ProjectContext
spec:
  language: typescript
  framework: react

---
kind: StyleGuide
spec:
  language: typescript
  rules:
    - prefer-const
    - no-any
```

### 3. **Overlay Pattern for Composition**

```
beads/
├── global/
│   ├── user-defaults.yaml
│   └── style-defaults.yaml
├── projects/
│   └── my-app/
│       ├── context.yaml
│       └── overrides.yaml
└── teams/
    └── acme/
        └── standards.yaml
```

### 4. **Optional Fields with Defaults**

```yaml
UserPreferences:
  type: object
  properties:
    theme:
      type: string
      enum: [light, dark, auto]
      default: auto
    editorFontSize:
      type: number
      minimum: 8
      maximum: 72
      default: 14
    # All fields optional with defaults = backward compatible evolution
```

### 5. **Escape Hatches for Extensibility**

```yaml
ProjectContext:
  type: object
  properties:
    language:
      type: string
      enum: [typescript, go, python, rust]

    # Known frameworks
    framework:
      type: string

    # Unknown/custom config (escape hatch)
    customConfig:
      type: object
      description: "Arbitrary config for tooling-specific needs"
      # No validation - preserve unknown fields
```

### 6. **Version with expand-contract**

```yaml
# V1
apiVersion: nancy.io/v1
kind: UserPreferences

# V2 (new features)
apiVersion: nancy.io/v2
kind: UserPreferences

# Both can coexist
# Conversion logic handles v1 → v2
```

---

## Anti-Patterns to Avoid

### ❌ Don't: `additionalProperties: false` with composition

**Problem**: Breaks allOf/oneOf composition.
**Solution**: Use `unevaluatedProperties: false` instead.

### ❌ Don't: Deep nested schemas (>3 levels)

**Problem**: Hard to understand, maintain, and compose.
**Solution**: Flatten with references, use composition operators.

### ❌ Don't: Required fields in new schema versions

**Problem**: Breaks backward compatibility.
**Solution**: Make new fields optional with defaults.

### ❌ Don't: Implicit schema (no validation)

**Problem**: Typos silently ignored, no discoverability.
**Solution**: Define schemas, validate on save.

### ❌ Don't: Single monolithic schema

**Problem**: Can't compose, hard to extend.
**Solution**: Multiple small schemas with composition.

---

## Tools for Implementation

### Schema Validation
- **ajv** (JavaScript): Supports JSON Schema 2019-09+, unevaluatedProperties
- **jsonschema** (Python): Python validator
- **yq** (CLI): YAML query/manipulation (like jq for YAML)

### Schema Composition
- **Kustomize**: Patch-based composition (can be used for any YAML)
- **yq eval-all '. as $item ireduce ({}; . * $item)'**: Deep merge YAML files

### Schema Registries
- **Confluent Schema Registry**: If using Kafka-like event streams
- **Custom Git repo**: Simple versioned schema storage

---

## Conclusion

**Key Insight**: The most successful composable systems balance structure with flexibility:

1. **Structure** through:
   - Base schemas with clear types
   - Validation on save (catch errors early)
   - Discriminated types (know what you have)

2. **Flexibility** through:
   - Optional fields with defaults (evolution)
   - Overlay/patch patterns (composition)
   - Escape hatches (unknown use cases)
   - unevaluatedProperties (composition-safe validation)

3. **Discoverability** through:
   - Schema documentation
   - Examples in each schema
   - Clear type hierarchy

**For Nancy Beads**: Start simple (flat YAML with optional validation), evolve toward structured schemas with composition as complexity grows. The patterns above provide a roadmap from simple to sophisticated.

---

**Research Date**: 2026-01-24
**Researcher**: Claude (Sonnet 4.5)
**Next Steps**: Design specific bead schemas based on these patterns
