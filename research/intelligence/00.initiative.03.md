# Extensibility in Plugin/Module Systems: Modern Approaches

**Research Focus**: Zero-config discoverability and non-breaking additions for language, framework, and workflow extensions.

**Last Updated**: 2026-01-24

---

## Executive Summary

Modern plugin systems prioritize **convention over configuration**, using filesystem-based discovery, naming patterns, and registry hooks to enable extensions without touching core code. The most successful systems (Vite, Nuxt, Astro, GitHub Actions) combine:

1. **Strict naming conventions** for auto-discovery
2. **Manifest-based contracts** (package.json, YAML) for metadata
3. **Hook/lifecycle systems** for predictable extension points
4. **Namespace scoping** to prevent conflicts
5. **Semantic versioning** for compatibility management

---

## 1. Plugin Architecture Patterns

### 1.1 Microkernel Architecture

**Core Concept**: Minimal core with extensible plugin system (Babel, Webpack, ESLint, Rollup).

**Key Characteristics**:
- Core provides infrastructure (compilation, bundling, linting)
- 80%+ of functionality delivered through plugins (Webpack's own codebase)
- Plugins hook into specific lifecycle stages
- Core remains stable while plugins evolve

**Example: Webpack**
```javascript
// Plugin is a JavaScript object with apply() method
class MyPlugin {
  apply(compiler) {
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // Plugin logic at specific lifecycle hook
      callback();
    });
  }
}
```

**Tapable System** (Webpack's backbone):
- Creates hooks for plugin attachment
- Supports sync/async hooks
- Hook types: Compiler, Compilation, Resolver, Module Factories, Parser, Templates
- 24+ extensibility points across build pipeline

**Sources**:
- [Webpack Plugins Concept](https://webpack.js.org/concepts/plugins/)
- [Building Custom Webpack Plugins - DigitalOcean](https://www.digitalocean.com/community/tutorials/js-create-custom-webpack-plugin)
- [Webpack Loaders and Plugins - Imran Sayed](https://imranhsayed.medium.com/webpack-loaders-and-plugins-e13f79fe6b32)

---

### 1.2 Visitor Pattern (AST Transformation)

**Core Concept**: Traverse abstract syntax tree, plugins register visitors for specific node types.

**Example: Babel**
```javascript
// Babel plugin using visitor pattern
export default function() {
  return {
    visitor: {
      Identifier(path) {
        // Transform identifier nodes
      },
      FunctionDeclaration(path) {
        // Transform function declarations
      }
    }
  };
}
```

**Architecture Flow**:
1. Configuration resolution (hierarchical discovery)
2. Parsing (code → AST)
3. AST transformation (visitor pattern)
4. Printing (AST → code)

**Benefits**:
- Separation of concerns
- Non-invasive to core
- Composable transformations

**Sources**:
- [Babel Plugin Handbook - Kent C. Dodds](https://github.com/kentcdodds/babel-plugin-handbook)
- [Configuration Loading and Merging - DeepWiki](https://deepwiki.com/babel/babel/4.1-configuration-loading-and-merging)
- [Babel Plugins Official Docs](https://babeljs.io/docs/plugins)

---

### 1.3 Hook/Registry Pattern

**Core Concept**: Plugins register callbacks at named hooks; core invokes them at specific lifecycle stages.

**Rollup Plugin Hooks**:

**Build Hooks** (run during scan):
- `resolveId`: Custom module resolution
- `load`: Load module content
- `transform`: Transform module code

**Output Hooks** (run during generate):
- `renderChunk`: Modify rendered chunks
- `generateBundle`: Access/modify bundle before write

**Hook Execution Control**:
- **Parallel**: Multiple plugins run simultaneously
- **Sequential**: Force serial execution with `sequential: true`
- **Filtering**: Run hooks conditionally with filter property

```javascript
export default function myPlugin() {
  return {
    name: 'my-plugin',
    resolveId(source) { /* resolve logic */ },
    load(id) { /* load logic */ },
    transform(code, id) { /* transform logic */ }
  };
}
```

**Vite Extension**: Rollup-compatible + Vite-specific hooks
- `configResolved`: Access final Vite config
- `configureServer`: Customize dev server
- `handleHotUpdate`: Custom HMR handling

**Sources**:
- [Rollup Plugin Development](https://rollupjs.org/plugin-development/)
- [Vite Plugin API](https://vite.dev/guide/api-plugin)
- [Rollup Plugin Hooks Lifecycle Issue](https://github.com/rollup/rollup/issues/3410)

---

### 1.4 Event-Driven Architecture

**Core Concept**: Core emits events; plugins subscribe to events of interest.

**VS Code Extension API**:
- Registration methods: `registerTaskProvider`, `registerCommand`, `registerTreeDataProvider`
- Document selectors for scoped activation: `{ language: 'typescript', scheme: 'file' }`
- Matching scores determine provider selection
- Asynchronous operations via Promises (Thenable-type)

**Pattern**: Register during activation, available in extension lifecycle

```typescript
export function activate(context: vscode.ExtensionContext) {
  context.subscriptions.push(
    vscode.commands.registerCommand('extension.myCommand', () => {
      // Command logic
    })
  );
}
```

**Sources**:
- [VS Code API Reference](https://code.visualstudio.com/api/references/vscode-api)
- [Extension Capabilities Overview](https://code.visualstudio.com/api/extension-capabilities/overview)
- [Patterns and Principles - VS Code Docs](https://vscode-docs.readthedocs.io/en/stable/extensions/patterns-and-principles/)

---

## 2. Auto-Discovery Mechanisms

### 2.1 Filesystem Conventions

**Principle**: File location and naming determine behavior without explicit config.

#### **GitHub Actions** (Strict Convention)
```
.github/
  workflows/       # REQUIRED directory
    ci.yml         # Auto-discovered
    deploy.yaml    # Auto-discovered
    test.yml       # Auto-discovered
```

**Rules**:
- Workflows MUST be in `.github/workflows`
- Subdirectories NOT supported
- Files MUST have `.yml` or `.yaml` extension
- Discovery triggers on events (commit SHA or Git ref)
- Actions (reusable units) can live elsewhere: `.github/actions/`

**Sources**:
- [GitHub Actions Workflows - GitHub Docs](https://docs.github.com/en/actions/concepts/workflows-and-actions/workflows)
- [Workflow Syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)

---

#### **Nuxt Layers** (Zero-Config Discovery)
```
~/
  layers/          # Auto-scanned directory
    auth/          # Auto-registered layer
      nuxt.config.ts
      components/
      composables/
    ui/            # Auto-registered layer
      nuxt.config.ts
      components/
```

**Rules**:
- Layers in `~~/layers` automatically registered
- Each layer MUST have `nuxt.config.ts` to indicate it's a layer
- Layer structure mirrors standard Nuxt app
- Auto-scanned files: components, composables, pages, plugins

**Manual Extension** (optional):
```javascript
// nuxt.config.ts
export default {
  extends: [
    './layers/base',           // Local path
    '@company/nuxt-layer',     // npm package
    'github:user/repo#branch'  // Git repo
  ]
}
```

**Sources**:
- [Nuxt Layers Documentation](https://nuxt.com/docs/4.x/getting-started/layers)
- [Authoring Nuxt Layers](https://nuxt.com/docs/4.x/guide/going-further/layers)
- [Nuxt Layers Unwrapped - Krutie Patel](https://krutiepatel.com/blog/nuxt-layers-unwrapped)

---

#### **Next.js App Directory** (File-Based Routing)
```
app/
  page.tsx            # Route root: /
  layout.tsx          # Layout for entire app
  loading.tsx         # Loading UI
  error.tsx           # Error boundary
  api/
    route.ts          # API endpoint: /api
  blog/
    page.tsx          # Route: /blog
    [slug]/
      page.tsx        # Dynamic route: /blog/:slug
    [...slug]/
      page.tsx        # Catch-all: /blog/*
  (marketing)/        # Route group (not in URL)
    about/
      page.tsx        # Route: /about (not /marketing/about)
```

**Special Files**:
- `page.tsx`: Expose route (required for public access)
- `layout.tsx`: Shared UI (header, nav, footer)
- `loading.tsx`: Loading skeletons
- `error.tsx`: Error boundaries
- `route.ts`: API endpoints

**Conventions**:
- `[segment]`: Single dynamic param
- `[...segment]`: Catch-all
- `[[...segment]]`: Optional catch-all
- `(folderName)`: Route group (organizational, excluded from URL)

**Sources**:
- [Next.js Project Structure](https://nextjs.org/docs/app/getting-started/project-structure)
- [Next.js File Conventions](https://nextjs.org/docs/app/api-reference/file-conventions)
- [Inside the App Router - Melvin Prince](https://medium.com/better-dev-nextjs-react/inside-the-app-router-best-practices-for-next-js-file-and-directory-structure-2025-edition-ed6bc14a8da3)

---

### 2.2 Naming Conventions

**Principle**: Prefix/suffix indicates plugin type, enabling programmatic discovery.

#### **npm Ecosystem Patterns**

**Vite Plugins**:
- Format: `vite-plugin-{name}`
- Example: `vite-plugin-vue`, `vite-plugin-react`
- package.json: Include `vite-plugin` keyword
- Discovery: `npm search vite-plugin`

**Rollup Plugins**:
- Format: `rollup-plugin-{name}`
- Example: `rollup-plugin-babel`, `rollup-plugin-terser`
- package.json: Include `rollup-plugin` keyword (also `vite-plugin` for dual compatibility)
- Discovery: `npm search rollup-plugin`

**PostCSS Plugins**:
- Format: `postcss-{name}`
- Example: `postcss-custom-media`, `postcss-nesting`
- Purpose must be clear from name alone
- Shows ecosystem membership

**ESLint Plugins**:
- Format: `eslint-plugin-{name}`
- Example: `eslint-plugin-react`, `eslint-plugin-vue`
- Rules automatically prefixed with plugin namespace

**Prettier Plugins**:
- Format: `prettier-plugin-{name}`
- Example: `prettier-plugin-organize-attributes`
- Shared configs: `@username/prettier-config` (scoped package)

**Sources**:
- [Vite Using Plugins](https://vite.dev/guide/using-plugins)
- [PostCSS Plugin Guidelines](https://postcss.org/docs/postcss-plugin-guidelines)
- [ESLint Configure Plugins](https://eslint.org/docs/latest/use/configure/plugins)
- [Prettier Plugins](https://prettier.io/docs/plugins)

---

### 2.3 Manifest-Based Discovery

**Principle**: Metadata files declare plugin capabilities and contracts.

#### **package.json Extensions**

**VS Code Extension Manifest**:
```json
{
  "name": "my-extension",
  "version": "1.0.0",
  "engines": {
    "vscode": "^1.74.0"
  },
  "activationEvents": [
    "onLanguage:javascript",
    "onCommand:extension.myCommand"
  ],
  "contributes": {
    "commands": [{
      "command": "extension.myCommand",
      "title": "My Command"
    }],
    "languages": [{
      "id": "mylang",
      "extensions": [".ml"]
    }]
  },
  "main": "./out/extension.js"
}
```

**Key Fields**:
- `engines.vscode`: Minimum VS Code version
- `activationEvents`: When to activate
- `contributes`: What plugin provides (commands, languages, views, etc.)
- `main`: Entry point

**Sources**:
- [VS Code Extension Manifest](https://code.visualstudio.com/api/references/extension-manifest)

---

**package.json Exports Field** (Modern Module Resolution):
```json
{
  "name": "my-plugin",
  "version": "1.0.0",
  "main": "./dist/index.cjs",          // Legacy CommonJS
  "module": "./dist/index.mjs",        // ESM (deprecated, use exports)
  "exports": {
    ".": {
      "import": "./dist/index.mjs",    // ESM import
      "require": "./dist/index.cjs"    // CommonJS require
    },
    "./package.json": "./package.json"
  },
  "type": "module"
}
```

**Benefits**:
- Explicit entry points
- Dual CJS/ESM support
- Subpath exports
- Conditional exports (development/production)

**Sources**:
- [Yarn Manifest Documentation](https://yarnpkg.com/configuration/manifest)
- [MDN manifest.json](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json)

---

#### **Argo CD Config Management Plugin Discovery**

```yaml
# /home/argocd/cmp-server/config/plugin.yaml
apiVersion: argoproj.io/v1alpha1
kind: ConfigManagementPlugin
metadata:
  name: my-plugin
spec:
  version: v1.0
  discover:
    fileName: "kustomization.yaml"    # Glob pattern for detection
    find:
      command: ["sh", "-c", "test -f package.json && echo 'found'"]
  generate:
    command: ["sh", "-c", "kustomize build ."]
```

**Discovery Methods**:
1. **fileName**: Glob pattern (e.g., `kustomization.yaml`, `*.tf`)
2. **find.command**: Execute command, non-zero exit = not supported

**Convention**: Plugin config at fixed path `/home/argocd/cmp-server/config/plugin.yaml`

**Sources**:
- [Argo CD Config Management Plugins](https://argo-cd.readthedocs.io/en/stable/operator-manual/config-management-plugins/)

---

### 2.4 Dependency-Based Auto-Loading

**Principle**: Detect installed packages, load corresponding plugins automatically.

#### **eslint-config-auto**

```javascript
// Automatically configures ESLint based on package.json dependencies
// If project has "react" → loads eslint-plugin-react
// If project has "vue" → loads eslint-plugin-vue
// If project has "typescript" → loads @typescript-eslint
```

**How It Works**:
1. Read project's `package.json`
2. Check `dependencies` and `devDependencies`
3. Match library names to known plugin mappings
4. Load and configure plugins automatically

**Benefits**:
- True zero-config for common cases
- Scales with project evolution
- No manual plugin list maintenance

**Limitation**: Only works for known libraries with established plugin mappings

**Sources**:
- [eslint-config-auto - GitHub](https://github.com/davidjbradshaw/eslint-config-auto)

---

#### **Prettier 3 Change: Removed Auto-Discovery**

**Before Prettier 3**: Plugins auto-discovered from node_modules
**After Prettier 3**: Explicit configuration required

```javascript
// .prettierrc.js
export default {
  plugins: ['prettier-plugin-organize-imports']
  // String passed to import() - can be module name, path, etc.
};
```

**Rationale**: Explicit over implicit for predictability and performance

**Sources**:
- [Prettier Plugins](https://prettier.io/docs/plugins)
- [Prettier Configuration System - DeepWiki](https://deepwiki.com/prettier/prettier/2.3-configuration-system)

---

### 2.5 Workspace Protocol (Monorepo Discovery)

**Principle**: Link local packages via `workspace:` protocol instead of npm registry.

#### **pnpm Workspaces**

```yaml
# pnpm-workspace.yaml
packages:
  - 'packages/*'
  - 'plugins/*'
  - 'apps/*'
```

```json
// packages/plugin-a/package.json
{
  "name": "@org/plugin-a",
  "version": "1.0.0",
  "dependencies": {
    "@org/plugin-b": "workspace:*"     // Link to local package
  }
}
```

**Discovery Flow**:
1. `readWorkspaceManifest()` reads `pnpm-workspace.yaml`
2. `find-workspace-packages` matches globs against filesystem
3. Each directory with `package.json` becomes workspace package
4. `workspace:` protocol resolves to local packages (symlink/copy)

**Catalog Protocol** (centralized version management):
```yaml
# pnpm-workspace.yaml
catalog:
  react: ^18.2.0
  typescript: ^5.0.0
```

```json
{
  "dependencies": {
    "react": "catalog:",
    "typescript": "catalog:"
  }
}
```

**Sources**:
- [pnpm Workspaces](https://pnpm.io/workspaces)
- [pnpm Workspace and Catalog Support - DeepWiki](https://deepwiki.com/pnpm/pnpm/3.2-workspace-support)
- [Bun Workspaces Guide](https://bun.com/docs/guides/install/workspaces)

---

#### **npm/Yarn Workspaces**

```json
// package.json (root)
{
  "workspaces": [
    "packages/*",
    "plugins/*"
  ]
}
```

**Resolution Strategy**:
- **Hoisting**: Common dependencies lifted to root `node_modules`
- **Deduplication**: Same package/version used across workspaces → single copy
- Per-workspace `node_modules` for unique dependencies

**Sources**:
- [npm Workspaces Guide - Leticia Mirelly](https://leticia-mirelly.medium.com/a-comprehensive-guide-to-npm-workspaces-and-monorepos-ce0cdfe1c625)
- [TypeScript Monorepo with npm Workspaces](https://yieldcode.blog/post/npm-workspaces/)

---

## 3. Extension Points and Contracts

### 3.1 Lifecycle Hooks

**Principle**: Defined stages in processing pipeline where plugins can intervene.

#### **Rollup Plugin Lifecycle**

**Build Phase**:
1. `options`: Modify input options
2. `buildStart`: Called when build starts
3. `resolveId`: Resolve module ID
4. `load`: Load module content
5. `transform`: Transform module code
6. `moduleParsed`: Called after module is parsed
7. `buildEnd`: Called when build ends

**Output Phase**:
1. `outputOptions`: Modify output options
2. `renderStart`: Called when rendering starts
3. `renderChunk`: Transform rendered chunks
4. `generateBundle`: Access/modify bundle before write
5. `writeBundle`: Called after bundle is written
6. `closeBundle`: Called when bundler finishes

**Hook Execution Ordering**:
- `pre`: Run before normal hooks
- `normal`: Default (no order property)
- `post`: Run after normal hooks

**Sources**:
- [Rollup Plugin Development](https://rollupjs.org/plugin-development/)
- [Rolldown Plugin System - DeepWiki](https://deepwiki.com/rolldown/rolldown)

---

#### **PostCSS Plugin Pipeline**

```javascript
export default {
  postcssPlugin: 'my-plugin',
  Once(root, { result }) {
    // Called once per CSS file
  },
  Declaration(decl) {
    // Called for each CSS declaration
  },
  AtRule: {
    'media': (atRule) => {
      // Called for @media rules
    }
  }
}
```

**Hooks**:
- `Once`: Execute once per file
- `Root`: Root node of AST
- `AtRule`: CSS at-rules (@media, @import, etc.)
- `Rule`: CSS rules
- `Declaration`: CSS declarations

**Sources**:
- [PostCSS Plugin Guidelines](https://postcss.org/docs/postcss-plugin-guidelines)
- [What is PostCSS? - freeCodeCamp](https://www.freecodecamp.org/news/what-is-postcss/)

---

### 3.2 API Contracts

**Principle**: Plugin must expose specific interface for core to recognize it.

#### **Vite Plugin Contract**

```typescript
interface Plugin {
  name: string                    // REQUIRED
  enforce?: 'pre' | 'post'        // Execution order
  apply?: 'serve' | 'build'       // When to apply
  config?: (config) => UserConfig | null
  configResolved?: (config: ResolvedConfig) => void
  configureServer?: (server: ViteDevServer) => void
  transformIndexHtml?: (html: string) => string
  handleHotUpdate?: (ctx: HmrContext) => void
  // ... Rollup hooks (resolveId, load, transform, etc.)
}
```

**Rollup-Compatible Hooks**: `resolveId`, `load`, `transform`, `renderChunk`, `generateBundle`
**Vite-Specific Hooks**: `config`, `configResolved`, `configureServer`, `handleHotUpdate`

**Sources**:
- [Vite Plugin API](https://vite.dev/guide/api-plugin)
- [Building a Plugin with Vite - Vue Mastery](https://www.vuemastery.com/blog/building-a-plugin-with-vite/)

---

#### **Babel Plugin Contract**

```javascript
export default function(babel) {
  const { types: t } = babel;
  return {
    name: "my-plugin",
    visitor: {
      Identifier(path, state) {
        // Transform identifier nodes
      }
    },
    pre(state) {
      // Called before traversal
    },
    post(state) {
      // Called after traversal
    }
  };
}
```

**Required**:
- Function returning object with `visitor`
- Visitor methods match AST node types

**Optional**:
- `name`: Plugin identifier
- `pre`/`post`: Lifecycle hooks
- `manipulateOptions`: Modify parser options

**Sources**:
- [Babel Plugin Handbook - Jamie Builds](https://github.com/jamiebuilds/babel-handbook)
- [What is Babel and How Does It Work? - Mohammad Taheri](https://mohammadtaheri.medium.com/what-is-babel-and-how-does-it-work-2cd18311980d)

---

### 3.3 Virtual Modules

**Principle**: Plugins can create modules that don't exist on filesystem.

#### **Rollup Virtual Module Convention**

```javascript
export default function virtualPlugin() {
  return {
    name: 'virtual',
    resolveId(id) {
      if (id === 'virtual:config') {
        return '\0virtual:config';  // Prefix with \0 for internal
      }
      return null;
    },
    load(id) {
      if (id === '\0virtual:config') {
        return 'export default { foo: "bar" }';
      }
      return null;
    }
  };
}
```

**Convention**:
- **Internal ID**: Prefix with `\0` (null byte) to prevent other plugins from processing
- **User-facing ID**: Prefix with `virtual:` by convention

**Use Cases**:
- Inject runtime config
- Generate code on-the-fly
- Create helper modules without filesystem

**Sources**:
- [Vite Plugin API](https://vite.dev/guide/api-plugin)
- [Rollup Plugin Development](https://rollupjs.org/plugin-development/)

---

## 4. Namespace and Scoping Strategies

### 4.1 Plugin Namespace Prefixing

**Principle**: Prevent collisions by prefixing plugin-provided names with plugin identifier.

#### **ESLint Namespacing**

```javascript
// eslint-plugin-react
module.exports = {
  rules: {
    'jsx-uses-vars': { /* ... */ },
    'no-unused-prop-types': { /* ... */ }
  }
};

// Usage in config
{
  "rules": {
    "react/jsx-uses-vars": "error",      // Auto-prefixed with plugin name
    "react/no-unused-prop-types": "warn"
  }
}
```

**Behavior**:
- All rules auto-prefixed with plugin namespace (`react/`, `vue/`, etc.)
- Duplicate namespace+ID → ESLint errors and exits immediately
- Prevents rule name collisions across plugins

**Sources**:
- [ESLint Configure Plugins](https://eslint.org/docs/latest/use/configure/plugins)

---

### 4.2 Scoped Packages (npm)

**Principle**: Use `@org/package-name` to avoid global namespace pollution.

```json
{
  "name": "@company/eslint-config",
  "name": "@company/prettier-plugin-sort",
  "name": "@company/vite-plugin-custom"
}
```

**Benefits**:
- Avoid name squatting
- Organizational ownership
- Package collections under single scope

**Sources**:
- [Prettier Sharing Configurations](https://prettier.io/docs/sharing-configurations)

---

### 4.3 PHP-Scoper (Dependency Isolation)

**Problem**: Multiple plugins using same library, different versions → conflicts

**Solution**: Prefix all namespaces in dependencies with unique scope

```php
// Before scoping
use Symfony\Component\Finder\Finder;

// After scoping
use MyPluginPrefix\Symfony\Component\Finder\Finder;
```

**Workflow**:
1. Install dependencies via Composer
2. Run PHP-Scoper to prefix all namespaces
3. Autoloader recognizes prefixed classes
4. Multiple plugins can use different versions of same library

**Tools**:
- PHP-Scoper: Rewrites namespaces
- Package Scoper (Symplify): Automated workflow

**Sources**:
- [How to Use PhpScoper in WordPress Plugins - Jacob Graham](https://jacob-t-graham.com/2025/09/12/how-to-use-phpscoper-in-wordpress-plugins-to-remedy-namespace-collisions/)
- [WordPress Plugin Conflicts - Pressidium](https://pressidium.com/blog/wordpress-plugin-conflicts-how-to-prevent-composer-dependency-hell/)
- [Package Scoper - Symplify GitHub](https://github.com/symplify/package-scoper)

---

### 4.4 Document Selectors (VS Code)

**Principle**: Scope plugin activation to specific file types, schemes, or patterns.

```typescript
// Simple: Language ID
vscode.languages.registerCompletionItemProvider('javascript', provider);

// Complex: Multi-criteria filter
const selector: vscode.DocumentSelector = {
  language: 'typescript',
  scheme: 'file',           // file:// URIs only (not git://, etc.)
  pattern: '**/*.test.ts'   // Only test files
};
vscode.languages.registerCompletionItemProvider(selector, provider);
```

**Matching Scores**: VS Code calculates match score for each provider, highest score wins

**Sources**:
- [VS Code API Reference](https://code.visualstudio.com/api/references/vscode-api)

---

## 5. Versioning Strategies

### 5.1 Semantic Versioning (SemVer)

**Format**: `MAJOR.MINOR.PATCH` (e.g., `2.3.1`)

**Rules**:
- **PATCH** (`2.3.1` → `2.3.2`): Bug fixes, no API changes
- **MINOR** (`2.3.0` → `2.4.0`): New features, backward compatible
- **MAJOR** (`2.0.0` → `3.0.0`): Breaking changes

**What's Breaking**:
- API signature changes (parameters, return types)
- Behavior changes that break existing code
- Dependency version updates (peer dependencies)
- Dropping runtime/browser support
- Removing features

**What's Not Breaking**:
- Internal refactoring
- Performance improvements
- Adding new optional parameters (with defaults)
- New features that don't affect existing code

**Sources**:
- [Semantic Versioning 2.0.0](https://semver.org/)
- [SemVer Compatibility - Cargo Book](https://doc.rust-lang.org/cargo/reference/semver.html)
- [Using Semantic Versioning - AWS DevOps Blog](https://aws.amazon.com/blogs/devops/using-semantic-versioning-to-simplify-release-management/)

---

### 5.2 Version Ranges (npm)

```json
{
  "dependencies": {
    "exact": "1.2.3",           // Exact version
    "patch": "~1.2.3",          // >=1.2.3 <1.3.0 (patch updates)
    "minor": "^1.2.3",          // >=1.2.3 <2.0.0 (minor updates)
    "latest": "*"               // Any version (dangerous)
  },
  "peerDependencies": {
    "vite": "^5.0.0"            // Compatible Vite versions
  }
}
```

**Best Practices**:
- Use `^` for dependencies (allow minor/patch)
- Use exact versions for production deployments
- Specify `peerDependencies` for plugin host requirements

**Sources**:
- [SemVer Versioning - Pavlik Kiselev](https://medium.com/ing-blog/semver-versioning-c2d1ffd77446)

---

### 5.3 Engine Constraints

**Specify minimum host version for compatibility**:

```json
{
  "engines": {
    "node": ">=18.0.0",
    "vscode": "^1.74.0",
    "npm": ">=8.0.0"
  }
}
```

**Benefits**:
- Prevent installation on incompatible systems
- Document runtime requirements
- CI/CD validation

**Sources**:
- [VS Code Extension Manifest](https://code.visualstudio.com/api/references/extension-manifest)

---

### 5.4 API Versioning in Manifests

```yaml
# Argo CD Plugin
apiVersion: argoproj.io/v1alpha1
kind: ConfigManagementPlugin
spec:
  version: v1.0
```

**Strategies**:
- **apiVersion**: API contract version (e.g., `v1alpha1`, `v1`, `v2`)
- **spec.version**: Plugin implementation version
- Allows breaking changes in new API versions while supporting old

**Sources**:
- [Argo CD Config Management Plugins](https://argo-cd.readthedocs.io/en/stable/operator-manual/config-management-plugins/)

---

## 6. Real-World Examples

### 6.1 Astro Integrations (Zero-Config)

**Auto-Loading Mechanisms** (2025):
- **Astro Auto Load**: Component-level data loading for SSR
- **Astro Auto Alias**: Path aliases generated from project structure
- **Astro Add Command**: Automated setup wizard for integrations

```bash
# Automated installation
npx astro add react
npx astro add tailwind

# Manual configuration
import react from '@astrojs/react';
export default {
  integrations: [react()]
};
```

**Convention**: Integrations export a function that returns integration object

**Sources**:
- [Astro Add Integrations Guide](https://docs.astro.build/en/guides/integrations-guide/)
- [Astro Integration API](https://docs.astro.build/en/reference/integrations-reference/)
- [What's New in Astro - December 2025](https://astro.build/blog/whats-new-december-2025/)

---

### 6.2 Vite Plugin Discovery

**Naming Convention**: `vite-plugin-{name}`
**Discovery**: `npm search vite-plugin`

```javascript
// vite.config.js
import vue from '@vitejs/plugin-vue';
import react from '@vitejs/plugin-react';
import customPlugin from './plugins/custom-plugin.js';

export default {
  plugins: [
    vue(),
    react(),
    customPlugin()
  ]
};
```

**Plugin Execution Order**:
- `enforce: 'pre'`: Run before core plugins
- (default): Run in registration order
- `enforce: 'post'`: Run after core plugins

**Conditional Application**:
- `apply: 'serve'`: Dev server only
- `apply: 'build'`: Production build only
- `apply: (config, env) => boolean`: Custom logic

**Sources**:
- [Vite Using Plugins](https://vite.dev/guide/using-plugins)
- [Vite Plugin API](https://vite.dev/guide/api-plugin)

---

### 6.3 PostCSS Plugin Loading

```javascript
// postcss.config.mjs (MUST be in project root, MUST be named exactly this)
export default {
  plugins: [
    'postcss-nesting',        // Package name (no path needed if installed)
    'postcss-custom-media',
    './local-plugin.js'       // Local plugin path
  ]
};
```

**Discovery**:
- Config file MUST be `postcss.config.mjs` or `postcss.config.js` in root
- Plugins installed in `node_modules` auto-resolved by name
- Local plugins referenced by relative path

**Sources**:
- [PostCSS Plugin Guidelines](https://postcss.org/docs/postcss-plugin-guidelines)
- [CodeKit Custom PostCSS Plugins](https://codekitapp.com/help/postcss/)

---

### 6.4 ESLint Flat Config (Modern)

**Old (eslintrc)**:
```json
{
  "plugins": ["react", "vue"],
  "extends": ["eslint:recommended", "plugin:react/recommended"]
}
```

**New (Flat Config)**:
```javascript
// eslint.config.js
import js from '@eslint/js';
import react from 'eslint-plugin-react';
import vue from 'eslint-plugin-vue';

export default [
  js.configs.recommended,
  {
    plugins: { react },
    rules: {
      'react/jsx-uses-vars': 'error'
    }
  },
  {
    plugins: { vue },
    rules: {
      'vue/no-unused-vars': 'error'
    }
  }
];
```

**Key Changes**:
- Use `import` instead of string-based loading
- Explicit plugin objects instead of name-based discovery
- Flat array of configs instead of cascading extends

**Sources**:
- [ESLint Flat Config Introduction](https://eslint.org/blog/2022/08/new-config-system-part-2/)
- [ESLint Configuration Files](https://eslint.org/docs/latest/use/configure/configuration-files)

---

### 6.5 Dynamic Import Plugin Loading

**Principle**: Load plugins at runtime based on conditions, not at build time.

#### **Python (stevedore)**

```python
from stevedore import driver

# Load plugin by name from entry point
mgr = driver.DriverManager(
    namespace='myapp.formatters',
    name='json',
    invoke_on_load=True,
)
mgr.driver.format(data)
```

**Entry Point Registration** (setup.py):
```python
setup(
    entry_points={
        'myapp.formatters': [
            'json = myapp.json_formatter:JSONFormatter',
            'yaml = myapp.yaml_formatter:YAMLFormatter',
        ]
    }
)
```

**Discovery**: `pkg_resources` scans installed packages for registered entry points

**Sources**:
- [stevedore Documentation](https://docs.openstack.org/stevedore/ocata/)
- [Dynamic Code Patterns - stevedore Essays](https://docs.openstack.org/stevedore/latest/user/essays/pycon2013.html)

---

#### **JavaScript/Webpack**

```javascript
// Dynamic import returns Promise
import('module/foo').then(foo => {
  console.log(foo.default);
});

// Strategy pattern: choose module at runtime
const loader = condition ? 'loaderA' : 'loaderB';
import(`./loaders/${loader}`).then(module => {
  module.process(data);
});
```

**Webpack Behavior**: Creates separate chunks for each dynamic import

**Sources**:
- [Webpack and Dynamic Imports - Rubens Pinheiro](https://medium.com/front-end-weekly/webpack-and-dynamic-imports-doing-it-right-72549ff49234)
- [Dynamic Import - Patterns.dev](https://www.patterns.dev/vanilla/dynamic-import/)

---

## 7. Best Practices for Extensibility

### 7.1 Zero-Config Design Principles

**1. Convention Over Configuration**
- Use filesystem location to determine behavior
- Standardize naming patterns
- Default to sensible behaviors

**2. Make Discovery Explicit and Inspectable**
- Provide CLI commands to list discovered plugins
- Log plugin loading process
- Debug mode to trace discovery

**3. Configuration as Escape Hatch**
- Zero-config for 90% use case
- Config available for advanced scenarios
- Don't force config for basic usage

**Sources**:
- [Zero-Config Backends - ThinhDA](https://thinhdanggroup.github.io/zero-config-backend-rikta/)
- [Argo CD Config Management Plugins](https://argo-cd.readthedocs.io/en/stable/operator-manual/config-management-plugins/)

---

### 7.2 Non-Breaking Addition Strategies

**1. Additive-Only Changes**
- Add new hooks without modifying existing ones
- New optional parameters with defaults
- New plugins in separate namespaces

**2. Deprecation Workflow**
- Deprecate → Warn → Remove (across major versions)
- Runtime warnings for deprecated APIs
- Migration guides and codemods

**3. Feature Flags**
```javascript
export default {
  experimental: {
    newFeature: true
  }
};
```

**4. Versioned Extension Points**
```javascript
// Support both v1 and v2 plugin APIs
if (plugin.version === 2) {
  // Use new API
} else {
  // Use legacy API
}
```

**Sources**:
- [Semantic Versioning 2.0.0](https://semver.org/)
- [Understand What Semantic Versioning Promises - Effective Rust](https://effective-rust.com/semver.html)

---

### 7.3 Plugin Isolation

**1. Namespace Scoping**
- Prefix plugin names
- Scoped npm packages
- PHP-Scoper for dependencies

**2. Sandboxing**
- Limit plugin access to specific APIs
- Capability-based security
- Plugin runs in separate process/worker

**3. Dependency Management**
- `peerDependencies` for shared dependencies
- Scoped dependencies for plugin-specific versions
- Workspace protocol in monorepos

**Sources**:
- [WordPress Plugin Conflicts - Pressidium](https://pressidium.com/blog/wordpress-plugin-conflicts-how-to-prevent-composer-dependency-hell/)
- [pnpm Workspaces](https://pnpm.io/workspaces)

---

### 7.4 Documentation and DX

**1. Clear Plugin Contract**
- TypeScript interfaces
- JSON Schema for manifests
- API reference documentation

**2. Plugin Starter Templates**
```bash
npm create vite-plugin my-plugin
npm create eslint-plugin my-plugin
```

**3. Testing Utilities**
- Test harness for plugin hooks
- Fixture generators
- Snapshot testing for output

**4. Error Messages**
- Clear error when plugin contract violated
- Suggest fixes for common mistakes
- Link to documentation

**Sources**:
- [Vite Plugin API](https://vite.dev/guide/api-plugin)
- [ESLint Plugin Development](https://eslint.org/docs/latest/extend/plugins)

---

## 8. Architecture Decision Summary

### For Nancy Bubble Gum: Recommended Approach

**Discovery Mechanism**:
```
fragments/
  languages/
    go.yaml              # Auto-discovered by filename
    rust.yaml
  frameworks/
    svelte.yaml
    vue.yaml
  workflows/
    github-actions.yaml
    gitlab-ci.yaml
```

**Naming Convention**:
- Filename = fragment identifier (e.g., `go.yaml` → `go` fragment)
- Subdirectory = category (language, framework, workflow)
- Manifest format: YAML or JSON

**Manifest Contract**:
```yaml
# fragments/languages/go.yaml
apiVersion: nancy/v1
kind: LanguageFragment
metadata:
  name: go
  version: 1.0.0
spec:
  extensions: ['.go', '.mod', '.sum']
  templates:
    - name: handler
      path: ./templates/handler.go.hbs
  hooks:
    onAnalyze: ./hooks/analyze.js
    onGenerate: ./hooks/generate.js
```

**Hooks/Extension Points**:
- `onAnalyze`: Extract repo context for this language
- `onGenerate`: Generate code for this language
- `onValidate`: Validate generated output
- `onTest`: Run tests for generated code

**Namespace Scoping**:
- Fragment name = namespace (e.g., `go:handler`, `vue:component`)
- Prevents template name collisions
- Category prefix optional: `languages/go:handler`

**Versioning**:
- Fragment version in manifest (`version: 1.0.0`)
- API version in manifest (`apiVersion: nancy/v1`)
- Breaking changes → new API version (`nancy/v2`)

**Zero-Config Discoverability**:
1. Scan `fragments/` directory recursively
2. Find all `*.yaml` or `*.json` files
3. Parse manifest, validate against schema
4. Register fragment in registry
5. Load hooks dynamically via `import()`

**Non-Breaking Additions**:
- New fragments in `fragments/` auto-discovered
- New hooks optional (check if defined before calling)
- New manifest fields optional with defaults
- Deprecation: warn → remove across versions

---

## Sources

This research synthesized information from 50+ sources across modern build tools, frameworks, editors, and plugin ecosystems. Key sources include:

### Build Tools & Bundlers
- [Webpack Plugins Concept](https://webpack.js.org/concepts/plugins/)
- [Babel Plugin Handbook - Kent C. Dodds](https://github.com/kentcdodds/babel-plugin-handbook)
- [Rollup Plugin Development](https://rollupjs.org/plugin-development/)
- [Vite Plugin API](https://vite.dev/guide/api-plugin)
- [PostCSS Plugin Guidelines](https://postcss.org/docs/postcss-plugin-guidelines)
- [Prettier Plugins](https://prettier.io/docs/plugins)

### Code Quality Tools
- [ESLint Configure Plugins](https://eslint.org/docs/latest/use/configure/plugins)
- [ESLint Flat Config Introduction](https://eslint.org/blog/2022/08/new-config-system-part-2/)

### Frameworks
- [Next.js Project Structure](https://nextjs.org/docs/app/getting-started/project-structure)
- [Nuxt Layers Documentation](https://nuxt.com/docs/4.x/getting-started/layers)
- [Astro Integration API](https://docs.astro.build/en/reference/integrations-reference/)

### Editors & IDEs
- [VS Code Extension API](https://code.visualstudio.com/api/references/vscode-api)
- [VS Code Extension Manifest](https://code.visualstudio.com/api/references/extension-manifest)

### CI/CD & Deployment
- [GitHub Actions Workflows - GitHub Docs](https://docs.github.com/en/actions/concepts/workflows-and-actions/workflows)
- [Argo CD Config Management Plugins](https://argo-cd.readthedocs.io/en/stable/operator-manual/config-management-plugins/)

### Package Management
- [pnpm Workspaces](https://pnpm.io/workspaces)
- [Semantic Versioning 2.0.0](https://semver.org/)
- [npm Workspaces Guide - Leticia Mirelly](https://leticia-mirelly.medium.com/a-comprehensive-guide-to-npm-workspaces-and-monorepos-ce0cdfe1c625)

### Dynamic Loading & Runtime Discovery
- [stevedore Documentation - OpenStack](https://docs.openstack.org/stevedore/ocata/)
- [Webpack and Dynamic Imports - Rubens Pinheiro](https://medium.com/front-end-weekly/webpack-and-dynamic-imports-doing-it-right-72549ff49234)
- [Dynamic Import - Patterns.dev](https://www.patterns.dev/vanilla/dynamic-import/)

### Namespace & Scoping
- [WordPress Plugin Conflicts - Pressidium](https://pressidium.com/blog/wordpress-plugin-conflicts-how-to-prevent-composer-dependency-hell/)
- [How to Use PhpScoper in WordPress Plugins - Jacob Graham](https://jacob-t-graham.com/2025/09/12/how-to-use-phpscoper-in-wordpress-plugins-to-remedy-namespace-collisions/)

---

**End of Research Document**
