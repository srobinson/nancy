# Nancy Internal Prompt System - API Design

**Date**: 2026-01-24
**Status**: Implementation Spec

---

## Philosophy

Build it **FOR Nancy**, not as a generic tool. Get Nancy working, extract patterns later.

---

## Directory Structure

```
nancy/
├── src/
│   └── prompts/
│       ├── index.ts             # Public API
│       ├── assemble.ts          # Assembly engine
│       ├── context.ts           # Context loading (user, project, detected)
│       ├── templates.ts         # Template loading
│       ├── interpolate.ts       # Variable interpolation
│       └── types.ts             # TypeScript types
│
├── prompts/                     # Shipped with Nancy
│   ├── core.principles.md
│   ├── user.identity.md
│   ├── eng.typescript.md
│   ├── eng.go.md
│   ├── eng.python.md
│   ├── workflow.linear.md
│   ├── workflow.nancy-issues.md
│   └── _catalog.yaml            # Template metadata/catalog
│
└── ~/.nancy/                    # User directory
    ├── config.yaml             # User preferences
    └── projects/
        └── nancy.yaml          # Project-specific context
```

---

## Public API

```typescript
// src/prompts/index.ts

import { assemblePrompt } from './assemble'

/**
 * Assemble a prompt for Nancy worker execution
 */
export async function assembleWorkerPrompt(options: {
  project: string           // Project name (e.g., 'nancy', 'bubble-gum')
  issue?: LinearIssue       // Current Linear issue (optional)
  cwd?: string             // Working directory (default: process.cwd())
}): Promise<AssembledPrompt>

/**
 * Assemble a prompt for Nancy planner mode
 */
export async function assemblePlannerPrompt(options: {
  project: string
  task: string             // Task description
  cwd?: string
}): Promise<AssembledPrompt>

/**
 * Get available templates
 */
export async function listTemplates(options?: {
  domain?: string          // Filter by domain (eng, workflow, etc.)
}): Promise<Template[]>

/**
 * Validate user config
 */
export async function validateConfig(
  configPath: string
): Promise<ValidationResult>
```

### Types

```typescript
// src/prompts/types.ts

export interface AssembledPrompt {
  content: string                    // Full assembled prompt
  metadata: {
    templates: TemplateUsed[]        // Which templates were used
    context: ContextUsed             // What context was loaded
    assembledAt: string              // ISO timestamp
    cacheKey: string                 // Hash for caching
  }
}

export interface TemplateUsed {
  id: string                         // e.g., 'core.principles'
  file: string                       // Path to template file
  priority: number                   // Assembly order
}

export interface ContextUsed {
  user?: UserContext                 // User preferences (if configured)
  project?: ProjectContext           // Project context
  detected: DetectedContext          // Auto-detected info
}

export interface UserContext {
  name: string
  role?: string
  preferences?: {
    codeReview?: 'minimal' | 'moderate' | 'thorough'
    testing?: 'minimal' | 'standard' | 'comprehensive'
    documentation?: 'minimal' | 'standard' | 'extensive'
  }
}

export interface ProjectContext {
  name: string
  type: 'production' | 'poc' | 'prototype' | 'library'
  techStack?: {
    languages: string[]
    frameworks: string[]
    tools: string[]
  }
  patterns?: string[]              // Coding patterns/preferences
  constraints?: string[]           // Project constraints
}

export interface DetectedContext {
  language: string | string[]      // Auto-detected from files
  framework?: string | string[]    // Auto-detected from package.json
  git: {
    branch: string
    worktrees: boolean
  }
}

export interface Template {
  id: string                       // e.g., 'eng.typescript'
  domain: string                   // e.g., 'eng'
  category: string                 // e.g., 'lang'
  name: string                     // e.g., 'typescript'
  file: string                     // Path to .md file
  priority: number                 // Default priority
  description?: string
}
```

---

## Internal Flow

### 1. Load Context

```typescript
// src/prompts/context.ts

async function loadContext(options: {
  project: string
  cwd: string
}): Promise<ContextUsed> {
  // 1. Try to load user config from ~/.nancy/config.yaml
  const user = await loadUserConfig().catch(() => undefined)

  // 2. Try to load project config from ~/.nancy/projects/{project}.yaml
  const project = await loadProjectConfig(options.project).catch(() => undefined)

  // 3. Auto-detect language, framework, git info
  const detected = await detectContext(options.cwd)

  return { user, project, detected }
}
```

### 2. Select Templates

```typescript
// src/prompts/assemble.ts

function selectTemplates(context: ContextUsed, mode: 'worker' | 'planner'): string[] {
  const selected: string[] = []

  // Always include core
  selected.push('core.principles')

  // Include user identity if available
  if (context.user) {
    selected.push('user.identity')
  }

  // Include language-specific templates
  const languages = Array.isArray(context.detected.language)
    ? context.detected.language
    : [context.detected.language]

  for (const lang of languages) {
    if (lang === 'typescript') selected.push('eng.typescript')
    if (lang === 'go') selected.push('eng.go')
    if (lang === 'python') selected.push('eng.python')
  }

  // Include workflow templates
  selected.push('workflow.linear')

  // Include Nancy-specific for worker mode
  if (mode === 'worker') {
    selected.push('workflow.nancy-issues')
  }

  return selected
}
```

### 3. Load & Interpolate Templates

```typescript
// src/prompts/templates.ts

async function loadTemplate(id: string): Promise<{
  content: string
  metadata: any
}> {
  const filePath = path.join(__dirname, '../../prompts', `${id}.md`)
  const raw = await fs.readFile(filePath, 'utf-8')

  // Parse frontmatter if present
  const { data, content } = matter(raw)

  return { content, metadata: data }
}

// src/prompts/interpolate.ts

function interpolate(template: string, context: ContextUsed): string {
  // Simple variable replacement for now
  // Later: use Handlebars or similar for conditionals

  let result = template

  // User context
  if (context.user) {
    result = result.replace(/\{\{user\.name\}\}/g, context.user.name)
    result = result.replace(/\{\{user\.role\}\}/g, context.user.role || 'Developer')
  }

  // Project context
  if (context.project) {
    result = result.replace(/\{\{project\.name\}\}/g, context.project.name)
    result = result.replace(/\{\{project\.type\}\}/g, context.project.type)
  }

  // Detected context
  result = result.replace(/\{\{detected\.language\}\}/g,
    Array.isArray(context.detected.language)
      ? context.detected.language.join(', ')
      : context.detected.language
  )

  return result
}
```

### 4. Assemble

```typescript
// src/prompts/assemble.ts

export async function assemblePrompt(
  templateIds: string[],
  context: ContextUsed
): Promise<AssembledPrompt> {
  // Load all templates
  const templates = await Promise.all(
    templateIds.map(async (id) => {
      const { content, metadata } = await loadTemplate(id)
      return {
        id,
        content,
        priority: metadata.priority || 50,
        file: `prompts/${id}.md`
      }
    })
  )

  // Sort by priority
  templates.sort((a, b) => a.priority - b.priority)

  // Interpolate each template
  const interpolated = templates.map(t => ({
    ...t,
    content: interpolate(t.content, context)
  }))

  // Combine with markers
  const sections = interpolated.map(t =>
    `<!-- BEGIN: ${t.id} | priority: ${t.priority} | ${t.file} -->\n` +
    t.content.trim() +
    `\n<!-- END: ${t.id} -->`
  )

  const content = sections.join('\n\n---\n\n')

  // Build metadata
  const metadata = {
    templates: interpolated.map(t => ({
      id: t.id,
      file: t.file,
      priority: t.priority
    })),
    context,
    assembledAt: new Date().toISOString(),
    cacheKey: hashContent([content, JSON.stringify(context)])
  }

  return { content, metadata }
}
```

---

## Usage in Nancy

```typescript
// In Nancy worker
import { assembleWorkerPrompt } from './prompts'

async function executeIssue(issue: LinearIssue) {
  // Assemble prompt for this execution
  const prompt = await assembleWorkerPrompt({
    project: 'nancy',
    issue: issue,
    cwd: process.cwd()
  })

  // Use prompt.content as system message for Claude
  const response = await claude.messages.create({
    model: 'claude-sonnet-4',
    system: prompt.content,
    messages: [...]
  })

  // Log metadata for debugging
  console.log('Prompt assembled from:', prompt.metadata.templates.map(t => t.id))
}
```

---

## Config File Examples

### User Config: `~/.nancy/config.yaml`

```yaml
user:
  name: Stuart
  role: Senior Developer
  preferences:
    codeReview: thorough
    testing: comprehensive
    documentation: minimal
```

### Project Config: `~/.nancy/projects/nancy.yaml`

```yaml
project:
  name: nancy
  type: production
  techStack:
    languages:
      - TypeScript
      - Go
    frameworks:
      - Node.js
    tools:
      - Linear
      - Git Worktrees
  patterns:
    - Functional programming style
    - Minimal abstractions
    - Convention over configuration
  constraints:
    - Must work offline
    - Fast execution
```

---

## Template Catalog: `prompts/_catalog.yaml`

```yaml
templates:
  - id: core.principles
    domain: core
    priority: 0
    description: Core Nancy principles and values

  - id: user.identity
    domain: user
    priority: 10
    description: User identity and preferences
    requires:
      - user context in config

  - id: eng.typescript
    domain: eng
    category: lang
    priority: 50
    description: TypeScript coding guidelines
    conditions:
      - detected.language == "typescript"

  - id: workflow.linear
    domain: workflow
    priority: 70
    description: Linear integration workflow

  - id: workflow.nancy-issues
    domain: workflow
    priority: 72
    description: Nancy-specific issue organization
    conditions:
      - mode == "worker"
```

---

## Implementation Phases

### Phase 1: Minimal Working Version
1. Hard-code template selection (no catalog yet)
2. Simple variable interpolation (no Handlebars)
3. Basic context loading (YAML files)
4. Simple assembly (concatenate templates)

### Phase 2: Template System
1. Template catalog loading
2. Conditional template selection
3. Priority-based ordering
4. Metadata tracking

### Phase 3: Advanced Features
1. Handlebars for complex interpolation
2. Template validation
3. Caching assembled prompts
4. CLI for debugging

---

## Next Steps

1. Implement `src/prompts/` with Phase 1 features
2. Create initial templates in `prompts/`
3. Test with Nancy worker execution
4. Iterate based on real usage
5. Extract to separate tool once patterns are clear

---

**Key Insight**: Build what Nancy needs TODAY, not a generic system for tomorrow.
