# Configuration Format Strategy for Nancy: Final Synthesis (2026)

**Date**: 2026-01-24
**Status**: Final Recommendation
**Context**: Nancy AI/LLM tool ecosystem - TypeScript/Node CLI for developers

---

## Executive Summary

**TL;DR**: Use **YAML for configuration**, **Markdown for content**, **JSON for data**, **SQLite for state**. Skip TOML.

### The Verdict

After reviewing configuration patterns across modern tools (2025-2026), analyzing battle-tested composition strategies, and considering Nancy's specific needs as an AI/LLM developer tool, the recommendation is:

1. **YAML**: Primary human-editable configuration format
2. **Markdown + YAML frontmatter**: Content/prompt definitions (beads, agents, skills)
3. **JSON**: Machine-generated configs, data interchange, API responses
4. **SQLite**: Persistent state, session history, structured data
5. **TOML**: Skip it entirely

This is **not** a controversial take in 2026. It's the boring, proven choice.

---

## Part 1: TOML Reality Check

### The Hard Truth About TOML (2026)

TOML had momentum around 2018-2022, primarily due to Rust/Cargo adoption. However, by 2026, the landscape has clarified:

#### Where TOML Won
- **Rust ecosystem**: `Cargo.toml` is the standard (not changing)
- **Python packaging**: `pyproject.toml` via PEP 518 (established 2017)
- **Hugo**: Static site generator default
- **pipx, uv, rye**: Python tooling follows pyproject.toml convention

#### Where TOML Lost or Stagnated
- **Kubernetes/Cloud Native**: YAML is ubiquitous (100+ projects)
- **CI/CD**: GitHub Actions, GitLab CI, CircleCI all use YAML
- **AI/ML Tools**: Overwhelming preference for YAML or JSON
- **Node.js/TypeScript**: JSON/JSON5 dominant, YAML when human-friendly needed
- **Developer tooling**: Mixed, trending toward "whatever users already know"

#### The Core Problem: TOML's Niche is Narrow

TOML was designed for one thing: **simple configuration files**. It excels at:
```toml
[server]
host = "localhost"
port = 8080
debug = true

[[workers]]
name = "worker-1"
threads = 4
```

But it fails at:
- **Deep nesting**: Becomes verbose and awkward
- **Complex data structures**: Lists of maps, polymorphic types
- **Composition**: No native merge/overlay/inheritance
- **Templates**: No variable substitution
- **Human-readable complex data**: YAML's block scalars, anchors win

### The Criticisms That Matter for Nancy

1. **Poor Composition Story**
   - No `allOf`, `extends`, `anchors`, or native merging
   - Each file is isolated
   - Overlay patterns (Kustomize-style) don't work
   - Nancy needs: base configs + user overrides + project-specific

2. **Awkward for AI Context**
   - Nancy's "beads" are prompts/context with metadata
   - Long text content in TOML is painful:
     ```toml
     content = """
     Line 1
     Line 2
     Line 3"""
     ```
   - Compare to YAML:
     ```yaml
     content: |
       Line 1
       Line 2
       Line 3
     ```
   - Or Markdown:
     ```markdown
     ---
     metadata: here
     ---
     # Natural content flows
     ```

3. **TypeScript Ecosystem Mismatch**
   - Nancy is TypeScript/Node
   - No standard TOML parser in Node (unlike `js-yaml`, native JSON)
   - Most popular: `@iarna/toml` (2.5k GitHub stars, last updated 2020)
   - Compare: `js-yaml` (6.2k stars, actively maintained)
   - Developers expect JSON/YAML, not TOML

4. **No Network Effect**
   - Nancy users are already comfortable with:
     - JSON (package.json, tsconfig.json, .vscode/settings.json)
     - YAML (docker-compose.yml, .github/workflows, k8s)
     - Markdown (README.md, docs)
   - Learning TOML = cognitive overhead for **zero benefit**

5. **Limited Tooling**
   - JSON: Every editor, linter, schema validator
   - YAML: Excellent support, JSON Schema validation via yaml-language-server
   - TOML: Basic syntax highlighting, limited validation

### Decision: Drop TOML

**Reasons**:
1. Nancy is **not in Rust/Python packaging ecosystem** where TOML is standard
2. Nancy needs **composition** (user + project + team configs)
3. Nancy handles **complex nested data** (prompts, context, multi-step plans)
4. Nancy's users expect **TypeScript/Node conventions**
5. TOML adds **no value** over YAML for Nancy's use cases

**Counter-argument addressed**: "TOML is simpler/less error-prone than YAML"
- **Response**: True for trivial configs, false for Nancy's needs. Nancy's configs aren't trivial. The "YAML gotchas" (Norway problem, implicit types) are solved by:
  - JSON Schema validation
  - Explicit type annotations in schema
  - Modern YAML 1.2 spec (most parsers support)
  - Linting (yamllint, prettier)

---

## Part 2: 2026 Zeitgeist - What Are Modern Tools Actually Using?

### Survey: AI/LLM Tools (2025-2026)

| Tool | Primary Config | Notes |
|------|---------------|-------|
| **LangChain** | Python/TypeScript code | Programmatic, not file-based |
| **CrewAI** | YAML | Agent definitions, workflows |
| **AutoGPT** | JSON/YAML | Config in JSON, prompts in YAML |
| **AgentGPT** | JSON | Next.js, JSON config |
| **Semantic Kernel** | JSON/Code | C#/Python, JSON configs |
| **SuperAGI** | YAML | Agent configs |
| **Haystack** | YAML | Pipeline definitions |
| **Agentic-flow** | JSON + YAML + Markdown | Multi-format strategy |

**Observation**: YAML dominates for agent/workflow definitions. JSON for machine configs. Markdown for content.

### Survey: Developer CLI Tools (2025-2026)

| Tool | Config Format | Why |
|------|--------------|-----|
| **Claude Desktop** | JSON | User config, MCP servers |
| **GitHub CLI (gh)** | YAML | Config, workflows |
| **Vercel CLI** | JSON | vercel.json, package.json |
| **Terraform** | HCL | Domain-specific, not general |
| **Docker** | YAML | docker-compose.yml |
| **Kubernetes** | YAML | Manifests, CRDs |
| **Deno** | JSON | deno.json |
| **Bun** | JSON | bunfig.toml exists but JSON preferred |

**Observation**: JSON for TypeScript/Node tools. YAML for orchestration/composition. No new major tools chose TOML.

### Emerging Formats (2024-2026)

| Format | Status | Verdict |
|--------|--------|---------|
| **CUE** | Niche (k8s, config validation) | Too exotic for Nancy |
| **Dhall** | Academic/niche | Dead for mainstream |
| **Nickel** | Experimental | Watch, don't adopt |
| **JSON5** | Growing (linters, Bun) | Viable for config that's "almost JSON" |
| **JSONC** | VSCode standard | Comments in JSON, good for examples |
| **KCL** | KusionStack project | Too new, k8s-specific |

**Observation**: No "YAML killer" emerged. Format innovation is in **validation/typing** (CUE, Dhall), not syntax. The market has spoken: YAML for humans, JSON for machines, done.

### The 2026 Consensus

**Among new developer tools**: "Use what users already know"
- JSON if TypeScript/Node
- YAML if composition/orchestration
- Markdown for content
- Don't invent new formats

**Among AI/LLM tools**: "YAML for agents, JSON for config, Markdown for prompts"
- Pattern: Separation of concerns
- Prompts are content (Markdown)
- Configs are data (YAML/JSON)
- State is structured (SQLite/DB)

**Format fatigue is real**: Developers don't want to learn TOML, HCL, or custom formats unless there's a compelling reason (Rust/Cargo, Terraform/HCL).

---

## Part 3: Risk-Adjusted Recommendation for Nancy

### Primary Format Choice: YAML

**Use YAML for**:
- User configuration (`~/.nancy/config.yaml`)
- Project configuration (`nancy.yaml`, `.nancy/config.yaml`)
- Agent/skill definitions (with frontmatter)
- Workflow/pipeline definitions
- Multi-environment configs

**Why YAML**:
1. **Composition**: Anchors, aliases, merge keys
2. **Human-friendly**: Block scalars, comments, readable
3. **Ecosystem**: JSON Schema validation, excellent tooling
4. **Network effect**: Users know it from Docker, K8s, GitHub Actions
5. **TypeScript support**: `js-yaml` is excellent, TypeScript types available

**YAML Best Practices for Nancy**:
```yaml
# Always specify version
version: 1

# Use explicit types to avoid Norway problem
port: !!int 8080
enabled: !!bool true

# Block scalars for multi-line strings
prompt: |
  You are a helpful assistant.
  You follow instructions carefully.

# Anchors for reuse
defaults: &defaults
  timeout: 30
  retries: 3

production:
  <<: *defaults
  timeout: 60

# Comments are valuable
# This setting controls X behavior
feature_flag: true
```

### Secondary Format: Markdown + YAML Frontmatter

**Use Markdown + YAML for**:
- Beads (prompt fragments)
- Agent system prompts
- Skill definitions
- Templates
- Documentation with metadata

**Pattern** (from Agentic-flow):
```markdown
---
name: skill-name
type: developer
version: 1.0
tags: [coding, review]
---

# System Prompt

You are a senior software engineer...

## Guidelines

- Write clean code
- Follow best practices
```

**Why this pattern**:
- Content is naturally in Markdown (prompts, instructions)
- Metadata is structured (YAML frontmatter)
- Single-file artifacts (easy to share, version)
- Git-friendly (readable diffs)
- Tooling exists (gray-matter, front-matter parsers)

### Tertiary Format: JSON

**Use JSON for**:
- Machine-generated configs
- Cache files
- Session state (before moving to SQLite)
- API responses
- Tool/plugin manifests
- Lock files

**Why JSON**:
- Native to JavaScript/TypeScript
- Fast parsing
- Strict validation
- Universal interchange format
- JSONC/JSON5 for human-edited variants

### Quaternary: SQLite

**Use SQLite for**:
- Session history
- Task/phase state
- Trajectory tracking
- Metrics/telemetry
- Structured query needs

**Why SQLite** (already decided for nancy-bubble-gum):
- ACID guarantees
- Complex queries
- No external dependencies
- Single-file database
- Excellent Node.js support (better-sqlite3)

### Hedge: Support Multiple Formats (Limited)

**Auto-detect pattern**:
```typescript
// Nancy config resolution
const CONFIG_FILES = [
  'nancy.yaml',    // Preferred
  'nancy.yml',     // Accepted
  'nancy.json',    // Supported
  '.nancy/config.yaml',
  '.nancy/config.json',
];

function loadConfig(): Config {
  for (const file of CONFIG_FILES) {
    if (exists(file)) {
      return file.endsWith('.json')
        ? JSON.parse(readFile(file))
        : yaml.load(readFile(file));
    }
  }
  return defaultConfig();
}
```

**Support matrix**:
| Format | User Config | Project Config | Beads | Agents | State |
|--------|------------|---------------|-------|--------|-------|
| YAML | Primary | Primary | With MD | With MD | No |
| JSON | Fallback | Fallback | No | No | Cache only |
| Markdown | No | No | Primary | Primary | No |
| SQLite | No | No | No | No | Primary |
| TOML | **No** | **No** | **No** | **No** | **No** |

---

## Part 4: Contrarian Takes

### What if we go against the trend?

**Option A: All-in on TOML**
- **Upside**: Simpler parser, less ambiguity
- **Downside**: Poor composition, awkward for Nancy's needs, ecosystem mismatch
- **Verdict**: Bad idea. Fighting users' expectations for zero benefit.

**Option B: All-in on JSON**
- **Upside**: Fastest parsing, universal format, strict validation
- **Downside**: No comments (need JSONC), verbose for humans
- **Verdict**: Viable but less friendly. JSON5/JSONC mitigates issues.

**Option C: Custom DSL (Nancy-specific format)**
- **Upside**: Perfectly tailored to Nancy
- **Downside**: Learning curve, tooling burden, maintenance cost
- **Verdict**: Hell no. This is how projects die.

**Option D: HCL (HashiCorp Configuration Language)**
- **Upside**: Great for infrastructure as code
- **Downside**: Not better than YAML for Nancy's use case, less familiar
- **Verdict**: No compelling reason.

### What if we embrace the trend?

**Option E: YAML + Markdown + JSON + SQLite (Recommended)**
- **Upside**: Each format used for its strengths, familiar to users
- **Downside**: Multiple parsers, slight complexity
- **Verdict**: This is the right choice. "Boring technology."

### What's the safest bet?

**"Boring Technology" Principle** (Dan McKinley):
- Choose mature, well-understood technology
- Save innovation budget for core features
- Don't solve problems you don't have

**Applied to Nancy**:
- YAML is boring (mature, understood, tooled)
- JSON is boring (native, fast, universal)
- Markdown is boring (ubiquitous, readable)
- SQLite is boring (battle-tested, embedded, fast)
- TOML is "interesting" (niche, requires justification)

**Safest bet**: YAML + Markdown + JSON + SQLite

---

## Part 5: Practical Guidance - Decision Tree

### When to Use Each Format

```
Is it human-editable configuration?
├─ Yes → YAML (nancy.yaml, config.yaml)
└─ No
   └─ Is it content with metadata (prompts, agents)?
      ├─ Yes → Markdown + YAML frontmatter
      └─ No
         └─ Is it machine-generated or API data?
            ├─ Yes → JSON
            └─ No
               └─ Is it persistent state needing queries?
                  ├─ Yes → SQLite
                  └─ No → Reconsider requirements
```

### Specific Use Cases

| Use Case | Format | Example |
|----------|--------|---------|
| User preferences | YAML | `~/.nancy/config.yaml` |
| Project settings | YAML | `nancy.yaml` |
| Agent definition | Markdown + YAML | `.claude/agents/coder.md` |
| Bead (prompt fragment) | Markdown + YAML | `beads/user-style.md` |
| Skill definition | Markdown + YAML | `skills/code-review.md` |
| MCP server config | JSON | `.nancy/mcp-servers.json` |
| Session state | SQLite | `.nancy/state.db` |
| Cache data | JSON | `.nancy/cache/*.json` |
| Lock file | JSON | `.nancy/nancy-lock.json` |
| Metrics/telemetry | SQLite | `.nancy/metrics.db` |

### YAML Structure Guidelines

**User Config** (`~/.nancy/config.yaml`):
```yaml
version: 1

# Core settings
model:
  provider: anthropic
  name: claude-sonnet-4-5
  temperature: 0.7

# Cascading config paths
config_paths:
  - ~/.nancy/config.yaml      # User global
  - ${CWD}/nancy.yaml         # Project
  - ${CWD}/.nancy/config.yaml # Project .nancy

# Environment variable substitution
api_key: ${ANTHROPIC_API_KEY}
cache_dir: ${NANCY_CACHE_DIR:-~/.nancy/cache}

# Feature flags
features:
  enable_beads: true
  enable_trajectory_tracking: true
  enable_reasoning_bank: false

# Extensibility escape hatch
custom:
  # Arbitrary user-specific config
  my_tool_setting: value
```

**Project Config** (`nancy.yaml`):
```yaml
version: 1

project:
  name: my-app
  language: typescript
  framework: react

beads:
  # Load these beads for this project
  - ~/.nancy/beads/user-style.yaml
  - .nancy/beads/project-context.yaml
  - .nancy/beads/team-standards.yaml

agents:
  # Load custom agents
  - .claude/agents/custom-reviewer.md

overrides:
  # Project-specific overrides
  model:
    temperature: 0.5
```

**Bead Definition** (`beads/user-style.md`):
```markdown
---
apiVersion: nancy.io/v1
kind: Bead
metadata:
  name: user-code-style
  tags: [style, coding, personal]
  priority: 10
spec:
  type: system-prompt-fragment
  context: coding
---

# Code Style Preferences

When writing code, follow these preferences:

- Use descriptive variable names
- Prefer functional programming patterns
- Write comprehensive tests

## TypeScript Specific

- Always define return types
- Use `const` over `let`
- Avoid `any` type
```

### Validation Strategy

1. **JSON Schema for YAML**:
   - Define schemas for all YAML configs
   - Validate on load, provide clear errors
   - IDE integration via yaml-language-server

2. **TypeScript Types**:
   - Generate TypeScript types from JSON Schema
   - Type-safe config loading
   - Example: `json-schema-to-typescript`

3. **Zod for Runtime Validation**:
   ```typescript
   import { z } from 'zod';

   const ConfigSchema = z.object({
     version: z.number(),
     model: z.object({
       provider: z.enum(['anthropic', 'openai']),
       name: z.string(),
       temperature: z.number().min(0).max(1),
     }),
   });

   type Config = z.infer<typeof ConfigSchema>;

   function loadConfig(raw: unknown): Config {
     return ConfigSchema.parse(raw); // Throws on invalid
   }
   ```

### Composition Strategy

**Pattern**: Cascading with explicit merge
```typescript
import { merge } from 'lodash';
import yaml from 'js-yaml';

function loadConfigCascade(): Config {
  const configs = [
    loadYaml('~/.nancy/config.yaml'),           // User global
    loadYaml(process.env.NANCY_CONFIG),         // Env override
    loadYaml('./nancy.yaml'),                   // Project
    loadYaml('./.nancy/config.yaml'),           // Project .nancy
  ].filter(exists);

  // Deep merge, later overrides earlier
  const merged = configs.reduce((acc, cfg) => merge(acc, cfg), {});

  // Environment variable substitution
  return substituteEnvVars(merged);
}

function substituteEnvVars(obj: any): any {
  // Replace ${VAR} and ${VAR:-default}
  // (Implementation from Agentic-flow pattern)
}
```

---

## Part 6: Counter-Arguments Addressed

### "YAML has too many footguns"

**Claim**: YAML's implicit typing (Norway → false, 0x10 -> 16) causes bugs.

**Response**:
1. Use YAML 1.2 (fixes most issues)
2. JSON Schema validation catches errors
3. Explicit type tags when needed: `!!str "010"`
4. Linting (yamllint) prevents common mistakes
5. Nancy's configs are simple, not complex enough for edge cases

**Real talk**: Yes, YAML has quirks. So does every format. TOML has `[[array.of.tables]]` confusion. JSON has no comments. The benefits of YAML (composition, readability) outweigh the risks for Nancy.

### "TOML is simpler to parse"

**Claim**: TOML spec is simpler, less ambiguous.

**Response**:
1. True, but **irrelevant**. Nancy doesn't implement parsers, it uses libraries.
2. `js-yaml` is mature, well-tested, widely used.
3. Parser complexity is not user complexity.
4. YAML's expressiveness (anchors, blocks) saves user effort.

### "JSON is sufficient"

**Claim**: Why not just JSON everywhere?

**Response**:
1. No comments (JSONC/JSON5 adds them, but not standard)
2. Verbose for humans (trailing commas, quotes everywhere)
3. Poor for long text (prompts, docs)
4. Markdown + frontmatter is superior for content

**Compromise**: JSON for machine-generated, YAML for human-edited.

### "Markdown frontmatter is non-standard"

**Claim**: YAML frontmatter is a convention, not a spec.

**Response**:
1. Widely adopted: Jekyll, Hugo, Astro, Obsidian, VSCode agents
2. Clear boundary (`---` delimiters)
3. Excellent parsers: `gray-matter` (Node), `python-frontmatter` (Python)
4. Natural fit for Nancy's beads/agents

### "Supporting multiple formats is complex"

**Claim**: Supporting YAML + JSON + Markdown + SQLite is too much.

**Response**:
1. Each format serves a **distinct purpose**
2. Users don't think about it (conventions guide them)
3. Auto-detection is trivial (file extension)
4. Complexity is in Nancy's internals, not user experience

### "Why not follow Rust/Cargo and use TOML?"

**Claim**: Cargo.toml is great, Nancy should copy it.

**Response**:
1. Nancy is **not Cargo**. Different ecosystem, different needs.
2. Cargo is Rust; Nancy is TypeScript/Node (JSON/YAML conventions)
3. Cargo's needs are simpler (package metadata, deps, build config)
4. Nancy's needs are more complex (prompts, agents, composition, state)

---

## Part 7: Decision Framework

### Evaluation Criteria

| Criterion | Weight | YAML | JSON | TOML | Markdown | SQLite |
|-----------|--------|------|------|------|----------|--------|
| Human readability | High | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |
| Composition | High | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | N/A |
| TypeScript support | High | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| Nested data | High | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| Long text content | Medium | ⭐⭐⭐⭐ | ⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| Comments | Medium | ⭐⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | N/A |
| Validation/Schema | High | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| User familiarity | High | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| Ecosystem | High | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| Queries/Relations | N/A | N/A | N/A | N/A | N/A | ⭐⭐⭐⭐⭐ |

**Legend**:
- ⭐⭐⭐⭐⭐ Excellent
- ⭐⭐⭐⭐ Good
- ⭐⭐⭐ Acceptable
- ⭐⭐ Poor
- ⭐ Very poor

### Format Selection Flowchart

```
START
  |
  v
Is it PERSISTENT STATE with QUERIES?
  |
  ├─ YES → SQLite (state.db)
  |
  └─ NO
     |
     v
Is it CONTENT with METADATA (prompts/agents)?
     |
     ├─ YES → Markdown + YAML frontmatter
     |
     └─ NO
        |
        v
Is it CONFIGURATION (settings/options)?
        |
        ├─ YES
        |  |
        |  v
        |  Human-editable?
        |     |
        |     ├─ YES → YAML
        |     |
        |     └─ NO → JSON
        |
        └─ NO
           |
           v
Is it DATA INTERCHANGE (API/cache)?
              |
              └─ YES → JSON
```

---

## Part 8: Implementation Roadmap

### Phase 1: Foundation (MVP)
**Goal**: Basic config loading with validation

1. **YAML Config Loader**
   ```typescript
   // src/config/loader.ts
   import yaml from 'js-yaml';
   import { merge } from 'lodash';
   import { ConfigSchema } from './schema';

   export function loadConfig(): Config {
     const cascade = [
       '~/.nancy/config.yaml',
       './nancy.yaml',
       './.nancy/config.yaml',
     ];

     const configs = cascade
       .map(loadYaml)
       .filter(exists);

     const merged = configs.reduce((acc, cfg) => merge(acc, cfg), {});
     return ConfigSchema.parse(merged);
   }
   ```

2. **JSON Schema Definition**
   ```yaml
   # schema/config.schema.yaml
   $schema: http://json-schema.org/draft-07/schema#
   type: object
   required: [version]
   properties:
     version:
       type: number
       const: 1
     model:
       type: object
       properties:
         provider:
           type: string
           enum: [anthropic, openai]
   ```

3. **Environment Variable Substitution**
   ```typescript
   function substituteEnvVars(obj: any): any {
     const pattern = /\$\{([^}:]+)(?::-([^}]+))?\}/g;
     // Implementation: replace ${VAR:-default}
   }
   ```

### Phase 2: Markdown + Frontmatter
**Goal**: Load beads and agents

1. **Frontmatter Parser**
   ```typescript
   import matter from 'gray-matter';

   export function loadBead(path: string): Bead {
     const file = readFileSync(path, 'utf8');
     const { data, content } = matter(file);

     return {
       metadata: BeadMetadataSchema.parse(data),
       content: content.trim(),
     };
   }
   ```

2. **Bead Schema**
   ```yaml
   # schema/bead.schema.yaml
   type: object
   required: [apiVersion, kind, metadata]
   properties:
     apiVersion:
       type: string
       pattern: "^nancy\\.io/v\\d+$"
     kind:
       type: string
       const: Bead
     metadata:
       type: object
       required: [name]
       properties:
         name: {type: string}
         tags: {type: array, items: {type: string}}
         priority: {type: number, default: 0}
   ```

### Phase 3: Composition
**Goal**: Merge configs, override patterns

1. **Overlay Pattern**
   ```typescript
   function applyOverlays(base: Config, overlays: Config[]): Config {
     // Deep merge with array replacement
     return overlays.reduce((acc, overlay) => {
       return merge(acc, overlay, {
         // Custom merge for arrays
         arrayMerge: (dest, source) => source, // Replace
       });
     }, base);
   }
   ```

2. **Anchor Support**
   ```yaml
   # nancy.yaml
   defaults: &defaults
     timeout: 30
     retries: 3

   development:
     <<: *defaults
     debug: true

   production:
     <<: *defaults
     timeout: 60
   ```

### Phase 4: SQLite State
**Goal**: Persistent state, session history

1. **Database Schema**
   ```sql
   CREATE TABLE sessions (
     id TEXT PRIMARY KEY,
     created_at INTEGER NOT NULL,
     updated_at INTEGER NOT NULL,
     metadata JSON
   );

   CREATE TABLE beads_applied (
     session_id TEXT,
     bead_name TEXT,
     applied_at INTEGER,
     FOREIGN KEY (session_id) REFERENCES sessions(id)
   );
   ```

2. **State Manager**
   ```typescript
   import Database from 'better-sqlite3';

   export class StateManager {
     private db: Database.Database;

     constructor(dbPath: string) {
       this.db = new Database(dbPath);
       this.migrate();
     }

     saveSession(session: Session): void {
       this.db.prepare(`
         INSERT INTO sessions (id, created_at, updated_at, metadata)
         VALUES (?, ?, ?, ?)
       `).run(session.id, Date.now(), Date.now(), JSON.stringify(session.metadata));
     }
   }
   ```

---

## Part 9: Next Steps

### Immediate Actions

1. **Create `schema/` directory**
   - `config.schema.yaml` - User/project config schema
   - `bead.schema.yaml` - Bead definition schema
   - `agent.schema.yaml` - Agent definition schema

2. **Implement config loader**
   - Cascading YAML loading
   - Environment variable substitution
   - Validation with Zod
   - Error handling with clear messages

3. **Document format choices**
   - User-facing docs explaining when to use each format
   - Examples for common use cases
   - Migration guide (if transitioning from other formats)

4. **Set up validation pipeline**
   - Pre-commit hooks (yamllint)
   - CI validation (schema checks)
   - IDE integration (yaml-language-server)

### Future Enhancements

1. **Configuration UI** (Optional)
   - Web-based config editor
   - Visual bead composer
   - Schema-driven forms

2. **Conversion Tools**
   - `nancy config migrate` - Migrate old formats
   - `nancy config validate` - Check config validity
   - `nancy config merge` - Preview merged config

3. **Advanced Composition**
   - Kustomize-style patches
   - Conditional includes
   - Environment-specific overlays

---

## Part 10: Final Recommendation

### The Nancy Format Strategy

**Primary Formats**:
1. **YAML** - Configuration (user, project, overrides)
2. **Markdown + YAML** - Content with metadata (beads, agents, skills)
3. **JSON** - Machine-generated, data interchange
4. **SQLite** - Persistent state, structured queries

**Rationale**:
- Each format serves a distinct, appropriate purpose
- Aligns with user expectations (TypeScript/Node ecosystem)
- Enables composition and extensibility
- Supported by excellent tooling
- "Boring technology" - proven, mature, stable

**Explicitly Rejected**:
- **TOML**: No compelling advantage for Nancy's use case
- **Custom DSL**: Unnecessary complexity
- **HCL**: Not better than YAML for Nancy
- **CUE/Dhall/Nickel**: Too exotic

### Why This Is Right for Nancy (2026)

1. **User Empathy**
   - Developers already know YAML, JSON, Markdown
   - No learning curve
   - Familiar patterns from Docker, K8s, GitHub Actions

2. **Composability**
   - YAML anchors, merge keys
   - Cascading config resolution
   - Overlay patterns (base + overrides)

3. **Ecosystem Fit**
   - TypeScript/Node conventions
   - AI/LLM tool patterns (CrewAI, Haystack, Agentic-flow)
   - Developer CLI standards (gh, docker, kubectl)

4. **Future-Proof**
   - YAML isn't going anywhere (30+ years of momentum)
   - JSON is the universal interchange format
   - Markdown is ubiquitous for content
   - SQLite is the world's most deployed database

5. **Boring Technology Win**
   - Mature parsers, validators, tools
   - Large knowledge base (StackOverflow, docs)
   - No surprises, no regrets

### The Anti-TOML Take (Final Word)

TOML is fine. It's a good format. But it's **wrong for Nancy**.

- It doesn't solve any problem Nancy has
- It creates problems Nancy doesn't need (poor composition, awkward text)
- It adds cognitive load for users (new syntax, no network effect)
- It's a "solution looking for a problem" in Nancy's context

**Choose boring. Choose proven. Choose what users know.**

**YAML + Markdown + JSON + SQLite. Ship it.**

---

**Date**: 2026-01-24
**Author**: Claude (Sonnet 4.5)
**Status**: Final Recommendation - Ready for Implementation
**Next**: Implement Phase 1 (config loader, schemas, validation)
